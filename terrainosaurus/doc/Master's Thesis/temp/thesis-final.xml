<?xml version="1.0" encoding="UTF-8"?>
<book xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:mml="http://www.w3.org/1998/Math/MathML">
  <bookinfo>
    <title>Terrainosaurus</title>
    <subtitle>Realistic Terrain Synthesis Using Genetic Algorithms</subtitle>
    <authorgroup>
      <author>
        <firstname>Ryan</firstname>
        <othername role="mi">L.</othername>
        <surname>Saunders</surname>
        <contrib>Student</contrib>
      </author>
      <editor>
        <honorific>Dr</honorific>
        <firstname>John</firstname>
        <surname>Keyser</surname>
        <contrib>Chair of Committee</contrib>
      </editor>
      <editor>
        <honorific>Dr</honorific>
        <firstname>Glen</firstname>
        <surname>Williams</surname>
        <contrib>Member</contrib>
      </editor>
      <editor>
        <honorific>Dr</honorific>
        <firstname>Donald</firstname>
        <surname>House</surname>
        <contrib>Member</contrib>
      </editor>
      <editor>
        <honorific>Dr</honorific>
        <firstname>Valerie</firstname>
        <surname>Taylor</surname>
        <contrib>Head of Department</contrib>
      </editor>
    </authorgroup>

    <date>December 2006</date>
    <orgname>Texas A&amp;M University</orgname>
    <bibliomisc role="degree">Master of Science</bibliomisc>
    <bibliomisc role="major-subject">Computer Science</bibliomisc>

    
    <abstract id="Abstract" xml:base="abstract.xml">
  <title>Abstract</title>
  <para>
    Synthetically generated terrain models are useful across a broad range of 
    applications, including computer generated art &amp; animation, virtual 
    reality and gaming, and architecture. Existing algorithms for terrain 
    generation suffer from a number of problems, especially that of being 
    limited in the types of terrain that they can produce and of being 
    difficult for the user to control. Typical applications of synthetic 
    terrain have several factors in common: first, they require the generation 
    of large regions of believable (though not necessarily physically correct) 
    terrain features; and second, while real-time performance is often needed 
    when <emphasis>visualizing</emphasis> the terrain, this is generally not 
    the case when <emphasis>generating</emphasis> the terrain.
  </para>
  <para>
    In this thesis, I present a new, design-by-example method for synthesizing 
    terrain height fields. In this approach, the user designs the layout of the 
    terrain by sketching out simple regions using a CAD-style interface, and 
    specifies the desired terrain characteristics of each region by providing 
    example height fields displaying these characteristics (these height fields 
    will typically come from real-world GIS data sources). A height field 
    matching the user's design is generated at several levels of detail, using a 
    genetic algorithm to blend together chunks of elevation data from the 
    example height fields in a visually plausible manner.
  </para>
  <para>
    This method has the advantage of producing an unlimited diversity of 
    reasonably realistic results, while requiring relatively little user effort 
    and expertise. The guided randomization inherent in the genetic algorithm 
    allows the algorithm to come up with novel arrangements of features, while 
    still approximating user-specified constraints.
  </para>
</abstract>

  </bookinfo>


  
  

  
  <chapter id="Introduction" xml:base="introduction.xml">
  <title>Introduction</title>
  <para>
    <footnote label=" ">
      <para>
        This thesis follows the style and format of the <citetitle>Journal of the 
        ACM</citetitle>.
      </para>
    </footnote>
  </para>
  <para>
    Computer-rendered terrain is an important facet of most graphical 
    applications that attempt to represent the natural world in some way, 
    including CG-animated feature films, virtual reality systems, computer 
    games, and art. The ability to synthesize large-scale, realistic terrain 
    models is of considerable interest for many of these applications.
  </para>
  <figure id="Halo Screenshot" float="0">
    <title>An Outdoor Scene from Halo 2</title>
    <mediaobject>
      <caption>
        Modern graphics hardware is capable of rendering detailed terrain models 
        in real time, as in this scene captured from <citetitle>Halo 
          2</citetitle> (<xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Halo 2"/>).
      </caption>
      <imageobject>
        <imagedata scalefit="1" width="5in" fileref="Halo 2 Screenshot.jpeg"/>
      </imageobject>
    </mediaobject>
  </figure>
  <para>
    Much of the recent research in virtual terrain has centered around 
    accelerating the visualization of large terrains to achieve interactive 
    frame rates, resulting in a wide array of <firstterm>level of detail (LOD) 
      algorithms</firstterm>, methods of increasing rendering speed by omitting 
    details that are too far away or would be otherwise indiscernible to the 
    viewer <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="ROAM"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Chunked LOD"/> 
    <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Geometry Clipmaps"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Feature-based CLOD"/>.  Recent, dramatic advances in the performance and capabilities 
    of graphics acceleration hardware have enabled the interactive presentation 
    of richly-detailed terrain models, and have sparked increased interest in 
    representing outdoor phenomena, as evidenced by the prominence of 
    nature-related techniques at a recent <citetitle>Game Developer's 
      Conference</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="GDC 2002"/>. The visually 
    stunning outdoor scenes in recent game titles, such as <citetitle>Halo 
      2</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Halo 2"/> (<xref linkend="Halo Screenshot"/>), are solid evidence that believable terrain can be 
    visualized in real-time with current technology.
  </para>
  <para>
    Terrain generation, in contrast, has received comparatively little treatment 
    in the literature. Fractal-based techniques are the most prevalent, because 
    they are easily implemented, require relatively little processing time and 
    human input, and yield at least mediocre results, allowing random, unique 
    terrains to be generated rapidly.  However, as several authors <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Geometry Clipmaps"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Wavelet Synthesis"/> have 
    noted, fractal methods for terrain generation are limited in the types of 
    terrain they can simulate, and one generally has to resort to elevation maps 
    digitized from the real world to get more interesting and believable terrain 
    models.
  </para>
  <para>
    In this thesis, I present <citetitle>Terrainosaurus</citetitle>, a new 
    method of synthesizing realistic, heterogeneous (with respect to type of 
    terrain) height fields at multiple levels of detail.  This method departs 
    from current industry-standard approaches to terrain generation in several 
    important ways, most notably through the use of real-world terrain data as 
    raw material, and of artificial intelligence methods to control the 
    generation process.
  </para>
  <para>
    There are a number of desirable characteristics for a terrain generation 
    algorithm that could be optimized during its design, some of which are in 
    conflict with one another. However, not all of these characteristics are 
    equally important for all applications of terrain generation, and so, by 
    selecting a more narrowly construed problem, it is possible to make some 
    reasonable decisions as to which characteristics are of the highest 
    priority. <citetitle>Terrainosaurus</citetitle> is aimed at the needs of 
    "studio" users: artists, animators, simulation and video game designers, 
    people who typically have high goals for realism and quality, have powerful 
    computing resources at their disposal, and do <emphasis>not</emphasis> have 
    real-time processing constraints. This means that, in order to be maximally  
    useful to its target user base, <citetitle>Terrainosaurus</citetitle> should 
    optimize the following characteristics:
    <itemizedlist>
      <listitem>
        realism, such that the terrain models generated by it create a plausible 
        illusion of the real world
      </listitem>
      <listitem>
        extensibility, such that new types of terrain can be added to its 
        repertoire on an as-needed basis
      </listitem>
      <listitem>
        ease of use, such that a human user is not burdened with tedious detail 
        or arcane controls
      </listitem>
    </itemizedlist>
    The motivations and goals of <citetitle>Terrainosaurus</citetitle> are 
    covered in more depth in <xref linkend="Motivation"/>.
  </para>
  <para>
    The variant of the terrain generation problem most commonly addressed is 
    that of generating a digital elevation map, in the form of a discrete height 
    field: i.e., a rectangular grid of elevation values (<xref linkend="Overview - Height Field"/>).  This formulation of the problem is popular because of a 
      number of simplifications it makes:
    <itemizedlist>
      <listitem>
        for every <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>

</inlineequation> coordinate pair within the 
        bounds of the height field, there is precisely one corresponding 
        elevation value; thus, the resulting surface is manifold everywhere but 
        at the height field edges
      </listitem>
      <listitem>
        the horizontal spatial resolution is constant throughout the terrain, 
        being pre-defined by the resolution of the rectangular grid
      </listitem>
    </itemizedlist>
    The advantages and disadvantages of of height fields, as well as those of 
    several alternative representations for terrain, are discussed in <xref linkend="Terrain Representations"/>.
  </para>
  <figure id="Overview - Height Field" float="0">
    <title>A Height Field</title>
    <mediaobject>
      <caption>
        <citetitle>Terrainosaurus</citetitle> generates terrain in the form of 
        <firstterm>height fields</firstterm>, rectangular grids containing one 
        elevation value for each <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>
</inlineequation> coordinate pair.
      </caption>
      <imageobject>
        <imagedata scalefit="1" width="5in" fileref="Height Field Wireframe.jpeg"/>
      </imageobject>
    </mediaobject>
  </figure>
  <para>
    To this problem of terrain height field generation, we apply genetic 
    algorithms. Genetic algorithms are a class of techniques for solving 
    difficult optimization problems using the metaphor of biological 
    micro-evolution, and are discussed in further detail in <xref linkend="Genetic Algorithms Overview"/>. This approach allows the graceful 
    melding of competing goals, including design objectives specified by the 
    user and realism constraints largely outside of the user's direct control.
  </para>
  <para>
    From the perspective of a user, <citetitle>Terrainosaurus</citetitle> is 
    composed of three distinct phases (<xref linkend="Terrainosaurus Phases Overview"/>):
    <itemizedlist spacing="compact">
      <listitem>
        assembly of a library of <firstterm>terrain types</firstterm>, 
        collections of GIS elevation data (or <firstterm>terrain 
        samples</firstterm>) that possess similar characteristics and belong to 
        the same category of terrain in the user's mind
      </listitem>
      <listitem>
        authoring of a 2D "map" describing the size, shape, and locations of one 
        or more regions of terrain
      </listitem>
      <listitem>
        generation of a height field conforming to this map, with each region of 
        terrain evincing similar characteristics to those displayed by the 
        terrain samples belonging to the corresponding terrain type
      </listitem>
    </itemizedlist>
  </para>
  <figure id="Terrainosaurus Phases Overview" float="0">
    <title>The Three Phases of <citetitle>Terrainosaurus</citetitle>
</title>
    <mediaobject>
      <imageobject>
        <imagedata fileref="Terrainosaurus Phases Overview.svg"/>
      </imageobject>
    </mediaobject>
  </figure>
  <para>
    The first of these phases, the construction of the terrain library 
    (discussed in <xref linkend="Terrain Library Assembly"/>), is essentially a 
    classification process.  The user (or a third party) provides a number of 
    sample height fields, presumably from GIS data sources, and sorts them into 
    separate, logical terrain types. In this way, the user is able to construct 
    a "palette" of terrain types, with which he will later create his map. In so 
    doing, the user describes <emphasis>by example</emphasis> the 
    characteristics he desires to have in the generated terrain.
  </para>
  <para>
    At the moment, this process is entirely manual, and likely to be somewhat 
    tedious, as it relies on the user to compare terrain samples visually and to 
    determine terrain type membership on this basis.  Furthermore, not all GIS 
    elevation maps can be used as example terrains at the present time (the 
    presence of bodies of water, for example, significantly alters the 
    statistical characteristics of a height field, making it unsuitable as a 
    reference example).  In <xref linkend="Future Work"/>, I propose a number of 
    areas for future work with the potential both to ease the burden on the user 
    and to relax the restrictions on example height fields. Still, even in 
    <citetitle>Terrainosaurus</citetitle>'s current state, this is not as 
    cumbersome as it might seem, as this task need be performed only 
    infrequently: once assembled, a terrain library can be reused indefinitely.
  </para>
  <para>
    The second phase, the authoring of the map, is where the user will do most 
    of his work, and is also where he has the most freedom to create. The user 
    expresses his desired terrain configuration by sketching arbitrary polygonal 
    regions using a 2D CAD-style interface, and assigning each region a terrain 
    type from the library constructed in the first phase.
  </para>
  <para>
    Normally, the user will not want the boundaries between adjacent regions of 
    terrain to be rigidly linear, so in addition to normal polygon editing 
    operations, we provide a <firstterm>boundary refinement</firstterm> 
    operation, which is a genetic-algorithm-controlled subdivision operation, 
    replacing a straight boundary with a series of short linear segments, 
    forming an irregular, less artificial-looking boundary connecting the same 
    endpoints as the original (<xref linkend="Overview - Boundary Refinement Illustration"/>).
  </para>
  <figure id="Overview - Boundary Refinement Illustration" float="0">
    <title>Boundary Refinement in the User's Map</title>
    <mediaobject>
      <caption>
        In order to prevent artificial-looking linear boundaries from being 
        apparent in the generated height field, 
        <citetitle>Terrainosaurus</citetitle> provides a <firstterm>boundary 
        refinement</firstterm> operation to subdivide the linear boundaries of 
        the polygonal regions in the map into irregular boundaries.
      </caption>
      <imageobject>
        <imagedata fileref="Overview - Boundary Refinement.svg"/>
      </imageobject>
    </mediaobject>
  </figure>
  <para>
    The third phase, generation of the height field, is almost totally 
    automated. The user selects a rectangular region of his map, and a target 
    spatial resolution, and then launches the generation process. A genetic 
    algorithm is applied repeatedly to generate successively higher resolution 
    height fields (i.e., successively finer levels of detail). At each LOD, the 
    task of the genetic algorithm is to find a plausible way of arranging small 
    patches of height field data taken from the respective terrain types created 
    by the user. The generated height field is deemed "good" insofar as each 
    region is similar to the user-provided examples for the terrain type it is 
    supposed to represent (<xref linkend="Generated Height Field"/>).
  </para>
  <para>
    The details of the <citetitle>Terrainosaurus</citetitle> algorithm are 
    discussed in much greater depth in <xref linkend="Methods"/>.
  </para>
  <para>
    In contrast to many of the "quick and dirty" algorithms in common practice 
    today, <citetitle>Terrainosaurus</citetitle> is somewhat more complex, and 
    is correspondingly more difficult to implement. In the interest of 
    illuminating the task of implementation somewhat, I discuss some of the 
    design considerations, hurdles, and lessons learned from the prototype 
    implementation in <xref linkend="Implementation"/>. An individual interested 
    in implementing <citetitle>Terrainosaurus</citetitle> may find this 
    discussion useful, to avoid the problems we encountered during our research.
  </para>
  <para>
    Conceptually, the main results of this work include:
    <itemizedlist spacing="compact">
      <listitem>
        a new, genetic-algorithm-based method for generating terrain at multiple 
        LODs without the use of fractals
      </listitem>
      <listitem>
        a terrain authoring paradigm for visually designing large-scale height 
        fields that places a minimal burden on the user in terms of effort and 
        domain knowledge
      </listitem>
      <listitem>
        a means of comparing terrain height fields for similarity, based on their 
        features and statistical characteristics
      </listitem>
    </itemizedlist>
  </para>
  <para>
    In <xref linkend="Discussion"/>, I discuss the results produced by this 
    work, as well as some of the significant problems and "wrong turns" 
    encountered during the research. In the process of this research, we 
    identified a number of promising avenues for further research, possibly 
    leading to improvements in the quality of the generated height fields and 
    streamlining of the user experience. These are discussed in <xref linkend="Future Work"/>.
  </para>
  <figure id="Generated Height Field" float="0">
    <title>A Height Field Generated by <citetitle>Terrainosaurus</citetitle>
</title>
    <mediaobject>
      <caption>
	The generated terrain may be composed of heterogeneous terrain types 
	arranged into arbitrary regions.
      </caption>
      <imageobject>
        <imagedata scalefit="1" width="5in" fileref="Generated Height Field.jpeg"/>
      </imageobject>
    </mediaobject>
  </figure>
</chapter>
  <chapter id="Motivation" xml:base="motivation.xml">
  <title>Motivation</title>
  <para>
    The goal of <citetitle>Terrainosaurus</citetitle> is to "build a better 
    mousetrap", so to speak.  Established terrain generation methodologies have 
    their own respective strengths and weaknesses, which will be discussed in 
    <xref linkend="Taxonomy of Methods"/>.  
    <citetitle>Terrainosaurus</citetitle> is an attempt to address the 
    shortcomings of these existing methods, yielding a better way of generating 
    artificial terrain for many applications.
  </para>
  <para>
    In order to elucidate the motivation for something like 
    <citetitle>Terrainosaurus</citetitle>,  and to establish the context for the 
    discussion that follows, it is worth spending time addressing some 
    preliminary questions:
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      Why generate terrain?
    </listitem>
    <listitem>
      What characteristics would an <emphasis>ideal</emphasis> terrain 
      generation algorithm have?
    </listitem>
    <listitem>
      What should be the primary objectives for 
      <citetitle>Terrainosaurus</citetitle>?
    </listitem>
  </itemizedlist>


  <section>
    <title>Applications of Terrain Generation</title>
    <para>
      Before bothering any further with <emphasis>how</emphasis> to generate 
      terrain, it is first helpful to establish <emphasis>why</emphasis> it is 
      worth doing, and who the primary users of terrain generation algorithms 
      are.
    </para>
    <para>
      Terrain generation has applications in a number of fields, many of which 
      are entertainment-related, though certainly not all are. Examples include:
      <itemizedlist spacing="compact">
        <listitem>
          Computer-generated art &amp; animation—both the commercial variety 
          and "art for art's sake" often depict the natural world
        </listitem>
        <listitem>
          Video games &amp; virtual reality (VR)—many virtual worlds involve 
          at least some natural terrain. In addition to the entertainment uses 
          of virtual worlds, they also have applications in military &amp; 
          non-military simulation
        </listitem>
        <listitem>
          Architectural rendering—while the focus of an architectural 
          rendering is generally the buildings themselves, realistic terrain 
          can help to provide the larger context for the buildings, contributing 
          to the overall visual effect
        </listitem>
      </itemizedlist>
    </para>
  </section>

  <section>
    <title>Idealized Terrain Generation</title>
    <para>
      As is the case in many problem domains, there are a number of traits that 
      an ideal terrain generation algorithm would have, some of which are in 
      tension with one another. Such an ideal algorithm is probably a figment of 
      our collective imagination; nonetheless, having such an ideal in view 
      provides a yardstick with which to evaluate the strengths and weaknesses 
      of real algorithms.
    </para>
    <para>
      While this is not an exhaustive list, such an imaginary, ideal algorithm 
      would:
      <itemizedlist spacing="compact">
        <listitem>
          require a low degree of human input
        </listitem>
        <listitem>
          permit a high degree of human control
        </listitem>
        <listitem>
          be completely intuitive to control
        </listitem>
        <listitem>
          be able to reproduce a wide variety of recognizable terrain types and 
          features realistically, in believable relationship to one another
        </listitem>
        <listitem>
          produce models at arbitrary levels of detail
        </listitem>
        <listitem>
          run quickly enough to be used in real-time, dynamic applications
        </listitem>
        <listitem>
          be extensible to support new types of terrain
        </listitem>
      </itemizedlist>
    </para>

    <section>
      <title>Requiring a Low Degree of Human Input</title>
      <para>
        Digital terrain models typically involve large amounts of data. For 
        example, a standard 10-meter USGS DEM (digital elevation model) 
        <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="DEM Specification"/> contains more than 10,000 data 
        points per square kilometer. If an artist has to place each point 
        manually, this adds up to an enormous amount of painstaking work for 
        the artist. Therefore, any terrain construction detail that can be 
        automated without significantly limiting the artist's control over the 
        result should yield an increase in productivity. An ideal terrain 
        generation methodology would accept a command as simple as "give me a 10 
        km by 5 km area of desert-like terrain with a resolution of 10m per 
        sample" and produce a believable result.
      </para>
      <para>
        If the inputs required by an algorithm are sufficiently minimal, there 
        may be a second benefit, in addition to the increase in artist 
        productivity: the algorithm may be useful for generating unique 
        terrains automatically (e.g., as a random world generator for a game).
      </para>
    </section>

    <section>
      <title>Permitting a High Degree of Human Control</title>
      <para>
        In obvious tension with the previous ideal is the goal of permitting 
        the artist to exert an arbitrarily fine degree of control over the 
        features and characteristics of the generated terrain. To give an 
        artist full creative freedom requires that he be able to control the 
        behavior of the terrain across all scales, from the macro-scale 
        features (hills, valleys, mountains, etc.) to the micro-scale details 
        (cracks, crevices, etc.), with any degree of localization, creating 
        both global and local effects. An ideal algorithm would permit the 
        artist to exert whatever amount of control he wishes, where he wishes, 
        while intelligently filling in the details he doesn't care to specify 
        directly.
      </para>
    </section>

    <section>
      <title>Intuitively Controllable</title>
      <para>
        If a user is required to gain arcane knowledge or specialized skills to 
        use a tool effectively, that tool will have a correspondingly steep 
        learning curve. An ideal terrain generation algorithm would be perfectly 
        intuitive to use—a complete "black box" from the user's perspective, 
        requiring no understanding whatsoever of the algorithm's innards. All of 
        the inputs available to the user would be easily understood: even an 
        inexperienced user would have a reasonable idea of how tweaking an input 
        would affect the generated terrain.
      </para>
    </section>

    <section>
      <title>Capable of Diverse, Believable Features &amp; Terrain Types</title>
      <para>
        A terrain generation algorithm that can reproduce only a narrow range 
        of terrain types and features is inherently limited in its usefulness. 
        An ideal algorithm would be able to create a wide diversity of terrain 
        types (e.g., desert, mountains, plains) and features (e.g. ravines, 
        riverbeds, volcanoes), both from the real world and from the imagination 
        of the artist.  Additionally, the transitions between different types of 
        terrain (e.g., from mountains to foothills) would be believable, and the 
        placement of semantic features would make sense (waterfalls would pour 
        into pools, rivers would always flow downhill).
      </para>
    </section>
    <section>
      <title>Arbitrary Level of Detail</title>
      <para>
        It is precisely because detailed terrain models involve such large 
        quantities of data that continuous level of detail (CLOD) algorithms are 
        necessary for their visualization, at least in the general case where 
        the viewer is permitted to move about the terrain freely.  However, 
        full-detail terrain models are not always needed, the requisite level of 
        detail being determined by their intended use.  For example, a model 
        meant to act as the setting for a computer-animated film needs highly 
        realistic detail only in the areas near to which the action is to take 
        place, and can use relatively simple geometry for distant terrain.  
        Similarly, the level of detail required of the terrain in a flight 
        simulation is significantly less than what is needed for ground-level 
        action. An ideal terrain generation algorithm would permit the creation 
        of terrain at multiple levels of detail, and the segmentation of large 
        terrains into regions of differing levels of detail.
      </para>
    </section>

    <section>
      <title>Fast Enough for Real-Time Applications</title>
      <para>
        Many terrain-related algorithms are very slow, or else require a 
        lengthy preprocessing phase <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Chunked LOD"/> 
        <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="L3DT"/> before the terrain can be used in a 
        real-time application.  Intuitively, we would expect all but the most 
        simplistic terrain generation algorithms to fall into this category.  
        Nonetheless, an algorithm that could do most or all of its processing 
        on-the-fly would provide several important advantages, including:
        <itemizedlist spacing="compact">
          <listitem>
            instantaneous feedback to the artist of the effects of a particular 
            modification
          </listitem>
          <listitem>
            the ability to modify dynamically the terrain in fundamental and 
            interesting ways (such as transforming a mountain into a crater, or 
            rapidly eroding a riverbed into a deep gorge)
          </listitem>
          <listitem>
            savings in the amount of memory and disk storage required (if the 
            full terrain can be (re)generated from a more compact set of 
            parameters)
          </listitem>
          <listitem>
            the ability to create seamless, infinite worlds, with arbitrarily 
            fine, dynamic level of detail
          </listitem>
        </itemizedlist>
      </para>
    </section>

    <section>
      <title>Extensible</title>
      <para>
        Regardless of how many types of terrain a terrain generation tool can 
        create, there will always be a user wanting something "just a little 
        bit different"—the set of terrain types is ultimately as limitless 
        as the human imagination. Thus, an ideal terrain generation algorithm 
        would be extensible in some way, allowing new types of terrain to be 
        introduced easily.
      </para>
    </section>
  </section>

  <section>
    <title>Goals</title>
    <para>
      This idealized algorithm has set the standard of perfection fairly high, 
      and <citetitle>Terrainosaurus</citetitle> most certainly will not possess 
      all of the traits of our imaginary ideal. So when it becomes necessary to 
      compromise on one trait in order to improve another, which traits should 
      be preferred?
    </para>
    <para>
      Different applications have different requirements, and the needs of the 
      primary user community of terrain generation tools should be used to 
      answer this question—if users demand realism and 
      <citetitle>Terrainosaurus</citetitle> gives them speedy generation but 
      mediocre results...it will not be very popular.  Looking back at the above 
      list of terrain generation applications, one thing that most of them have 
      in common is that they have time to spare: with the possible exception of 
      some games &amp; VR applications, none of them need to generate terrain at 
      interactive speeds. Even in this last case, the terrain is normally 
      generated once (either by the game designer, or when the program starts) 
      and never modified afterward. In fact, most CLOD algorithms 
      <emphasis>depend</emphasis> on the terrain being static).  Thus, real-time 
      performance, while nice, is not essential.
    </para>
    <para>
      A second, significant observation is that terrain is, by its very nature, 
      somewhat "sloppy": two mountains might have innumerable, minute 
      differences between  them, but if some fundamental relationships are 
      intact, a human will perceive them as similar—the differences are 
      inconsequential. The success of randomized algorithms in imitating 
      natural phenomena can be largely attributed to this fact.  Because of 
      this, and because the terrain model being created is often quite large, a 
      user of a terrain generation tool typically does not care to exercise a 
      great deal of fine-scale control over the terrain.  Therefore, when 
      forced to choose between the competing goals of high controllability and 
      ease of use, we should favor the latter.
    </para>
    <para>
      In the design of <citetitle>Terrainosaurus</citetitle>, the goals 
      considered to be most important are (in order of decreasing importance):
      <orderedlist spacing="compact" inheritnum="ignore" continuation="restarts">
        <listitem>
          realism
        </listitem>
        <listitem>
          extensibility
        </listitem>
        <listitem>
          ease of use (intuitive control, with low input requirements)
        </listitem>
      </orderedlist>
      By pursuing these as guiding objectives, we can expect that the resulting 
      algorithm will be of maximal utility to the terrain generation community, 
      particularly for non-real-time authoring of large-scale virtual 
      environments.
    </para>
  </section>
</chapter>
  <chapter id="Background" xml:base="background.xml">
  <title>Background</title>
  <para>
    In this chapter, I cover a number of topics that serve as necessary 
    background material for understanding the 
    <citetitle>Terrainosaurus</citetitle> algorithm. First, I survey the history 
    and state-of-the-art in virtual terrain, and then highlight several previous 
    works that are especially similar to <citetitle>Terrainosaurus</citetitle>.  
    Finally, I touch upon several auxiliary topics that are directly relevant to 
    <citetitle>Terrainosaurus</citetitle>.
  </para>

  <section id="Previous Work">
    <title>Previous Work in Virtual Terrain</title>
    <para>
      In order to understand the relationship of 
      <citetitle>Terrainosaurus</citetitle> to the field of terrain generation, 
      it is helpful to have a grasp of the scope of current terrain generation 
      literature and praxis. To this end, in this section, I review the 
      following topics:
      <itemizedlist spacing="compact">
        <listitem>
          a brief discussion of the issues involved in mapping ellipsoid 
          objects (e.g., the Earth)
        </listitem>
        <listitem>
          a survey of different structures for representing terrain, with their 
          benefits and drawbacks
        </listitem>
        <listitem>
          a taxonomy of existing methods of generating terrain
        </listitem>
        <listitem>
          a discussion of level of detail issues in terrain generation
        </listitem>
        <listitem>
          a survey of existing terrain generation software
        </listitem>
        <listitem>
          pointers to terrain-related sites on the Internet
        </listitem>
      </itemizedlist>
    </para>

    <section id="Geodetic Mapping">
      <title>Geodetic Mapping</title>
      <para>
        The Earth (and the other planets) are (roughly) ellipsoidal objects of 
        enormous size. In most aspects of our everyday life, it suffices to 
        think of the Earth simply as an infinite plane, completely flat. Only 
        when we deal with a planet at larger scales (e.g., for global 
        positioning and navigation) does it become necessary to account for the 
        effects of planetary curvature.
      </para>
      <para>
        Researchers in the cartographic and astronomic sciences have been 
        devising schemes for dealing with these effects for a long time. With 
        the rise of computing technology, the field of <firstterm>Geographic 
          Information Systems (GIS)</firstterm>, the application of computers 
        to mapping and understanding the Earth, has made great use of these 
        schemes to produce digital maps of most of the Earth's surface. Still, 
        GIS mapping is not without its difficulties, many of them due to 
        attempting to "unwrap" the ellipsoidal planet surface to produce a 
        planar representation of the geography; there appears to be no natural 
        way of doing this. A full discussion of the difficulties of planetary 
        mapping, and their work-arounds, is outside of the scope of this 
        thesis, but to name a few:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          One way of producing a planar surface from an ellipsoidal surface is 
          to map the ellipsoid using a spherical coordinate system, and then to 
          create a rectangular map with the latitude and longitude as the two 
          axes. The major problem with this approach is that distances become 
          more and more distorted towards the poles. For a digital terrain 
          model, this means that if the surface is sampled uniformly in the 
          latitude/longitude coordinate system, the sample points will not be 
          uniformly distributed across the surface of the sphere, but will be 
          denser around the poles.
        </listitem>
        <listitem>
          Another way of producing a planar surface is to "slice" the ellipsoid 
          like an orange and to flatten each slice of the map with a local 
          planar projection. This results in less distortion, but causes 
          discontinuities in the planar map and creates large areas in the map 
          that do not correspond to any point on the ellipsoid.
        </listitem>
      </itemizedlist>
      For more information on geodetic mapping, projection &amp; coordinate 
      systems, and GIS in general, the USGS's website is a good place to start 
      <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="USGS"/>.
    </section>

    <section id="Terrain Representations">
      <title>Methods of Representing Terrain</title>
      <para>
        One of the most fundamental decisions to be made when working with 
        virtual terrain is that of how to <emphasis>represent</emphasis> the 
        terrain. The choice of data structure will affect the set of available 
        tools in our terrain generation "toolbox", and may also limit the kinds 
        of terrain features that can be represented or the ways in which the 
        terrain can be edited and used. Some questions that must be answered 
        based on the needs of the application include:
        <itemizedlist spacing="compact">
          <listitem>
            Does the terrain need to have infinite precision, such that it can 
            be viewed at any arbitrary scale, or is it acceptable to have a 
            finite, maximal resolution?
          </listitem>
          <listitem>
            Is it important to be able to represent terrain structures like 
            caves and overhangs, in which multiple surfaces have the same 
            horizontal coordinates, or will the terrain surface obey the 
            vertical line test at every point?
          </listitem>
          <listitem>
            Are the effects of planetary curvature important, or is a "flat 
            Earth" approximation good enough?
          </listitem>
          <listitem>
            Will the terrain surface need to be rendered and/or tested for 
            object collisions in an efficient manner?
          </listitem>
        </itemizedlist>
        In light of these considerations, we can compare the merits and 
        limitations of several alternative representations for terrain:
        <itemizedlist spacing="compact">
          <listitem>
            height fields
          </listitem>
          <listitem>
            voxel grids
          </listitem>
          <listitem>
            non-uniform meshes
          </listitem>
          <listitem>
            analytic and fractal functions
          </listitem>
        </itemizedlist>
      </para>

      <section id="Height Fields">
        <title>Height Fields</title>
        <para>
          The terrain representation most widely used at the present time is 
          probably the <firstterm>height field</firstterm>. A height field 
          represents a surface as a scalar function of two discrete variables, 
          such that the horizontal coordinate pair
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>

                        </inlineequation> 
          determines the elevation at that point. While there is nothing 
          precluding the use of an infinite, continuous function or a 
          non-rectangular domain, in usual practice, this function is 
          discretized at regular intervals in <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>
                        </inlineequation> and 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/y.mml">
  <mi>y</mi>
</math>

                        </inlineequation>, 
          with <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>
                        </inlineequation> and 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/y.mml">
  <mi>y</mi>
</math>

                        </inlineequation> 
          valid over a finite, rectangular domain, the width and height of the 
          height field (<xref linkend="Height Field Equation"/>).
        </para>
        <equation id="Height Field Equation">
          <title>Height Field Equation</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Height%20Field%20Equation.mml">
  <mi>z</mi>
  <mo>=</mo>
  <mi>f</mi>
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
  <mfenced open="{" close="">
    <mfrac linethickness="0">
      <mrow>
        <mi>x</mi>
        <mo>∈</mo>
        <mfenced open="[" close=")">
          <mn>0</mn>
          <mi>w</mi>
        </mfenced>
      </mrow>
      <mrow>
        <mi>y</mi>
        <mo>∈</mo>
        <mfenced open="[" close=")">
          <mn>0</mn>
          <mi>h</mi>
        </mfenced>
      </mrow>
    </mfrac>
  </mfenced>
</math>
        </equation>
        <para>
          This formulation leads to the familiar implementation of the height 
          field as a 2D array of scalar elevation values (<xref linkend="Height Field Image"/>).
        </para>
        <figure id="Height Field Image" float="0">
          <title>A Discrete Height Field</title>
          <mediaobject>
            <imageobject>
              <imagedata scalefit="1" width="5in" fileref="Height Field Wireframe.jpeg"/>
            </imageobject>
          </mediaobject>
        </figure>

        <section>
          <title>Advantages of Height Fields</title>
          <para>
            Once we observe that the discrete form of the height field is 
            essentially the same thing as a greyscale image, this quickly leads 
            us to the insight that computer vision and image processing 
            techniques may be used to construct, modify, analyze, and compress 
            terrain models represented as height fields (for example, a rough 
            terrain could be made smoother by applying a standard Gaussian blur 
            filter to it, and a height field can be stored using an image file 
            format).
          </para>
          <para>
            A second advantage of the height field is that its regular 
            structure makes it possible to optimize operations like rendering, 
            collision-detection and path-finding. The rendering of even very 
            large height fields in real-time has been made feasible by the 
            invention of a number of <firstterm>continuous level of detail 
              (CLOD) algorithms</firstterm>, which render highly visible areas 
            of the terrain with detailed geometry, using progressively simpler 
            geometry for obscured or more distant parts of the terrain 
            <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="ROAM"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Chunked LOD"/> 
            <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Feature-based CLOD"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Geometry Clipmaps"/>. Collision detection, an expensive 
            operation in the general case, can be done cheaply when one of the 
            objects is a height field since, given an
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>

</inlineequation>
            location in the height field, only a few surrounding triangles need 
            to be checked for collision.
          </para>
          <para>
            A third advantage is that significant quantities of real-world 
            terrain data are available in height field form, making it the 
            representation of choice for working with GIS data.
          </para>
        </section>

        <section>
          <title>Disadvantages of Height Fields</title>
          <para>
            The most fundamental disadvantage of the height field is that, 
            since surface elevation is a function of an
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>

                            </inlineequation>
            coordinate pair, there must be exactly one elevation for every pair 
            of coordinates. Because of this, a height field is inherently unable 
            to represent caves, overhangs, vertical surfaces, and other terrain 
            structures in which multiple surfaces have the same horizontal 
            coordinates (<xref linkend="Height Field Cartoon"/>). In practice, 
            this limitation is often inconsequential, since most natural terrain 
            is fairly "well behaved" in this respect, and the exceptional cases 
            can be handled by modeling overlapping structures as separate 
            objects placed atop the terrain (though this solution does have an 
            undesirable <foreignphrase>ad hoc</foreignphrase> quality to it).
          </para>
          <figure id="Height Field Cartoon" float="0">
            <title>The Problem With Height Fields</title>
            <mediaobject>
              <caption>
                One of the main disadvantages of height fields is that they are 
                inherently limited in the kinds of features that they can 
                capture; features such as overhangs and caves cannot be 
                represented in a standard height field.
              </caption>
              <imageobject>
                <imagedata scalefit="1" width="80%" fileref="Height Field Cartoon.svg"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            A second disadvantage of the height field, when used in its usual, 
            discrete form, is that it has a finite, uniform resolution.  This 
            has two negative implications. First, because the resolution is 
            <emphasis>finite</emphasis>, this places a firm upper bound on the 
            degree of fine-scale detail that the height field can represent.  As 
            a result, when viewed from a too-close viewpoint, the terrain may 
            appear blocky, featureless and unnatural. Second, because the 
            resolution is <emphasis>uniform</emphasis> throughout the domain, a 
            a height field cannot gracefully handle terrains having a highly 
            variable local level of detail. If the resolution is chosen to match 
            the average scale of the features in the terrain, then any 
            finer-scale features will be simplified or eliminated; conversely, 
            if the resolution is chosen to be high enough to capture the 
            fine-scale features, areas containing only coarse features will also 
            be captured at this same high resolution, an undesirable waste of 
            space and processing time. Ideally, a terrain representation for 
            terrain generation would either be infinite in resolution, or else 
            would adaptively increase its resolution to accommodate the addition 
            of fine scale details, rather than requiring an <foreignphrase>a 
              priori</foreignphrase> decision about resolution.
          </para>
          <para>
            A third disadvantage of the height field, if used to represent 
            terrain on a planetary scale, is that rectangular height field 
            patches do not map onto spheroid objects any better than rectangular 
            image textures do.  If the standard, two-pole spherical projection 
            is used to map a height field onto a spherical planet, the density 
            of height field points will be substantially greater in areas near 
            the poles than at those near the equator.
          </para>
        </section>
      </section>

      <section>
        <title>Voxel Grids</title>
        <para>
          Another possibility for representing terrain is the height field's 3D 
          cousin, the <firstterm>voxel grid</firstterm>. A voxel grid is a 
          discrete, three-dimensional grid of <firstterm>voxels</firstterm> 
          (the volumetric equivalent of pixels), in which (in the simplest 
          case) each voxel is either filled or not. By selectively filling 
          voxels, one can create arbitrary 3D shapes.
        </para>

        <section>
          <title>Advantages of Voxel Grids</title>
          <para>
            The main advantage that voxel grids have over height fields is that 
            they are not constrained by the vertical line test, and can 
            represent vertical surfaces, overhangs, etc.
          </para>
        </section>

        <section>
          <title>Disadvantages of Voxel Grids</title>
          <para>
            Voxel grids inherit most of the problems of height fields, and add 
            several of their own. They share the height field's disadvantages 
            of having a finite resolution, and of not handling planetary 
            curvature gracefully. Rendering and collision detection are more 
            expensive than with height fields, and more data must be pushed to 
            the graphics card for the same amount of rendered horizontal area.  
            Additionally, without the use of spatial subdivision techniques 
            (such as octrees), voxel grids are typically very wasteful of 
            memory (as large chunks of the grid are either completely empty or 
            are buried deep underground).
          </para>
        </section>
      </section>

      <section>
        <title>Non-uniform Meshes</title>
        <para>
          A more general way of handling terrain is to represent the surface of  
          the terrain as an arbitrary mesh of 2D primitives (usually polygons, 
          but sometimes quadric or cubic Bezier or NURBS patches) embedded in 
          the 3D space. Such mesh surfaces are popular ways of modeling and 
          animating characters and other objects, and there are numerous tools 
          available for working with objects in this form.
        </para>
        <para>
          A <firstterm>triangular irregular network (TIN)</firstterm> 
          <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="TIN"/> is a special case of a non-uniform mesh.  
          In a TIN, the surface is represented as a mesh of triangles derived 
          from a set of 3D points (using, for example, the Delunay 
          triangulation). TINs are useful ways of creating a mesh 
          representation from real-world data—the points, called 
          <firstterm>mass points</firstterm>, could be sampled directly from 
          the terrain surface, or could be derived from the contours of a 
          topographic map.
        </para>

        <section>
          <title>Advantages of Meshes</title>
          <para>
            The main benefit of using meshes to model the terrain surface is 
            that they are extremely general. The surface may have arbitrary 
            geometry and topology (overhangs, caves, rock arches, etc.), and an 
            artist working with meshes is free to model even the most bizarre 
            and heterogeneous terrain structures using a single modeling 
            paradigm.
          </para>
          <para>
            A second advantage of meshes is that they naturally support variable 
            level of detail, allowing more vertices in areas of sharp change and 
            relatively few vertices in flat areas. As a result, a mesh structure 
            can store some terrain models much more efficiently than regular 
            grid methods, since it does not require a globally high resolution 
            in order to achieve fine-scale features in a few places.
          </para>
          <para>
            Furthermore, as most of the tools for computer modeling and 
            animation support this paradigm, there is a significant user base 
            that is already comfortable with manipulating objects represented 
            in this way.
          </para>
        </section>

        <section>
          <title>Disadvantages of Meshes</title>
          <para>
            The main difficulty with using meshes for terrain generation is that 
            it is not clear how to generate them automatically; even though 
            terrain is almost always tessellated into some sort of polygonal 
            representation before rendering, I am unaware of any terrain 
            generation methods (other than manual sculpting) that work directly 
            on a mesh representation (i.e., without the use of a more 
            constrained, terrain-specific data structure).
          </para>
        </section>
      </section>

      <section>
        <title>Continuous Functions</title>
        <para>
          A final possibility is to represent the terrain with some sort of 
          analytic or fractal function. This approach is seldom used in 
          practice, with the <citetitle>MojoWorld</citetitle> world generator 
          being a rare, but impressive example <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="MojoWorld"/>.
        </para>

        <section>
          <title>Advantages of Continuous Functions</title>
          <para>
            Continuous functions (both analytic and fractal) have the advantage 
            of being viewable at any scale without losing resolution; viewed 
            close-up, they do not look "faceted" as height fields tend to do.  
            Beyond this, both analytic and fractal functions have their own 
            advantages.
          </para>
          <para>
            Certain classes of analytic functions offer mathematical advantages 
            that make them friendly for rendering and/or collision 
            detection/response. Many types of analytic functions are 
            differentiable at most or all points, allowing precise derivatives 
            to be calculated. Polynomial surfaces of low degree (quartic and 
            below) have closed-form solutions, allowing ray/surface 
            intersections to be calculated in a straightforward way.
          </para>
          <para>
            Fractals offer a different advantage: unlike analytic functions, 
            which typically become more and more linear when viewed at finer and  
            finer scales, fractal functions continue to produce new details as 
            they are evaluated at progressively finer scales, meaning that a 
            fractal terrain can have as much fine-scale detail as the display 
            system can render.
          </para>
        </section>

        <section>
          <title>Disadvantages of Continuous Functions</title>
          <para>
            The main problem of using continuous functions is the difficulty of 
            modeling with them. If a single, global function is used, it is 
            difficult to know how to modify the function to achieve a certain 
            local effect. A more usable approach is to compose a number of 
            functions, each having a local area of effect (B-spline patches are 
            example of this), though this has yet to replace polygon-based 
            techniques as the dominant modeling paradigm.
          </para>
          <para>
            The other drawback of continuous functions is the difficulty of 
            rendering them. For a polygon-based rendering system, the function 
            must be transformed into a form that the graphics hardware can 
            process (e.g., triangles). For a ray tracing system, the first 
            intersection of a ray with the surface must be evaluated.  In 
            either case, depending on the complexity and topology of the 
            function, this process may be quite expensive.
          </para>
        </section>
      </section>

    </section>

    <section id="Taxonomy of Methods">
      <title>A Taxonomy of Terrain Generation Methods</title>
      <para>
        Terrain generation has not received nearly as much attention in the 
        literature as terrain LOD rendering has, with relatively few 
        innovations to date. The discussion of terrain generation in the 
        computer science literature dates back at least as far as 1977, to a 
        paper in which terrain created from simple mathematical functions is 
        used to stage simulated military combat scenarios <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Combat Simulation"/>. Since that time, a variety of methods  
        for producing terrain have been proposed, generally falling into four 
        broad categories:
        <itemizedlist spacing="compact">
          <listitem>
            GIS-based methods
          </listitem>
          <listitem>
            Sculpting methods
          </listitem>
          <listitem>
            Simulation methods
          </listitem>
          <listitem>
            Procedural methods
          </listitem>
        </itemizedlist>
      </para>

      <section id="GIS-based Methods">
        <title>GIS-based Methods</title>
        <figure id="GIS-based Methods Skill Chart" float="0">
          <title>Typical Characteristics of GIS-based Methods</title>
          <mediaobject>
            <caption>
              GIS-based methods are simple to implement, and borrow their 
              realism directly from the real world, but are limited to the 
              locations and resolutions for which real-world data is available.
            </caption>
            <imageobject>
              <imagedata fileref="Skill Chart - GIS.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          The most obvious place to find natural-looking terrain is in nature 
          itself. While not strictly a method of 
          <emphasis>generating</emphasis> terrain, the use of GIS data is a 
          simple and effective way of getting very realistic terrain models 
          (<xref linkend="GIS-based Methods Skill Chart"/>).  High-quality 
          elevation maps (height fields) of the entire United States (and some 
          other parts of the world) can be downloaded or ordered from a variety 
          of GIS data providers (such as <citetitle>Geo Community</citetitle> 
          <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="GeoCommunity"/> and the <citetitle>U.S.  
            Geological Survey (USGS)</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="USGS Maps"/>).  These data are available in several formats (with older 
          elevation maps available in the DEM format <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="DEM Specification"/> and more recent data available only in the more 
          complex SDTS format <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="SDTS Specification"/>) and at 
          resolutions as high as 3 meters per sample in some cases (though 
          resolutions of 10 and 30 meters per sample are much more 
          commonplace).
        </para>
        <para>
          GIS data is ideal when the overriding concern is realism, and is 
          often the best or only option when an application needs to represent 
          actual, real-world locations faithfully. Applications of this sort 
          include mapping software <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="ArcGIS"/> and 
          simulations set in real-world locations <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="SimCity 4"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="FS 2004"/>. Using GIS data, a high degree 
          of realism can be achieved for relatively little human effort.
        </para>
        <para>
          The major drawback to the use of GIS data is the constraint that it 
          imposes: only real-world locations that are present in a mapping 
          agency's database can be used. Thus, while little or no effort is 
          required to <emphasis>use</emphasis> GIS data in an application, 
          <emphasis>finding</emphasis> suitable data may be time-consuming or 
          simply impossible. For many applications, this may unacceptably 
          compromise artistic objectives (e.g., a movie director may want a 
          particular arrangement of mountains and rivers) or other, more 
          utilitarian goals (e.g., a particular military combat scenario might 
          require a particular set of terrain features). A secondary 
          disadvantage of GIS-based methods is the significant amount of space 
          required to store large datasets.  Finally, the level of detail 
          available through GIS sources is limited—if a particular 
          application requires finer-scale detail than that offered by the 
          mapping agency, one will have to resort to other means for achieving 
          it.
        </para>
      </section>

      <section id="Sculpting Methods">
        <title>Sculpting Methods</title>
        <figure id="Sculpting Methods Skill Chart" float="0">
          <title>Typical Characteristics of Sculpting Methods</title>
          <mediaobject>
            <caption>
              Sculpting methods allow the terrain author to construct virtually 
              anything imaginable, but require significant effort and skill.
            </caption>
            <imageobject>
              <imagedata fileref="Skill Chart - Sculpting.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          At the opposite end of the spectrum, in terms of human effort, is the 
          use of artistic tools to "paint" or "sculpt" the features of the 
          terrain (<xref linkend="Sculpting Methods Skill Chart"/>).  In most 
          cases, this means using computer-based modeling and painting tools 
          (such as <citetitle>Adobe Photoshop</citetitle>, <citetitle>Bryce 
            3D</citetitle>, or <citetitle>Maya</citetitle>) or specialized 
          "level editors" (such as those shipped with the recent game titles 
          <citetitle>SimCity 4</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="SimCity 4"/> and 
          <citetitle>Unreal Tournament 2004</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="UT 2004"/>). Less commonly, an artist might create a model using 
          traditional, physical media and then digitize it using laser scanning 
          techniques, as was done to create the terrain for the video game 
          title <citetitle>Trespasser</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Trespasser Postmortem"/>.
        </para>
        <para>
          The primary advantage of sculpting methods is the enormous freedom 
          given to the artist. Anything the artist can conceive, he can 
          achieve, given sufficient skill and effort.
        </para>
        <para>
          This strength is also its main drawback—achieving a desired result 
          with this method typically requires a large investment of human time 
          and effort, and the quality of the results is heavily dependent on 
          the skill of the artist. As the size of the virtual environment 
          increases, so does the cost of sculpting it, making this method of 
          terrain generation less and less feasible as projects increase in 
          scope.
        </para>
      </section>

      <section id="Simulation Methods">
        <title>Simulation Methods</title>
        <figure id="Simulation Methods Skill Chart" float="0">
          <title>Typical Characteristics of Simulation Methods</title>
          <mediaobject>
            <caption>
              Simulation methods have high potential for realism, but are 
              computationally expensive and difficult to control.
            </caption>
            <imageobject>
              <imagedata fileref="Skill Chart - Simulation.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          Another family of terrain generation methods involves the evolution 
          of terrain by simulating the effects of physical processes such as 
          plate tectonics or erosion by wind or water <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Stream Erosion"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Eroded Fractal Terrains"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Area51"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Erosion 3D"/> (<xref linkend="Simulation Methods Skill Chart"/>).  Simulation techniques for terrain generation have been 
          explored to a much smaller extent than other methods.
        </para>
        <para>
          These methods have the potential to produce highly realistic results,  
          to the extent that they accurately model the physical processes they 
          are intended to simulate. They can also be very hands-off, requiring 
          little input from the user.
        </para>
        <para>
          One drawback of simulation methods is the amount of processing time 
          required. In order for the simulation to produce realistic results, it 
          must run at sufficiently fine resolutions in both space and time to 
          adequately capture the effects of these processes; as the resolution 
          of the simulation increases, so does the time required to run it. A 
          second drawback of such methods is the relative lack of user control: 
          since a simulation is intended to capture the effects of natural 
          processes, the role of the human user is limited to setting up the 
          initial conditions for the simulation and kicking it off—achieving 
          specific, user-specified effects may be difficult.
        </para>
      </section>

      <section id="Procedural Methods">
        <title>Procedural Methods</title>
        <figure id="Procedural Methods Skill Chart" float="0">
          <title>Typical Characteristics of Procedural Methods</title>
          <mediaobject>
            <caption>
              Procedural methods are often simple to implement, relatively fast 
              to run, somewhat difficult to control, and limited in realism.
            </caption>
            <imageobject>
              <imagedata fileref="Skill Chart - Procedural.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          The term "procedural methods" describes a broad family of terrain 
          generation techniques whose unifying factor is that they produce a 
          terrain model through the application of some sort of automatic 
          "procedure" (<xref linkend="Procedural Methods Skill Chart"/>). While 
          the aforementioned simulation methods (<xref linkend="Simulation Methods"/>) fit this description, I consider them separately 
          because, unlike true simulation methods, most procedural generation 
          methods do not attempt to simulate any physical processes, and use 
          techniques that are quite different from the numeric integration that 
          is typical of simulations.  In most cases, procedural generation 
          methods are simply "hacks" that have been found to work acceptably for 
          generating certain types of terrain and rely heavily on random number 
          generation to produce irregular variations in the terrain surface.  
          Some of the earliest discussions in the literature focus on procedural 
          methods for approximating terrain <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Combat Simulation"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Procedure Models"/>.
        </para>
        <para>
          Some of the most popular procedural techniques are fractal in nature, 
          such as the midpoint displacement method (MPD) <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="MPD Method"/> and Perlin Noise <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Perlin Noise"/>.  These techniques exhibit the fractal property of 
          self-similarity at different scales, and generally involve randomly 
          perturbing the height values of the terrain by increasingly smaller 
          amounts at increasingly finer scales.  Prusinkiewicz &amp; Hammel 
          describe a method for generating mountains with an integrated river 
          network that is entirely fractal in nature <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Mountains and Rivers"/>.
        </para>
        <para>
          A similar class of procedural techniques in current practice is known 
          as <firstterm>collaging</firstterm> or <firstterm>faulting</firstterm> 
          methods <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Area51"/>.  In these techniques, an 
          irregular height field is created through the random superposition of 
          simple shapes, such as spheres, cones, half-planes, or 2D 
          trigonometric functions.  After several hundred to several thousand 
          iterations, the result is a random height field possessing similar 
          curvature and smoothness characteristics to the primitive shape, but 
          without any of the primitive shapes directly apparent in the terrain.
        </para>
        <para>
          Less frequently used are a family of <firstterm>spectral 
            synthesis</firstterm> techniques, which involve randomly or 
          semi-randomly constructing a frequency-spectrum (Fourier- or 
          wavelet-space) representation of a terrain and then performing the 
          inverse transform to produce the spatial representation of the 
          terrain <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Wavelet Synthesis"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Spectral Synthesis"/>.
        </para>
        <para>
          Procedural methods for terrain generation are popular among artists 
          and game designers <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Lighthouse 3D"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Fluid Simulation"/>, largely because they are easy to 
          understand and implement. They also generate unique and (ideally) 
          interesting results each time, and can run with little or no human 
          input in many cases, making them useful for generating random game 
          worlds. If used in this way, the application need not store any 
          height field data on disk, since a new, unique terrain environment 
          can be constructed each time the application runs.
        </para>
        <para>
          The principal drawback of these methods is that they generally have 
          no causal connection to the real-world terrain they try to emulate, 
          instead bearing only an incidental resemblance (in other words, they 
          only happen to <emphasis>look</emphasis> terrain-like rather than 
          being somehow <emphasis>derived from</emphasis> the same principles 
          and processes that cause the formation of real terrain).  Because of 
          this, most procedural methods are only useful for simulating a limited 
          range of terrain types. In addition, since the procedural parameters 
          do not typically correspond to real-world terrain characteristics (and 
          are often rather unintuitive), achieving a desired effect is likely to 
          be an exercise in trial and error.
        </para>
      </section>
    </section>

    <section id="Level of Detail Considerations">
      <title>Level of Detail Considerations</title>
      <para>
        Another way of classifying terrain generation methods, essentially 
        orthogonal to the taxonomy of the previous section (<xref linkend="Taxonomy of Methods"/>), is with respect to how they handle 
        level of detail.  In terrain rendering, LOD considerations are 
        important for handling large terrain models efficiently. In terrain 
        <emphasis>generation</emphasis>, however, LOD acquires a whole new 
        level of importance. In rendering, LOD may be thought of simply as an 
        upper limit on the amount of detail to be shown; in generation, LOD has 
        (or <emphasis>should</emphasis> have) an enormous impact on the shape 
        and features of the generated terrain. Terrain features occur across a 
        variety of scales, ranging from entire mountain ranges down to small 
        cracks in the ground. As the LOD of a terrain is reduced, the finer 
        details are lost, leaving only the larger features; because of this, we 
        may consider those details that disappeared as <emphasis>belonging 
          to</emphasis> the finer LOD, and we may design our algorithms to 
        exploit this. At least three classes of generation methods can be 
        distinguished with respect to LOD:
        <itemizedlist spacing="compact">
          <listitem>
            methods that are LOD-agnostic, and generate the full spectrum of 
            detail in one shot
          </listitem>
          <listitem>
            methods that generate detail at different scales, and combine 
            them via superposition
          </listitem>
          <listitem>
            methods that work from coarse to fine, progressively introducing 
            finer and finer modifications to the terrain
          </listitem>
        </itemizedlist>
        In the following sections, I describe these three classes of methods, 
        concluding with a discussion of the applicability of fractals to terrain 
        generation.
      </para>

      <section id="LOD-agnostic Methods">
        <title>LOD-agnostic Methods</title>
        <para>
          The most simplistic approach to LOD is, of course, to ignore it as 
          much as possible. A number of generation methods follow this course, 
          considering LOD only when initially selecting the resolution of the 
          height field (or other structure).
        </para>
        <para>
          Many of the procedural methods discussed in <xref linkend="Procedural Methods"/> fit this description.  Collaging/faulting methods 
          <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Area51"/> are a good example: the resolution of 
          the height field is fixed at the start of the algorithm, and the 
          collaging process runs to completion without explicit consideration 
          for the LOD of generated features.  The features produced, whether 
          large or small, are simply the consequence of the random overlapping 
          of hundreds or thousands of simple shapes.
        </para>
        <para>
          Another class of methods that is typically LOD-agnostic is the class  
          of simulation methods discussed in <xref linkend="Simulation Methods"/>.  Since simulation is usually done using numerical 
          integration techniques on a regular grid structure, the initial 
          choices of grid resolution and simulation time-step are normally the 
          only points at which LOD considerations are consciously applied.  
          Thereafter, the physical features of the terrain emerge through the 
          approximation of physical processes, without further reference to LOD 
          (though the initial choice of LOD will certainly affect the accuracy 
          of the simulation).
        </para>
        <para>
          These examples are sufficient to illustrate the principal weakness of 
          most LOD-agnostic algorithms: because they do "everything at once", 
          with many overlapping effects, the effects of any individual step in 
          the generation process are difficult or impossible for the human user 
          to distinguish, making the generation process inscrutable, 
          unpredictable…and uncontrollable. As was mentioned in <xref linkend="Simulation Methods"/>, physically-based simulations have the 
          drawback of being difficult for a user to guide towards a desired 
          result. This is partially attributable to the LOD-agnostic nature of 
          the simulation: a tweak to the initial conditions of the simulation 
          may (or may not) produce the desired effect at a certain scale, but 
          may also have undesired side-effects at larger or smaller scales.  
          Non-physically-based methods of the LOD-agnostic sort share this 
          characteristic of being opaque to the human user, and carry the 
          additional liability of tending to generate physically incorrect 
          shapes. It is difficult to see how such methods could ever rise above 
          the level of simple "hacks" to become controllable, realistic terrain 
          generators.
        </para>
      </section>

      <section id="Superposition Methods">
        <title>Superposition Methods</title>
        <para>
          A second approach to LOD is to construct detail in separate "layers" 
          of different scales, and then to combine these layers by adding them 
          together (employing <firstterm>superposition</firstterm>, to borrow 
          signal theory terminology). To understand the distinction between 
          these methods and the following class (<xref linkend="Progressive Refinement Methods"/>), it is important to grasp that these 
          different layers are not <emphasis>themselves</emphasis> the LODs of 
          the terrain, but only the details belonging to a finite "slice" of the 
          frequency spectrum. The actual LODs can be reconstituted by summing 
          together all of the layers up to the requisite degree of fineness.
        </para>
        <para>
          Spectral synthesis methods <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Wavelet Synthesis"/> 
          <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Spectral Synthesis"/> take precisely this 
          approach: by setting the values of the various frequency-domain 
          coefficients, one can control the presence and importance of details 
          at different scales. The recombination of these different scales into 
          a spatial-domain height field is done by applying the appropriate 
          inverse transform (Fourier or wavelet) to the frequency-domain 
          representation.
        </para>
        <para>
          Another example of a superposition method is Perlin Noise <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Perlin Noise"/>, in which random noise layers of different 
          frequencies and amplitudes are added together; the choice of 
          frequency and amplitude for each of the layers gives some measure of 
          control over the overall characteristics of the resulting height 
          field.
        </para>
        <para>
          The practical success of Perlin Noise in computer graphics can be 
          largely attributed to its versatility. Compared to the LOD-agnostic 
          methods previously discussed (<xref linkend="LOD-agnostic Methods"/>), Perlin Noise (and similar superposition methods) allow 
          a user to achieve a greater variety of effects, by allowing him to 
          exert some degree of predictable control over the behavior of the 
          surface at different scales.
        </para>
      </section>

      <section id="Progressive Refinement Methods">
        <title>Progressive Refinement Methods</title>
        <para>
          A third approach to LOD in terrain generation is to refine the terrain 
          surface progressively, starting from a coarse LOD and adding finer and 
          finer details until the desired LOD is reached.  These methods differ 
          from those in the previous section (<xref linkend="Superposition Methods"/>) in that they construct new, fine-scale details as 
          modifications to the coarser LODs.
        </para>
        <para>
          These methods often work by recursive subdivision: given a complete,  
          coarse LOD of the terrain, the next-finer LOD is constructed by 
          subdividing the coarse LOD and, at the same time, introducing new, 
          small-scale modifications to the terrain. The <citetitle>Midpoint 
            Displacement Method (MPD)</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Area51"/> 
          is, perhaps, the prototypical example of this.  
          <citetitle>Terrainosaurus</citetitle> also takes a progressive 
          refinement approach, though with a bit more sophistication in how it 
          introduces new details.
        </para>
        <para>
          A main advantage of progressive refinement methods over superposition 
          methods is that they can make use of the previously constructed, 
          coarse detail in deciding where and how to introduce the new, 
          fine-scale detail.  While no previously existing method of which I am 
          aware exploits this at all (and 
          <citetitle>Terrainosaurus</citetitle>, in its current incarnation, 
          does so only to a limited degree), I believe that this family of 
          methods holds the most promise for generating realistic terrain 
          containing recognizable, coherent features, such as rivers, volcanoes, 
          and ravines.
        </para>
      </section>

      <section id="Fractals and Not">
        <title>Fractals &amp; Non-fractals</title>
        <para>
          All terrain generation methods that are not agnostic with respect to 
          LOD must decide how to handle the different LODs: what kinds of 
          features will appear in each LOD, how large they will be, and how 
          they will relate to one another.  A physically correct solution to 
          this problem is difficult (perhaps the "Holy Grail" of terrain 
          generation), and as a result, many researchers and practitioners have 
          turned to fractals as an approximate solution.
        </para>
        <para>
          In his seminal work, <citetitle>The Fractal Geometry of 
            Nature</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Mandelbrot"/>, Benoit 
          Mandelbrot observed that many objects in nature display the fractal 
          characteristic of <firstterm>self-similarity</firstterm>, having 
          essentially the same structure when viewed at a variety of scales.  
          For example, the small-scale variations in elevation across a 
          1-meter-square piece of mountainous terrain might,  if one zooms back 
          far enough, happen to resemble the large-scale variations across the 
          entire mountain range.  This observation has been applied to great 
          effect in computer graphics, with fractal algorithms being used as 
          reasonable approximations of a number of natural structures, both 
          regular (e.g., plants and trees) and irregular (e.g., terrain).
        </para>
        <para>
          Randomized fractal algorithms are a convenient method of creating 
          irregular shapes across an entire range of LODs. Because each 
          successively finer LOD has a defined relationship to the one 
          preceding it (modulo the effects of the random number generator), 
          fractal algorithms offer effectively unlimited amounts of detail: 
          when rendering a fractal surface, one can evaluate the fractal to 
          whatever degree of fineness the display system is able to show.
        </para>
        <para>
          Still, as useful as the fractal approximation for terrain is, it 
          cannot tell the whole story—not all types of terrain exhibit 
          conveniently self-similar properties across all the levels of detail 
          at which we experience them. To see that this must be the case, one 
          need only consider the diverse array of physical forces that interact 
          to create real-world terrain—plate tectonics, erosion due to wind 
          &amp; water, earthquakes, avalanches, floods &amp; volcanic eruptions, 
          dehydration &amp; thermal expansion (to name a few)—it is 
          intuitively obvious that each of these forces acts more noticeably at 
          some scales than at others.  <xref linkend="Cracked Mud"/> is a 
          photograph, taken close-up, of cracked, dried mud formed at the bottom 
          of a volcanic crater in the Death Valley area in California; if a 
          fractal relationship held between this bit of terrain and its 
          surrounding macro-environment, we would expect to find it in the 
          context of an area characterized by broad, flat mesas, separated by 
          narrow, severe ravines. As it turns out, this photo was taken at the 
          bottom of a relatively shallow, sloping crater. Obviously, in this 
          example, no fractal relationship holds between these two scales.
        </para>
        <figure id="Cracked Mud" float="0">
          <title>Cracked Mud</title>
          <mediaobject>
            <caption>
              A photograph taken close-up of cracked mud. The physical process 
              predominantly responsible for this effect does not manifest in the 
              same way in the surrounding larger-scale environment. As a result, 
              while a fractal relationship does appear to exist in the terrain 
              in this photo, we would not expect this local effect to be 
              co-reducible, along with its surrounding environment, to a single 
              fractal function.  (Photo courtesy of 
              <citetitle>www.freenaturepictures.com</citetitle>.)
            </caption>
            <imageobject>
              <imagedata scalefit="1" width="4in" fileref="Cracked Mud.jpeg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          Therefore, since fractal relationships cannot be trusted to hold in 
          the general case, any terrain generation algorithm that relies on 
          fractal behavior is inherently limited—there will be types of 
          terrain (probably <emphasis>many</emphasis> types of terrain) that it 
          will be unable to reproduce. Any terrain generation algorithm that 
          aims to support a broad range of terrain types at various scales must 
          allow for the possibility of non-self-similar terrain.
        </para>
        <para>
          This leads to the observation that multi-scale, 
          <emphasis>fractal</emphasis> terrain generation algorithms are simply 
          a special case of a more general class of multi-scale, 
          <emphasis>not-necessarily-fractal</emphasis> terrain generation 
          algorithms. Fractal algorithms answer the question, "What should the 
          terrain look like at this scale?", with, "Just like it did at the 
          larger scale, but smaller." This is a straightforward way of 
          generating terrain across multiple LODs, but it is probably not 
          sufficient for many types of terrain.  Part of the goal of 
          <citetitle>Terrainosaurus</citetitle> is to provide an alternative 
          answer to this question, leading to a terrain generation methodology 
          that is more general and controllable.
        </para>
      </section>
    </section>

    <section id="Existing Tools">
      <title>Existing Tools for Terrain Generation</title>
      <para>
        While the list of terrain generation software is too large to be 
        reviewed exhaustively in this section, it is worthwhile to make note of 
        a representative sampling. Most of these applications permit the use of 
        more than one of the above techniques as a way of mitigating the 
        weaknesses of each.
      </para>

      <section>
        <title>Terragen</title>
        <para>
          <citetitle>Terragen</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Terragen"/> is a 
          well-known terrain generation and rendering tool, developed by 
          Planetside Software, free for non-commercial use. It provides several 
          fractal algorithms for generating terrains and also provides a simple 
          set of sculpting tools for modifying the resultant height fields. It 
          offers an integrated ray tracing engine including some very nice 
          cloud, water, and atmospheric lighting effects, and has a significant 
          artistic community.
        </para>
      </section>

      <section>
        <title>MojoWorld</title>
        <para>
          <citetitle>MojoWorld</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="MojoWorld"/> is 
          a set of applications for creating and exploring fractal worlds. 
          <citetitle>MojoWorld Transporter</citetitle> is a free program for 
          exploring the worlds created by the commercial product, 
          <citetitle>MojoWorld Generator</citetitle>.  Unlike most hybrid 
          fractal/sculpting terrain generators, 
          <citetitle>MojoWorld</citetitle> handles fractal objects in symbolic 
          form, allowing entire worlds to be viewed at any level of detail and 
          stored in relatively small files.
        </para>
      </section>

      <section>
        <title>Bryce 3D</title>
        <para>
          <citetitle>Bryce 3D</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Bryce 3D"/> is a 
          general-purpose 3D modeling and animation tool, but is perhaps best 
          known for its terrain modeling capabilities. It offers a full set of 
          painting/sculpting tools for generating and editing 
          height-field-based terrain objects, including the ability to use Adobe 
          <citetitle>Photoshop</citetitle> image filters.
        </para>
      </section>

      <section>
        <title>World Machine</title>
        <para>
          <citetitle>World Machine</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="World Machine"/> is a procedural height field generation tool, free for 
          non-commercial use. Its most interesting aspect is that it treats the 
          terrain creation process as composed of simple "device" primitives 
          (e.g., 2D Perlin noise generator, Gaussian blur filter, etc.) which 
          the user connects to form a "machine", a directed acyclic graph (DAG) 
          that will produce the height field when evaluated.  The main benefit 
          of this approach over a more traditional fractal/sculpting approach is 
          that, since the series of operations is preserved in the DAG, the user 
          is free to tweak the parameters of any stage of the generation 
          process, rather than having to commit to a particular filter size, 
          random seed, etc. at the outset.
        </para>
      </section>

      <section>
        <title>Erosion 3D</title>
        <para>
          <citetitle>Erosion 3D</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Erosion 3D"/> 
          is an application for simulating the effects of water erosion on 
          height field terrain. Developed at the Department of Soil Science and 
          Water Protection of the Institut fÃ¼r Geographische Wissenschaften 
          (Institute for Geographic Sciences) in Germany, <citetitle>Erosion 
            3D</citetitle> is intended primarily as an analysis tool, not as a 
          terrain creation tool.
        </para>
      </section>

    </section>

    <section id="Other Terrain Sources">
      <title>Other Sources for Terrain Information</title>
      <para>
        There also exist a number of community hubs and information portals on 
        the Internet that focus partially or exclusively on the synthesis and 
        use of virtual terrain. These sites are good places to go to find 
        mature, free software, tutorials, technical specifications, and links 
        to other resources.
      </para>

      <section>
        <title>United States Geological Survey</title>
        <subtitle>
                        <ulink url="http://www.usgs.gov"/>
</subtitle>
        <para>
          The <citetitle>U.S. Geological Survey</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="USGS"/> is a U.S.  government organization dedicated to 
          geographic, environmental and biological research. The USGS maintains 
          standards (i.e., file format specifications) for GIS data interchange, 
          offers downloadable GIS data, and provides a wealth of GIS-related 
          information.
        </para>
      </section>

      <section>
        <title>GeoCommunity</title>
        <subtitle>
                        <ulink url="http://www.geocomm.com"/>
</subtitle>
        <para>
          <citetitle>GeoCommunity</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="GeoCommunity"/> is a portal site for the GIS community, 
          and provides information, software, and freely downloadable GIS data 
          for the entire United States, and some other parts of the world.
        </para>
      </section>

      <section>
        <title>The Virtual Terrain Project</title>
        <subtitle>
                        <ulink url="http://www.vterrain.org"/>
</subtitle>
        <para>
          The <citetitle>Virtual Terrain Project (VTP)</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="VTP"/> is an online repository containing a wealth of 
          information and free, cross-platform software, as well as a portal to 
          additional resources.  The stated goal of VTP is "to foster the 
          creation of tools for easily constructing any part of the real world 
          in interactive, 3D digital form."
        </para>
      </section>

      <section>
        <title>Gamasutra</title>
        <subtitle>
                        <ulink url="http://www.gamasutra.com"/>
</subtitle>
        <para>
          <citetitle>Gamasutra</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Gamasutra"/> is 
          one of the premiere websites of the game developer community, 
          tracking game industry news and providing tutorials on useful 
          techniques for real-time interactive games, including techniques for 
          generating and visualizing terrain.
        </para>
      </section>

      <section>
        <title>NeHe</title>
        <subtitle>
                        <ulink url="http://www.nehe.gamedev.net"/>
</subtitle>
        <para>
          <citetitle>Neon Helium Productions (NeHe)</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="NeHe"/> is another game developer community site, focused 
          on largely on OpenGL, providing articles, tutorials and sample code.  
          It has a number of tutorials on terrain rendering and generation.
        </para>
      </section>

    </section>

  </section>

  <section>
    <title>Other Similar Works</title>
    <para>
      In the course of reviewing the existing terrain generation literature, 
      several papers were encountered that were especially similar to aspects of 
      <citetitle>Terrainosaurus</citetitle> (in spirit, at least, if not in 
      application).
    </para>

    <section>
      <title>
                    <citetitle>Procedural Modeling of Cities</citetitle>
</title>
      <para>
        This paper <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Procedural Cities"/> by Parish &amp; 
        Müller describes <citetitle>CityEngine</citetitle>, a procedural 
        approach to city generation (buildings, roads, etc.) using L-systems.  
        The user provides raster maps of the land elevation, bodies of water, 
        and population density, and <citetitle>CityEngine</citetitle> constructs 
        a plausible road network and a set of buildings matching these maps, 
        using L-system rules derived from studying actual cities.
      </para>
      <para>
        <citetitle>CityEngine</citetitle> is similar to 
        <citetitle>Terrainosaurus</citetitle> in a number of ways; in fact, 
        parts of <citetitle>Terrainosaurus</citetitle>'s generation pipeline 
        are inspired by that of <citetitle>CityEngine</citetitle>. In a sense, 
        they are "sister systems", attacking different problems (terrain vs.  
        cities), using different techniques (genetic algorithms vs. L-systems), 
        but with the same objective: extensible, realistic synthesis of 
        large-scale constructs, incorporating both human-designed layouts and 
        realism constraints derived from real-world observations.
      </para>
    </section>

    <section>
      <title>
                    <citetitle>Towards an Understanding of Landscape Scale and 
      Structure</citetitle>
</title>
      <para>
        This paper <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Positive Wavelet"/> by Gallant &amp; 
        Hutchinson investigates the relationship between the resolution of a 
        height field and the kinds of physical features that can be detected 
        within that height field. As their analysis tool, they use a 
        <firstterm>positive wavelet decomposition</firstterm> of the height 
        field (intuitively, the inverse of the aforementioned collaging methods 
        (<xref linkend="Procedural Methods"/>), although the positive wavelet 
        decomposition does not technically have an inverse operation) to break 
        it into features of different scales, from which they draw their 
        conclusions.
      </para>
      <para>
        While their objective is quite different (they are interested in 
        hydrological analysis), their work bears a resemblance to 
        <citetitle>Terrainosaurus</citetitle> in that they are seeking to 
        decompose terrain height fields into features of different scales in 
        order to characterize and understand them.
      </para>
    </section>

    <section>
      <title>
                    <citetitle>SAR Surface Ice Cover Discrimination Using Distribution 
      Matching</citetitle>
</title>
      <para>
        This paper <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Ice Cover Discrimination"/> by Gill 
        describes an algorithm for computer-aided discrimination between sea 
        ice and open water from synthetic aperture radar (SAR) imagery. In this 
        algorithm, a human identifies a region he believes to be "ice" and 
        another he believes to be "water", and then the computer categorizes 
        the rest of the image as "ice" or "water" using the Kolmogorov-Smimov 
        (KS) and <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/chi%5E2.mml">
  <msup>
    <mi>χ</mi>
    <mn>2</mn>
  </msup>
</math>

</inlineequation> 
        statistical distribution matching tests.
      </para>
      <para>
        This is similar to <citetitle>Terrainosaurus</citetitle> in that the 
        statistical characteristics of human-identified terrain types are used 
        to compare samples of terrain for similarity, though 
        <citetitle>Terrainosaurus</citetitle> uses a different means of 
        determining the degree of similarity.
      </para>
    </section>

    <section>
      <title>
                    <citetitle>Flexible Generation and Lightweight View-Dependent 
      Rendering of Terrain</citetitle>
</title>
      <para>
        This technical report <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Wavelet Synthesis"/> by 
        Pelton &amp; Atkinson describes a spectral synthesis technique for 
        terrain generation based on real-world GIS example data:
      </para>
      <procedure>
        <step performance="required">
          Compute a wavelet transform of the example height field
        </step>
        <step performance="required">
          From this, construct a frequency histogram of the example height 
          field
        </step>
        <step performance="required">
          Generate a new wavelet-space representation of a height field by 
          stochastically sampling the frequency histogram from the example 
          height field
        </step>
        <step performance="required">
          Create the spatial representation of the height field by performing 
          the inverse wavelet transform
        </step>
      </procedure>
      <para>
        In this way, they are able to create new height fields similar to a 
        reference height field. They note that their approach is successful at 
        creating unique results with similar roughness characteristics to the 
        original, but that it fails to capture semantic features, specifically 
        riverbeds.
      </para>
      <para>
        Their approach is similar to <citetitle>Terrainosaurus</citetitle> in 
        that both derive new, unique terrain models using example GIS elevation 
        maps.
      </para>
    </section>
  </section>

  <section>
    <title>Other Topics</title>
    <para>
      Having surveyed the landscape of terrain-related literature, there still 
      remain a few auxiliary topics that must be covered to set the stage 
      adequately for the <citetitle>Terrainosaurus</citetitle> algorithm:
      <itemizedlist spacing="compact">
        <listitem>
          genetic algorithms
        </listitem>
        <listitem>
          computer vision
        </listitem>
        <listitem>
          descriptive statistics
        </listitem>
      </itemizedlist>
    </para>

    <section id="Genetic Algorithms Overview">
      <title>Genetic Algorithms</title>
      <para>
        Unfortunately, many of the more interesting problems in computer 
        science fall into the class of <firstterm>NP hard</firstterm> problems 
        (for which there are no known polynomial-time solutions), meaning that 
        they become intractably difficult to solve optimally as the size of the 
        problem increases <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Algorithms"/>. In many cases, it 
        is not feasible to find a perfect solution, and approximation 
        techniques must be used. The <firstterm>genetic algorithm 
          (GA)</firstterm> is one of these techniques.
      </para>
      <para>
        Genetic algorithms are used in several places in 
        <citetitle>Terrainosaurus</citetitle> as a way of replacing the role of 
        human intelligence with a form of artificial intelligence. By pushing 
        the burden of constructing a believable terrain model onto the 
        computer, the human user is relieved of most of the work of terrain 
        generation.
      </para>
      <para>
        Conceptually, a genetic algorithm is a parallel search algorithm that 
        tries to find better and better solutions to its problem through a 
        process analogous to the Darwinian theory of biological micro-evolution.  
        Single possible solutions within the solution space of the problem are 
        called <firstterm>chromosomes</firstterm> (or, alternatively,  
        <firstterm>individuals</firstterm>). A <firstterm>fitness 
          function</firstterm> provides an evaluation of how good of a solution 
        any particular chromosome is, expressed as a scalar value. As the GA 
        iterates, new potential solutions to the problem are explored by taking 
        the more "fit" of the existing chromosomes and recombining some of their 
        sub-parts (their <firstterm>genes</firstterm>) to create new chromosomes 
        having characteristics of both "parents". By iteratively evolving a 
        <firstterm>population</firstterm> of chromosomes (generally of some 
        fixed size), the GA explores the solution space in a parallel fashion.  
        Hopefully, after some reasonable number of iterations, the most "fit" of 
        the chromosomes in the final population will be fairly close to an 
        optimal solution to the problem <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Genetic Algorithms"/>.
      </para>
      <para>
        In order to adapt a GA to solve a particular problem, we must define 
        three basic things:
        <itemizedlist spacing="compact">
          <listitem>
            a modular, genetic encoding for describing candidate solutions
          </listitem>
          <listitem>
            crossover and mutation operators to work on this genetic 
            representation
          </listitem>
          <listitem>
            a fitness function for evaluating the "goodness" of a particular 
            candidate solution
          </listitem>
        </itemizedlist>
      </para>
      <para>
        The meaning and implementation of these things will vary according to 
        the problem domain to which the GA is applied.
      </para>
    </section>

    <section>
      <title>Computer Vision</title>
      <para>
        <firstterm>Computer vision</firstterm> is the branch of computer 
        science concerned with processing images to recover conceptual 
        representations of the objects present within those images. Computer 
        vision techniques are useful in a number of areas, especially robotics 
        and augmented reality (AR) applications.
      </para>
      <para>
        In <citetitle>Terrainosaurus</citetitle>, feature detection techniques 
        are used in the analysis of terrain models, to find the location, size, 
        and scale of geometric features of the terrain (such as edges, ridges, 
        and peaks).
      </para>

      <section>
        <title>Single-scale Feature Detection</title>
        <para>
          The normal method of feature detection is to design a 
          <firstterm>detector</firstterm> for the desired feature, a function 
          that, given a pixel location within the image, returns a scalar 
          <firstterm>response</firstterm> indicating how much the pixels in that 
          vicinity resemble the desired feature. The stronger the resemblance, 
          the higher the response will be. This detector is then passed over 
          every pixel in the image, and its response recorded.  Pixels 
          containing local maxima of the detector response are kept, and the 
          other pixels are zeroed, a technique called <firstterm>non-maximal 
            suppression</firstterm>. The result is a greyscale image with grey 
          or white pixels wherever the feature was found and black elsewhere.
        </para>
        <para>
          Feature detectors are highly sensitive to the scale of the feature 
          being detected. For example, an edge detector optimized for finding 
          sharp edges between regions will perform poorly if the edges in the 
          image are diffuse (i.e., blurry), especially in the presence of noise.  
          Thus, it is important to tune the detector to the scale of feature 
          being sought.
        </para>
      </section>

      <section>
        <title>Scale-space Feature Detection</title>
        <para>
          Unfortunately, in many computer vision applications, the scales at 
          which features will appear are unknown.  If this is the case, then 
          <firstterm>scale-space</firstterm> feature detection may be used to 
          search for features across a range of scales <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Scale-space Blob"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Scale-space Edge/Ridge"/>.
        </para>
        <para>
          Scale-space feature detection is a relatively straightforward 
          extension of single-scale feature detection, in which locally maximal 
          detector responses are looked for, not only across the 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>

</inlineequation> domain of the image, 
          but also across adjacent scales.  Because the algorithm is independent 
          of the actual feature detector matrix used, virtually any single-scale 
          detector may be adapted to work in scale-space, including "blob" 
          detectors, "edge" detectors, "ridge" detectors, etc.
        </para>
        <procedure>
          <para>
            The major steps in scale-space feature detection are:
          </para>
          <step performance="required">
            Generate the scale-space representation of the image by convolving 
            the image with successively larger Gaussian blobs. This produces a 
            3-dimensional image "cube", in which the added dimension represents 
            scale; as the scale parameter increases, fine-scale image details 
            disappear, leaving only the larger-scale shapes.
          </step>
          <step performance="required">
            Calculate the feature detector response at every pixel in the 
            scale-space image.
          </step>
          <step performance="required">
            Find the locations within the scale-space image at which the 
            detector response is maximal. Finding the maxima in the 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>
</inlineequation> and             
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/y.mml">
  <mi>y</mi>
</math>

</inlineequation> dimensions yields the 
            locations of the detected features, while finding the scale at which 
            each is maximized gives an estimate of the size of the feature.
          </step>
        </procedure>
        <para>
          In this way, features present in the image may be recovered and, 
          additionally, classified according to the scale at which they appear.  
          For example, when ridge detection is performed on an image of a 
          crumpled piece of cloth, a tiny wrinkle in the fabric will yield a 
          maximal detector response at a fine scale, and will completely 
          disappear as the scale is increased. In contrast, a gentle fold in the 
          fabric will give some small response at the finest scale, and a much 
          higher response as the scale approaches that of the fold.
        </para>
        <para>
          If the only benefit of scale-space detectors over single-scale 
          detectors were that features are detectable at multiple scales, this 
          would not be much of an improvement over single-scale detectors 
          (since the same thing can be accomplished by running a single-scale 
          detector multiple times, at several different scales), and not worth 
          the additional cost in memory and computation time.  However, since 
          scale-space detectors are able to examine multiple scales 
          <emphasis>simultaneously</emphasis>, a "long" feature (such as an edge 
          or ridge) can be recognized as a single feature, even if it varies 
          dramatically in scale along its length. In contrast, a multi-pass, 
          single-scale detector would register multiple, partially overlapping 
          features in this case, rather than a single feature of varying scale.  
          As a result, a scale-space detector will report fewer features (and 
          generally, more meaningful ones).
        </para>
      </section>
    </section>

    <section id="Descriptive Statistics">
      <title>Descriptive Statistics</title>
      <para>
        <firstterm>Descriptive statistics</firstterm> is the branch of 
        statistics dealing with identifying patterns and trends within 
        collected samples of data. In <citetitle>Terrainosaurus</citetitle>, 
        measured statistics are used as a basis for comparing terrains for 
        similarity: intuitively, the more similar the statistical 
        characteristics of two terrains, the more "alike" they are. In 
        particular, we are interested in the following four statistics:
      </para>
      <itemizedlist spacing="compact">
        <listitem>the sample mean</listitem>
        <listitem>the sample standard deviation</listitem>
        <listitem>the sample skewness</listitem>
        <listitem>the sample kurtosis excess</listitem>
      </itemizedlist>
      <para>
        The following diagrams of these statistics depict distributions similar 
        in shape to a Gaussian (normal) distribution.  This is because some of 
        these measures (the skewness and kurtosis excess) are defined with 
        reference to the Gaussian distribution, such that the Gaussian 
        distribution has a value of zero. Thus, Gaussian-like distributions are 
        convenient for conveying an intuitive sense of the statistic.  This 
        should not be taken to mean that these measures apply only to the 
        Gaussian distribution; they are defined wholly in terms of raw moments 
        and central moments of the distribution, and can be applied to any 
        distribution. The degree to which these measures deviate from zero gives 
        an indication of how non-Gaussian the distribution is.
      </para>

      <section>
        <title>The Sample Mean</title>
        <para>
          The best-known statistic is the <firstterm>sample mean</firstterm>, or 
          unweighted average (<xref linkend="Sample Mean Equation"/>).  
          Intuitively, this is the "center" value of a sample distribution 
          (<xref linkend="Mean Illustration"/>) <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Mean"/>.
        </para>
        <figure id="Mean Illustration" float="0">
          <title>Mean</title>
          <mediaobject>
            <caption>
              The mean of a statistical distribution is a first-order measure 
              and is the value around which the distribution is centered.
            </caption>
            <imageobject>
              <imagedata fileref="Statistics - Mean Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <equation id="Sample Mean Equation">
          <title>The Sample Mean</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Statistics%20-%20Sample%20Mean%20Equation.mml">
  <mi>μ</mi>
  <mo>=</mo>
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mi>N</mi>
  </munderover>
  <mfrac linethickness="thin">
    <mn>1</mn>
    <msub>
      <mi>x</mi>
      <mi>i</mi>
    </msub>
  </mfrac>
</math>
        </equation>
      </section>

      <section>
        <title>The Sample Standard Deviation</title>
        <para>
          A second useful statistic is the <firstterm>sample standard 
          deviation</firstterm>, <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma.mml">
  <mi>σ</mi>
</math>

                        </inlineequation>, a non-negative value 
          measuring the degree of variability of a sample distribution (<xref linkend="Sample Standard Deviation Equation"/>). A low standard 
          deviation indicates that the sample values are tightly clustered about 
          the mean (<xref linkend="Standard Deviation Illustration"/>) 
          <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Standard Deviation"/>.
        </para>
        <figure id="Standard Deviation Illustration" float="0">
          <title>Standard Deviation</title>
          <mediaobject>
            <caption>
              The standard deviation of a statistical distribution is a 
              second-order measure describing the degree to which the 
              distribution is "spread out".
            </caption>
            <imageobject>
              <imagedata fileref="Statistics - Standard Deviation Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <equation id="Sample Standard Deviation Equation">
          <title>The Sample Standard Deviation</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Statistics%20-%20Sample%20Standard%20Deviation%20Equation.mml">
  <mi>σ</mi>
  <mo>=</mo>
  <msqrt>
    <mfrac linethickness="thin">
      <mn>1</mn>
      <mi>N</mi>
    </mfrac>
    <munderover>
      <mo>∑</mo>
      <mrow>
        <mi>i</mi>
        <mo>=</mo>
        <mn>1</mn>
      </mrow>
      <mi>N</mi>
    </munderover>
    <msup>
      <mfenced>
        <mrow>
          <msub>
            <mi>x</mi>
            <mi>i</mi>
          </msub>
          <mo>−</mo>
          <mi>μ</mi>
        </mrow>
      </mfenced>
      <mn>2</mn>
    </msup>
  </msqrt>
</math>
        </equation>
      </section>

      <section>
        <title>The Sample Skewness</title>
        <para>
          A third, lesser-known statistic is the <firstterm>sample 
            skewness</firstterm>, <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/gamma_1.mml">
  <msub>
    <mi>γ</mi>
    <mn>1</mn>
  </msub>
</math>

                        </inlineequation>, which measures 
          the degree of asymmetry of a sample distribution (<xref linkend="Sample Skewness Equation"/>). A skewness of zero indicates 
          that the distribution is perfectly symmetrical about the  mean, 
          whereas a positive or negative skewness indicates that the 
          distribution is skewed to the left or right of the mean, respectively 
          (<xref linkend="Skewness Illustration"/>) <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Skewness"/>.
        </para>
        <figure id="Skewness Illustration" float="0">
          <title>Skewness</title>
          <mediaobject>
            <caption>
              The skewness of a statistical distribution is a third-order 
              measure describing the amount of asymmetry of the distribution.  
              Values less than zero indicate that the distribution is skewed to 
              the left of the mean, and values greater than zero indicate that 
              the distribution is skewed to the right.
            </caption>
            <imageobject>
              <imagedata fileref="Statistics - Skewness Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <equation id="Sample Skewness Equation">
          <title>The Sample Skewness</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Statistics%20-%20Sample%20Skewness%20Equation.mml">
  <msub>
    <mi>γ</mi>
    <mn>1</mn>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="thin">
    <msub>
      <mi>k</mi>
      <mn>3</mn>
    </msub>
    <msubsup>
      <mi>k</mi>
      <mn>2</mn>
      <mfrac linethickness="thin" bevelled="true">
        <mn>3</mn>
        <mn>2</mn>
      </mfrac>
    </msubsup>
  </mfrac>
</math>
        </equation>
        <para>
          This formulation of the skewness is in terms of the second and third 
          <firstterm>k-statistics</firstterm>. The first four k-statistics are 
          given in <xref linkend="k-Statistic Equations"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="k-Statistic"/>.
        </para>
        <equation id="k-Statistic Equations">
          <title>The First Four k-Statistics</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Statistics%20-%20K-statistic%20Equations.mml">
  <mtable columnalign="left">
    <mtr>
      <mtd>
        <msub>
          <mi>k</mi>
          <mn>1</mn>
        </msub>
        <mo>=</mo>
        <msub>
          <mi>m</mi>
          <mn>1</mn>
        </msub>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <msub>
          <mi>k</mi>
          <mn>2</mn>
        </msub>
        <mo>=</mo>
        <mfrac linethickness="thin">
          <mi>n</mi>
          <mrow>
            <mi>n</mi>
            <mo>−</mo>
            <mn>1</mn>
          </mrow>
        </mfrac>
        <mo>⁢</mo>
        <msub>
          <mi>m</mi>
          <mn>2</mn>
        </msub>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <msub>
          <mi>k</mi>
          <mn>3</mn>
        </msub>
        <mo>=</mo>
        <mfrac linethickness="thin">
          <msup>
            <mi>n</mi>
            <mn>2</mn>
          </msup>
          <mrow>
            <mfenced>
              <mrow>
                <mi>n</mi>
                <mo>−</mo>
                <mn>1</mn>
              </mrow>
            </mfenced>
            <mo>⁢</mo>
            <mfenced>
              <mrow>
                <mi>n</mi>
                <mo>−</mo>
                <mn>2</mn>
              </mrow>
            </mfenced>
          </mrow>
        </mfrac>
        <mo>⁢</mo>
        <msub>
          <mi>m</mi>
          <mn>3</mn>
        </msub>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <msub>
          <mi>k</mi>
          <mn>4</mn>
        </msub>
        <mo>=</mo>
        <mfrac linethickness="thin">
          <mrow>
            <msup>
              <mi>n</mi>
              <mn>2</mn>
            </msup>
            <mo>⁢</mo>
            <mfenced open="[" close="]">
              <mrow>
                <mfenced>
                  <mrow>
                    <mi>n</mi>
                    <mo>+</mo>
                    <mn>1</mn>
                  </mrow>
                </mfenced>
                <mo>⁢</mo>
                <msub>
                  <mi>m</mi>
                  <mn>4</mn>
                </msub>
                <mo>−</mo>
                <mn>3</mn>
                <mo>⁢</mo>
                <mfenced>
                  <mrow>
                    <mi>n</mi>
                    <mo>−</mo>
                    <mn>1</mn>
                  </mrow>
                </mfenced>
                <msubsup>
                  <mi>m</mi>
                  <mn>2</mn>
                  <mn>2</mn>
                </msubsup>
              </mrow>
            </mfenced>
          </mrow>
          <mrow>
            <mfenced>
              <mrow>
                <mi>n</mi>
                <mo>−</mo>
                <mn>1</mn>
              </mrow>
            </mfenced>
            <mo>⁢</mo>
            <mfenced>
              <mrow>
                <mi>n</mi>
                <mo>−</mo>
                <mn>2</mn>
              </mrow>
            </mfenced>
            <mo>⁢</mo>
            <mfenced>
              <mrow>
                <mi>n</mi>
                <mo>−</mo>
                <mn>3</mn>
              </mrow>
            </mfenced>
          </mrow>
        </mfrac>
      </mtd>
    </mtr>
  </mtable>
</math>
        </equation>
        <para>
          where <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/_n.mml">
  <mi>n</mi>
</math>

                        </inlineequation> is the sample size and the 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/m_r.mml">
  <msub>
    <mi>m</mi>
    <mi>r</mi>
  </msub>
</math>

                        </inlineequation>'s are the 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/_r.mml">
  <mi>r</mi>
</math>
                        </inlineequation>
          <superscript>th</superscript> sample central moments, given by <xref linkend="Sample Central Moment Equation"/> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Sample Central Moment"/>.
        </para>
        <equation id="Sample Central Moment Equation">
          <title>Sample Central Moment</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Statistics%20-%20Sample%20Central%20Moment%20Equation.mml">
  <msub>
    <mi>m</mi>
    <mi>r</mi>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="thin">
    <mn>1</mn>
    <mi>n</mi>
  </mfrac>
  <mo>⁢</mo>
  <munderover>
    <mo>∑</mo>
    <mrow>
      <mi>i</mi>
      <mo>=</mo>
      <mn>1</mn>
    </mrow>
    <mi>n</mi>
  </munderover>
  <msup>
    <mfenced>
      <mrow>
        <msub>
          <mi>x</mi>
          <mi>i</mi>
        </msub>
        <mo>−</mo>
        <mi>μ</mi>
      </mrow>
    </mfenced>
    <mi>r</mi>
  </msup>
</math>
        </equation>
      </section>

      <section>
        <title>The Sample Kurtosis Excess</title>
        <para>
          A fourth statistic is the <firstterm>sample kurtosis 
          excess</firstterm>, <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/gamma_2.mml">
  <msub>
    <mi>γ</mi>
    <mn>2</mn>
  </msub>
</math>

                        </inlineequation>, often simply called 
          the <firstterm>sample kurtosis</firstterm>, which measures the degree 
          of peakedness of a sample distribution (<xref linkend="Sample Kurtosis Equation"/>).  The normal distribution has a kurtosis of zero, 
          whereas a more peaked distribution  has a positive kurtosis and a 
          flattened distribution has a negative kurtosis (<xref linkend="Kurtosis Illustration"/>) <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Kurtosis"/>.
        </para>
        <figure id="Kurtosis Illustration" float="0">
          <title>Kurtosis</title>
          <mediaobject>
            <caption>
              The kurtosis excess of a statistical distribution is a 
              fourth-order measure describing the amount of "peakedness" of the 
              distribution. Values less than zero indicate that the distribution 
              is more "flat" than a normal distribution, and values greater than 
              zero indicate that the distribution is more peaked than a normal 
              distribution.
            </caption>
            <imageobject>
              <imagedata fileref="Statistics - Kurtosis Excess Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <equation id="Sample Kurtosis Equation">
          <title>The Sample Kurtosis Excess</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Statistics%20-%20Sample%20Kurtosis%20Excess%20Equation.mml">
  <msub>
    <mi>γ</mi>
    <mn>2</mn>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="thin">
    <msub>
      <mi>k</mi>
      <mn>4</mn>
    </msub>
    <msubsup>
      <mi>k</mi>
      <mn>2</mn>
      <mn>2</mn>
    </msubsup>
  </mfrac>
</math>
        </equation>
      </section>
      <para>
        The <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/k_i.mml">
  <msub>
    <mi>k</mi>
    <mi>i</mi>
  </msub>
</math>

                    </inlineequation>'s are the second and fourth 
        k-statistics, as defined above in <xref linkend="k-Statistic Equations"/>.
      </para>
    </section>

  </section>

</chapter>
  <chapter id="Methods" xml:base="methods.xml">
  <title>Methods</title>
  <para>
    In this chapter, I discuss the <citetitle>Terrainosaurus</citetitle> 
    algorithm at a conceptual level, including its overall strategy and major 
    steps, explaining the rationale for important design decisions. The gritty 
    details of implementing the algorithm are glossed over here, and presented 
    in detail in the chapter on implementation (<xref linkend="Implementation"/>). These topics will be covered in the following 
    order:
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      prerequisites—design strategy and basic tools
    </listitem>
    <listitem>
      how the algorithm works from the user's perspective
    </listitem>
    <listitem>
      how the algorithm works from the computer's perspective
    </listitem>
  </itemizedlist>

  <section>
    <title>Prerequisites</title>
    <para>
      Before delving into the details of the algorithm, there are several 
      things that must be nailed down first, outlining the basic strategies 
      underlying <citetitle>Terrainosaurus</citetitle>:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        how ease of use will be ensured
      </listitem>
      <listitem>
        how the terrain generation problem will be attacked
      </listitem>
      <listitem>
        what data structure will be used to represent the terrain
      </listitem>
      <listitem>
        how level of detail will be addressed
      </listitem>
    </itemizedlist>

    <section>
      <title>Usability Considerations</title>
      <para>
        Since one of our major stated objectives is to create something easy to 
        use, this aspect deserves specific consideration. While a full-scale 
        user study would be helpful in this respect, this is outside the scope 
        of this thesis. Nevertheless, there are basic user-interaction decisions 
        we can make that will, <foreignphrase>prima facie</foreignphrase>, 
        promote usability.
      </para>
      <para>
        The crucial observation to make, in this regard, is that not all 
        possible parameters and constraints for a terrain generation algorithm 
        are of the same nature. For our purposes, it will suffice to 
        distinguish between three types:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          those that are essentially <firstterm>free</firstterm>, meaning that 
          the user can manipulate them for artistic purposes (within limits, of 
          course), without damaging the apparent realism of the 
          terrain—examples of these include the size of a mountain range, 
          and the placement of lakes and mountain peaks
        </listitem>
        <listitem>
          those that are critical for maintaining the apparent realism of the 
          terrain—examples of these include the characteristic fine-scale 
          detail of different terrain types, and the smoothness of transitions 
          between different terrain types
        </listitem>
        <listitem>
          everything else—the miscellaneous parameters that influence things 
          like algorithm running time, memory usage and quality of results
        </listitem>
      </itemizedlist>
      <para>
        In everything, our goal is for <citetitle>Terrainosaurus</citetitle> to 
        be thoroughly intuitive. For each of these three types of 
        parameters/constraints, a different method of user interaction is most 
        appropriate.
      </para>

      <section>
        <title>Visual Authoring</title>
        <para>
          Those aspects of the terrain that can be freely manipulated for 
          artistic effect without impacting the realism of the terrain belong 
          under the control of the user. Since most of these are spatial and/or 
          visual, a visual authoring environment is the obvious choice, allowing 
          the author to interact with a visual representation of his work, and 
          to refine it incrementally until it reaches his satisfaction. Human 
          beings process visually-presented information quite efficiently, and 
          we would expect this to be especially true of information that is 
          already spatial in nature, such as terrain.  Furthermore, the digital 
          art community works almost exclusively with 2D and 3D visual authoring 
          tools (e.g., <citetitle>Photoshop</citetitle>, <citetitle>3D 
            Studio</citetitle>, <citetitle>Maya</citetitle>), and will be much 
          more likely to adopt a tool that allows them to work in this fashion.
        </para>
      </section>

      <section>
        <title>Example-based Design</title>
        <para>
          In contrast to the previous section, those aspects of the terrain that 
          are crucial for maintaining its realism are not especially suitable 
          candidates for user authoring. These are likely to be more highly 
          constrained, and possibly in ways that are not well understood or 
          would be tedious or impossible to replicate by hand (e.g., satisfying 
          a certain statistical distribution). Such things are perhaps better 
          left for the computer to solve, freeing the user to do what the 
          computer cannot: imagine and create.
        </para>
        <para>
          Still, the user needs to be able to control the characteristics of 
          the generated terrain in <emphasis>some</emphasis> way.  A 
          <firstterm>design by example</firstterm> approach is a graceful 
          method of specifying these characteristics: rather than requiring the 
          user to comprehend the complexities that give a particular flavor of 
          terrain its identity, we simply ask him to provide one or more 
          examples that exhibit the characteristics he would like to see 
          replicated in his terrain. In this way, the burden of 
          reverse-engineering terrain is transferred off of the user and on to 
          the software, and the algorithm becomes a true "black box" from the 
          user's perspective, requiring almost no domain knowledge to be used.
        </para>
        <para>
          Two additional benefits come from taking such an approach. First, the 
          algorithm is easily extensible, since the user can simply add new 
          examples of terrain to achieve new effects. Second, the algorithm can 
          be "upgraded" completely transparently to the user—because of the 
          simplicity of the interface, improvements can be made to the algorithm 
          without the user having to learn to use new parameters, or even 
          needing to know that anything has changed.
        </para>
      </section>

      <section>
        <title>Miscellaneous Controls</title>
        <para>
          Naturally, there are other parameters and constraints that do not fit 
          well into either of the above categories.  If these values cannot be 
          determined automatically, then other methods of presenting them to 
          the user will be required, such as standard GUI controls (sliders, 
          buttons, etc.).
        </para>
        <para>
          Having additional, non-visual parameters for the user to set is not, 
          in itself, a problem.  The important thing is not for all parameters 
          to be expressible visually, but for all parameters to be 
          <emphasis>intuitive</emphasis>: the meaning of the parameter should 
          be easily understood by a user who has no comprehension of the inner 
          workings of the algorithm. As a result, the user should have a fair 
          idea of what the effect of changing each parameter will be, even 
          before the change is made.
        </para>
        <para>
          One example of a non-visual parameter that is nonetheless intuitive 
          is a "quality" parameter that adjusts a tradeoff between the amount 
          of processing time spent and the realism of the result produced. Even 
          though this tradeoff does not have an obvious visual meaning, humans 
          already understand the concept of spending additional time working on 
          a task to achieve a better result.
        </para>
        <para>
          As an example of the sort of parameters that we want to 
          <emphasis>avoid</emphasis> presenting to the user, consider the 
          well-known Perlin Noise <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Perlin Noise"/> function.  
          While the usefulness of Perlin Noise is indisputable—it has been 
          used to great effect for creating believable imitations of a wide 
          variety of natural phenomena—it has a significant drawback: it 
          requires a non-trivial amount of domain knowledge (or else brute 
          force, trial-and-error experimentation) to achieve a desired result.  
          To a novice user, the parameters (e.g., <property moreinfo="none">octaves</property>, 
          <property moreinfo="none">turbulence</property>, <property moreinfo="none">persistence</property>) are 
          "magic": it is difficult to gain an intuition for the effects of 
          tweaking one of them without first understanding how Perlin Noise 
          works.
        </para>
      </section>
    </section>

    <section>
      <title>Terrain Generation Strategy</title>
      <para>
        Obviously, there is no unique "correct" answer to the problem of 
        generating terrain; instead, there are infinitely many "good" answers, 
        infinitely many more "bad" answers, and everything in between. Thus, 
        the quest to make believable terrain can be viewed as a search over an 
        infinitely large solution space, in which some solutions are 
        quantitatively better than others.
      </para>
      <para>
        A number of methods exist for finding good approximate solutions to 
        problems for which an exhaustive search is infeasible or (as in the 
        case of terrain generation) impossible. These methods vary in 
        performance and generality. In <citetitle>Terrainosaurus</citetitle>, 
        we have chosen to use a genetic algorithm for this purpose (<xref linkend="Genetic Algorithms"/>). The major benefits of GAs (for our 
        purposes) are:
        <itemizedlist spacing="compact">
          <listitem>
            they are randomized, rather than deterministic; as a result, they 
            are capable of some degree of innovation and can produce an 
            effectively unlimited number of unique terrain models.  
            Additionally, this randomness can enable a properly-tuned GA to 
            escape from locally "best" solutions in order to find other, better 
            solutions.
          </listitem>
          <listitem>
            they are extremely general: a GA treats its problem as a "black 
            box", and need not understand the complex effects of the changes it 
            makes, only caring about the results of the fitness evaluation.  
            Because of this, a GA can unite a diversity of orthogonal or 
            competing constraints: anything that can be incorporated into the 
            fitness evaluation. This makes a GA an attractive development tool, 
            as it leaves open a straightforward means of adding new constraints 
            as they become necessary.
          </listitem>
        </itemizedlist>
      </para>
    </section>

    <section>
      <title>Choice of Data Structure</title>
      <para>
        The terrain data structure used in 
        <citetitle>Terrainosaurus</citetitle> is the height field
        <footnote>
          <para>
            Throughout the remainder of this thesis, the terms <firstterm>height 
            field</firstterm> and <firstterm>terrain</firstterm> will be used 
            synonymously, unless otherwise noted.
          </para>
        </footnote>
        (<xref linkend="Height Fields"/>). This decision makes sense in light of 
        two facts:
      </para>
      <orderedlist spacing="compact" inheritnum="ignore" continuation="restarts">
        <listitem>
          most current, real-time applications of terrain use height fields
        </listitem>
        <listitem>
          GIS elevation data is most widely available in this form; as a result, 
          the data has <emphasis>already</emphasis> been sampled to a finite 
          resolution and has lost its ability to resolve features like overhangs 
          and caves. Thus, there is no further penalty for using height fields, 
          and no additional benefit to using other representations that do not 
          share these restrictions
        </listitem>
      </orderedlist>
    </section>

    <section>
      <title>Level of Detail Strategy</title>
      <para>
        From an LOD perspective, the terrain generation problem can be 
        understood as the problem of constructing a height field having the 
        following characteristics:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          at each LOD, appropriate, characteristic features are present in the 
          terrain, in correct proportions
        </listitem>
        <listitem>
          the entire set of LODs is <firstterm>coherent</firstterm>, meaning 
          that features present in coarse LODs continue to exist at the same 
          locations in the finer LODs
        </listitem>
      </itemizedlist>
      <para>
        As was stated in <xref linkend="Progressive Refinement Methods"/>, 
        <citetitle>Terrainosaurus</citetitle> approaches terrain construction as 
        a multi-LOD, progressive refinement process. As was also mentioned 
        earlier (<xref linkend="Fractals and Not"/>), one of the more 
        significant goals of <citetitle>Terrainosaurus</citetitle> is to offer a 
        not-necessarily-fractal answer to the question of what the terrain ought 
        to look like at any given LOD.
      </para>
    </section>
    
  </section>

  <section>
    <title>The User's Perspective (What It Does)</title>
    <para>
      Since ease-of-use is one of the primary objectives of our approach, it is 
      worth taking some time to walk through how our approach looks from the 
      perspective of a user. This will also serve to create the context for the 
      more technical discussion to follow. Consider a hypothetical user, a set 
      designer for a large computer animation studio. Among this user's routine 
      tasks is the construction of outdoor, virtual worlds for the commercials, 
      feature films, and video game content that his company develops.
    </para>
    <para>
      From the user's perspective, terrain generation with       
      <citetitle>Terrainosaurus</citetitle> involves three discrete phases:
    </para>
    <itemizedlist spacing="compact">
      <listitem>
        assembling a terrain library
      </listitem>
      <listitem>
        authoring a terrain map
      </listitem>
      <listitem>
        generating a height field
      </listitem>
    </itemizedlist>

    <section id="Terrain Library Assembly">
      <title>Terrain Library Assembly</title>
      <para>
        The user's first step is to assemble a <firstterm>terrain 
          library</firstterm>, the "palette" with which he will later "paint" 
        his terrain models. His task in this phase is to define the taxonomy of 
        <firstterm>terrain types</firstterm> he wants to use.  Terrain types are  
        logical abstractions, semantic classes of terrain, as a human would 
        think of them (things like "steep mountains", "sandy beach", "rocky 
        desert", "plains", etc.) and are created by providing one or more 
        <firstterm>terrain samples</firstterm>, example height fields 
        representative of these classes. These examples will normally come from 
        providers of real-world GIS data (e.g., <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="GeoCommunity"/>), though they could potentially come from 
        other sources as well. Once the user has populated his library with 
        example terrains, <citetitle>Terrainosaurus</citetitle> analyzes the 
        library (see <xref linkend="Terrain Library Analysis"/>) in order to 
        identify unifying characteristics for each terrain type, measurable 
        quantities that are similar across all of the example terrains within a 
        single terrain type (and thus, which are likely to contribute to the 
        user's perception of those terrains as being related). These example 
        terrains will also serve as the raw material for constructing new height 
        fields in the third phase (see <xref linkend="Height Field GA"/>).
      </para>
      <para>
        Because terrain types are correlative to human mental categories, they 
        are effectively unlimited in number, and will vary according to the 
        user.  No matter how many terrain types are identified, there will 
        always be someone who wants something just a bit different. At the same 
        time, the choice of terrain types is not wholly arbitrary—it is 
        important that example terrains for the same terrain type 
        <emphasis>are</emphasis> truly similar in some way, or else the terrain 
        analysis process will be hindered, because 
        <citetitle>Terrainosaurus</citetitle> will be unable to identify 
        meaningful unifying characteristics for that terrain type.
      </para>
      <para>
        The user's terrain libraries can be as coarse- or as fine-grained as he 
        wishes, depending on his needs, and he might have separate libraries for 
        different purposes. For example, he might define many variations of 
        "mountains" in order to finely control the kinds of features that appear 
        throughout a mountainous terrain model, or he might have only a few, 
        highly different, general-purpose terrain types for building more 
        heterogeneous worlds.
      </para>
      <para>
        While the construction of the terrain library is likely to be a bit 
        tedious, it is something that will be done only infrequently, as once a 
        terrain library has been assembled, it can be reused indefinitely, and 
        extended incrementally as additional terrain types are needed. <xref linkend="Computer-aided Classification"/> discusses potential avenues 
        for future research that might help alleviate this burden on the user.
      </para>
    </section>

    <section>
      <title>Map Design</title>
      <para>
        The user's primary design task when using 
        <citetitle>Terrainosaurus</citetitle> is to create the layout of his 
        terrain. He does this visually, creating a 2D, vector-drawn map of the 
        terrain using a CAD-style interface (<xref linkend="Map Editor Interface"/>).  By representing the map as a vector drawing rather 
        than a raster image, we avoid committing to a particular resolution for 
        the map, enabling the user to defer the decision of what LOD to generate 
        until he actually generates it, allowing him to produce multiple LODs 
        from a single map.  The map is made up of one or more polygonal regions 
        of terrain, which may be of arbitrary sizes and shapes. Each region is 
        assigned one of the terrain types from the library. Through sketching 
        out such regions and tweaking their shapes, the user can express the 
        approximate layout he desires for his terrain, using a modeling paradigm 
        that is well-established and intuitive.
      </para>
      <figure id="Map Editor Interface" float="0">
        <title>The Map Authoring Interface</title>
        <mediaobject>
          <caption>
            The user describes his desired terrain layout by authoring a 2D map, 
            which specifies the location, size, and shape of regions of terrain, 
            each of which may have its own terrain type.  A CAD-style interface 
            allows the user to accomplish this using a familiar and intuitive 
            design paradigm.
          </caption>
          <imageobject>
            <imagedata scalefit="1" width="4in" fileref="Map Authoring Interface.jpeg"/>
          </imageobject>
        </mediaobject>
      </figure>

      <section>
        <title>Boundary Refinement</title>
        <para>
          The use of polygons to represent regions in the terrain type map has 
          the advantage of simplicity: operations on polygons are well-defined 
          and well-understood, and provide a straightforward way for a user to 
          work with the map.  However, while linear shapes are useful tools for 
          modeling, their linearity is also a drawback: since polygons are 
          restricted to having straight edges, curved or irregular shapes may 
          require large numbers of small segments to be adequately approximated.  
          If the approximation is not fine enough for the particular 
          application, the unrealistically straight edges will be visible. In 
          our case, this means that if the length of a linear region boundary is 
          large compared to the resolution of the generated height field, this 
          boundary may be reflected visibly in the generated terrain as an 
          unnaturally straight transition between two terrain  types; the longer 
          the boundary, the more noticeable this is likely to be.  If the height 
          field is colored or texture-mapped according to terrain type, this 
          effect is greatly magnified (<xref linkend="Boundary Artifacts"/>).  
          Therefore it is important that the boundaries between regions be of 
          sufficiently fine scale.
        </para>
        <figure id="Boundary Artifacts" float="0">
          <title>Artifacts Resulting from Linear Region Boundaries</title>
          <mediaobject>
            <caption>
              Seams between adjacent regions can appear as unnatural-looking 
              artifacts in the generated height field if the region boundaries 
              are long and linear. This effect is made all the more obvious by 
              coloring or texture-mapping the regions.
            </caption>
            <imageobject>
              <imagedata scalefit="1" width="4in" fileref="Height Field With Boundary Artifacts.jpeg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          Creating such fine-scale boundaries by hand would be quite tedious, 
          and it is much to be preferred, from a user-experience standpoint, 
          that this task be automated. We do this by providing a 
          <firstterm>boundary refinement</firstterm> operation, which 
          non-destructively replaces a straight boundary from the user's 
          polygonal map with a new boundary that follows the same approximate 
          path as the original, but with a meandering, irregular shape made up 
          of many short segments (<xref linkend="Boundary Refinement"/>). The 
          user influences the shape of this boundary by adjusting a 
          <firstterm>smoothness</firstterm> parameter. The resulting 
          <firstterm>refined boundary</firstterm> will be used instead of the 
          original linear boundary when the height field is constructed, 
          producing a more believable, irregular transition between the regions 
          (<xref linkend="Artifact-free Boundary"/>). The gory details of this 
          operation are described later, in <xref linkend="Boundary GA"/>.  
          Using this operation, the user is enabled to sketch his map using 
          rough, simple shapes, and then to fill in fine-scale boundary detail 
          automatically.  With this paradigm, even an inexperienced user should 
          be able to create a simple but believable map in just a few minutes.
        </para>
        <figure id="Boundary Refinement" float="0">
          <title>The Boundary Refinement Operation</title>
          <mediaobject>
            <caption>
              The boundary refinement operation replaces a long, linear segment 
              of a region boundary with a string of short segments connecting 
              the same endpoints.
            </caption>
            <imageobject>
              <imagedata fileref="Boundary Refinement.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <figure id="Artifact-free Boundary" float="0">
          <title>A Refined Boundary Avoids Unnatural-looking Artifacts</title>
          <mediaobject>
            <caption>
              With long, linear boundaries replaced by irregular, meandering 
              boundaries, such boundary artifacts are no longer evident in the 
              generated height field.
            </caption>
            <imageobject>
              <imagedata scalefit="1" width="4in" fileref="Height Field Without Boundary Artifacts.jpeg"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>

    <section>
      <title>Height Field Construction</title>
      <para>
        Once satisfied with the map he has created, the user selects a 
        rectangular chunk of the map, chooses the desired level of detail, and 
        launches the height field generation algorithm. This third phase of the 
        process is computationally expensive (and therefore, slow), but is also 
        entirely automated: once started, no further input from the user is 
        needed, and he can go on to other tasks.
      </para>
      <para>
        In this phase, <citetitle>Terrainosaurus</citetitle> generates a height 
        field at multiple LODs, beginning from the coarsest possible LOD and 
        continuing up to the target LOD requested by the user.  At each LOD, the 
        height field is built such that the features present in each region 
        resemble those of the corresponding terrain types at that LOD.
      </para>
      <para>
        A secondary, optional by-product of generating each LOD is a rasterized 
        version  of the user's map, an image file with the same raster 
        dimensions as the generated height field, in which each pixel represents 
        the terrain type of the corresponding grid cell in the height field.  
        This information could be loaded and used by another program to do 
        terrain-type-based postprocessing, such as generating a texture map for 
        the height field, or simulating erosion of the terrain surface using 
        terrain-type-specific soil characteristics.
      </para>
    </section>
  </section>

  <section id="The Computer's Perspective">
    <title>The Computer's Perspective (How It Works)</title>
    <para>
      Having covered the fundamental concepts in 
      <citetitle>Terrainosaurus</citetitle> and outlined the general steps of 
      the algorithm, all that remains to be done is to peer inside of the "black 
      boxes" in the above outline, and fill in the details.  In this section, I 
      discuss the following aspects:
      <itemizedlist spacing="compact">
        <listitem>
          the boundary refinement algorithm
        </listitem>
        <listitem>
          height field analysis &amp; comparison
        </listitem>
        <listitem>
          the height field generation algorithm
        </listitem>
      </itemizedlist>
    </para>

    <section id="Boundary GA">
      <title>Boundary Refinement</title>
      <para>
        The boundary refinement operation is the first algorithmic aspect of 
        <citetitle>Terrainosaurus</citetitle> that I discuss, and also the first 
        problem that we solve using a genetic algorithm.
      </para>

      <section id="Boundary GA Overview">
        <title>Overview</title>
        <para>
          The boundary refinement operation is essentially a randomized 
          subdivision operation. It takes as input a single line segment of 
          arbitrary length and produces a piecewise-linear curve with the same 
          starting and ending points as the original segment, but made up of 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/N.mml">
  <mi>N</mi>
</math>

                        </inlineequation> 
          segments (connecting <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/N+1.mml">
  <mi>N</mi>
  <mo>+</mo>
  <mn>1</mn>
</math>

                        </inlineequation> points), where
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/N.mml">
  <mi>N</mi>
</math>

                        </inlineequation> is 
          proportional to the length of the original segment. This curve is then 
          translated, rotated and scaled as needed to line it up with the 
          original boundary's end points. Since we will ultimately be 
          transforming the entire curve anyway, we can, without loss of 
          generality, think of the original boundary as lying along the positive 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>

</inlineequation> 
          axis, starting from the origin. All of the diagrams in this section 
          reflect this convention.
        </para>
        <para>
          A useful result of applying this operation to each boundary in the 
          map is that the segment length throughout the entire map is roughly 
          uniform (recall that <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/N.mml">
  <mi>N</mi>
</math>

</inlineequation>, the number of segments, 
          was said to be proportional to the length of the original boundary).  
          If this length is chosen to be small enough, relative to the 
          resolution of the height field that will be generated, no straight 
          boundaries between terrain types will be evident in the generated 
          height field, nor in any texture maps applied to the height field.
        </para>
        <para>
          The segment length (and thus, the number of segments) may be 
          calculated from the resolution of the target height field, according 
          to the spatial version of the Nyquist limit: considering the height 
          field as sampling the boundary, we know that the height field cannot 
          resolve boundary details finer than half its spatial resolution 
          (<xref linkend="Nyquist Equation"/>).
        </para>
        <equation id="Nyquist Equation">
          <title>The Maximum Segment Length, Set According to the Nyquist 
          Limit</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Boundary%20GA%20-%20Nyquist%20Equation.mml">
  <mi>L</mi>
  <mo>≤</mo>
  <mfrac linethickness="thin">
    <mi>cells</mi>
    <mi>meter</mi>
  </mfrac>
  <mo>×</mo>
  <mn>2</mn>
</math>
        </equation>
        <para>
          However, since the generated boundary may need to be scaled somewhat 
          to match the endpoints of the original boundary, we incorporate a 
          "slop factor" of two, resulting in <xref linkend="Boundary Segment Length Equation"/>.
        </para>
        <equation id="Boundary Segment Length Equation">
          <title>Maximum Boundary Segment Length</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Boundary%20GA%20-%20Segment%20Length%20Equation.mml">
  <mi>L</mi>
  <mo>≤</mo>
  <mfrac linethickness="thin">
    <mi>cells</mi>
    <mi>meter</mi>
  </mfrac>
</math>
        </equation>
        <para>
          The shape of the generated boundary is subject to the constraints 
          imposed by the user. The user can control how sharp the angles between 
          successive segments are allowed to be by adjusting the 
          <firstterm>smoothness</firstterm> parameter,
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/S.mml">
  <mi>S</mi>
</math>

</inlineequation>, which can 
          vary from 0.0 (very rough) to 1.0 (very smooth).
        </para>
      </section>

      <section id="Boundary GA Encoding">
        <title>Genetic Encoding</title>
        <para>
          The first step in casting the boundary refinement problem as a 
          genetic algorithm is to define a suitable genetic encoding for a 
          boundary. In the encoding we selected, a chromosome has
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/N.mml">
  <mi>N</mi>
</math>

                        </inlineequation>
          genes, one for each segment in the resulting boundary, and each gene 
          contains a real-valued angle in the range <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B-pi,pi%5D.mml">
  <mfenced open="[" close="]">
    <mrow>
      <mo>−</mo>
      <mi>π</mi>
    </mrow>
    <mi>π</mi>
  </mfenced>
</math>

                        </inlineequation> indicating the 
          <emphasis>relative</emphasis> change in direction of the corresponding 
          segment with respect to the one preceding it (<xref linkend="Boundary GA Encoding Illustration"/>). A positive angle indicates a turn to the 
          counter-clockwise direction, while a negative angle indicates a turn 
          to the clockwise direction.  A differential angle of zero indicates 
          that the segment is traveling in the same direction as the previous 
          segment. The angle of the first segment is defined with respect to the 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>

</inlineequation> 
          axis, since it has no preceding segment.
        </para>
        <figure id="Boundary GA Encoding Illustration" float="0">
          <title>The Encoding of a Gene in the Boundary GA</title>
          <mediaobject>
            <caption>
              A boundary's genetic encoding is the sequence of relative angles 
              between successive segments. An angle of zero indicates no change 
              in direction.
            </caption>
            <imageobject>
              <imagedata fileref="Boundary GA - Gene Angle Encoding Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          An encoding such as this is advantageous in that it represents the 
          shape of the boundary in terms of a <emphasis>local</emphasis> 
          property of the curve (the differential angle). This is a convenient 
          representation, since the property that we are trying to optimize 
          (the curve smoothness) is itself a local property. Furthermore, the 
          curve smoothness can be calculated using only the angles, without the 
          need to convert to Cartesian coordinates, with the result that the 
          fitness evaluation can be done quite cheaply, in terms of processing 
          time.
        </para>
        <para>
          Another important consequence of this encoding is that the 
          relationship between the gene angle values and the 2D Cartesian 
          points to which they are decoded depends <emphasis>on the entire 
            chromosome</emphasis>: since each angle encoded in a gene is 
          specified relative to the preceding line segment, a change in the 
          angle of one gene will affect the location of not just the next 
          point, but of <emphasis>every</emphasis> subsequent point. As a 
          result, the end point of the boundary cannot easily be held fixed, 
          since mutations earlier in the sequence will tend to move it. This is 
          one reason that we must transform the curve at the end of the 
          algorithm, rather than simply constructing the curve "in place".
        </para>
        <para>
          A downside to this encoding is that it is possible for the boundary 
          to double back on itself, which causes several problems. We prevent 
          this by requiring that the <emphasis>absolute</emphasis> angle (i.e., 
          the angle with respect to the <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>

                        </inlineequation> axis) cannot exceed a 
          certain maximum angle at any point on the boundary (<xref linkend="Boundary GA Angle Limit Illustration"/>).  This is discussed 
          in more detail in <xref linkend="Boundary GA Discussion"/>.
        </para>
        <figure id="Boundary GA Angle Limit Illustration" float="0">
          <title>The Absolute Angle Limit</title>
          <mediaobject>
            <caption>
              A constraint is placed on the maximum absolute angle that a 
              segment can have with respect to the reference axis, in order to 
              prevent the boundary from doubling back and intersecting with 
              itself.
            </caption>
            <imageobject>
              <imagedata fileref="Boundary GA - Angle Limit Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
          
      <section id="Boundary GA Operators">
        <title>Genetic Operators</title>
        <para>
          To mutate and cross-breed the chromosomes, we use the standard GA 
          crossover and mutation operators. Mutating a gene corresponds to 
          changing the degree of "bend" between two consecutive segments (<xref linkend="Boundary GA Mutation Illustration"/>).
        </para>
        <figure id="Boundary GA Mutation Illustration" float="0">
          <title>The Boundary GA Mutation Operator</title>
          <mediaobject>
            <caption>
              Mutation of a boundary segment's gene changes the amount of "bend" 
              between that segment and its predecessor.
            </caption>
            <imageobject>
              <imagedata fileref="Boundary GA - Mutation Operator Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          Crossing two chromosomes is the equivalent of cutting each boundary 
          in the middle of one of the segments and exchanging the pieces (<xref linkend="Boundary GA Crossover Illustration"/>).
        </para>
        <figure id="Boundary GA Crossover Illustration" float="0">
          <title>The Boundary GA Crossover Operator</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Boundary GA - Crossover Operator Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section id="Boundary GA Fitness">
        <title>Fitness Evaluation</title>
        <para>
          A chromosome is "fit" if the boundary curve it represents satisfies 
          the smoothness constraint placed on it. The smoothness of a single 
          gene is calculated according to <xref linkend="Boundary GA Gene Smoothness Equation"/>. When <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/S.mml">
  <mi>S</mi>
</math>

                        </inlineequation> is near 1, this equation is 
          linear, favoring angles near zero and penalizing sharper angles. For 
          lower values of <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/S.mml">
  <mi>S</mi>
</math>

                        </inlineequation>, the equation becomes more 
          sinusoidal, favoring sharper angles (<xref linkend="Boundary GA Gene Smoothness Graph"/>). The constant 1.1 in this equation controls the 
          horizontal offset of the sinusoid's peak, and is somewhat arbitrary.
        </para>
        <equation id="Boundary GA Gene Smoothness Equation">
          <title>Boundary GA Gene Smoothness Equation</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Boundary%20GA%20-%20Smoothness%20Equation.mml">
  <mi>F</mi>
  <mo>=</mo>
  <mo>sin</mo>
  <mfenced>
    <mrow>
      <mfenced>
        <mrow>
          <mi>π</mi>
          <mo>−</mo>
          <mi>α</mi>
        </mrow>
      </mfenced>
      <mo>⁢</mo>
      <mfenced>
        <mrow>
          <mn>1.1</mn>
          <mo>−</mo>
          <mi>S</mi>
        </mrow>
      </mfenced>
    </mrow>
  </mfenced>
</math>
        </equation>
        <figure id="Boundary GA Gene Smoothness Graph" float="0">
          <title>The Smoothness Fitness Function for Several Values of 
          S</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Boundary GA - Smoothness Graph.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          The fitness of the entire chromosome is then calculated as the mean 
          fitness across all of the genes.
        </para>
        
      </section>

      <section id="Boundary GA Decoding">
        <title>Decoding the Result</title>
        <para>
          Once the GA has completed, we have a "best" boundary, encoded as a 
          series of floating-point, relative angle values. The final step in 
          this operation is to decode this chromosome into a series of 2D 
          points (<inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/P_0.mml">
  <msub mathvariant="bold">
    <mi>P</mi>
    <mn>0</mn>
  </msub>
</math>
                        </inlineequation> 
          to <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/P_N.mml">
  <msub mathvariant="bold">
    <mi>P</mi>
    <mi>N</mi>
  </msub>
</math>

</inlineequation>) 
          connecting the end points of the original boundary. This is done in a 
          relatively straightforward manner:
        </para>
        <procedure>
          <step performance="required">
            The initial point <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/P_0.mml">
  <msub mathvariant="bold">
    <mi>P</mi>
    <mn>0</mn>
  </msub>
</math>

</inlineequation> is placed at the origin.
          </step>
          <step performance="required">
            Subsequent points <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/P_1.mml">
  <msub mathvariant="bold">
    <mi>P</mi>
    <mn>1</mn>
  </msub>
</math>
</inlineequation> to 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/P_N.mml">
  <msub mathvariant="bold">
    <mi>P</mi>
    <mi>N</mi>
  </msub>
</math>

                            </inlineequation> are calculated from the 
            previous point, using the recurrence relation <xref linkend="Boundary GA Point Decoding Equation"/>.
            <equation id="Boundary GA Point Decoding Equation">
              <title>Point Decoding Equation</title>
              <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Boundary%20GA%20-%20Point%20Decoding%20Equation.mml">
  <msub mathvariant="bold">
    <mi>P</mi>
    <mi mathvariant="bold-italic">i</mi>
  </msub>
  <mo>=</mo>
  <msub mathvariant="bold">
    <mi>P</mi>
    <mrow>
      <mi mathvariant="bold-italic">i</mi>
      <mo>−</mo>
      <mn>1</mn>
    </mrow>
  </msub>
  <mo>+</mo>
  <mi mathvariant="bold">P</mi>
  <mfenced>
    <mrow>
      <mo>cos</mo>
      <msub>
        <mi>α</mi>
        <mrow>
          <mi>i</mi>
          <mo>−</mo>
          <mn>1</mn>
        </mrow>
      </msub>
    </mrow>
    <mrow>
      <mo>sin</mo>
      <msub>
        <mi>α</mi>
        <mrow>
          <mi>i</mi>
          <mo>−</mo>
          <mn>1</mn>
        </mrow>
      </msub>
    </mrow>
  </mfenced>
</math>
            </equation>
          </step>
          <step performance="required">
            The end points of the generated curve will not, in general, line up 
            with the end points of the original boundary. Therefore, we 
            construct an affine transformation matrix that translates, rotates 
            and scales the points such that the first and last points line up 
            exactly with the start and end points, respectively, of the original 
            boundary.  This transform is constructed in the following way:
            <substeps performance="required">
              <step performance="required">
                Let <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/V_o.mml">
  <msub>
    <mi>V</mi>
    <mi>o</mi>
  </msub>
</math>

                                    </inlineequation> be the vector 
                connecting the start and end points of the original boundary, 
                and <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/V_r.mml">
  <msub>
    <mi>V</mi>
    <mi>r</mi>
  </msub>
</math>

</inlineequation> be similarly 
                defined for the refined boundary.
              </step>
              <step performance="required">
                The transform is the matrix
                <inlineequation>
                  <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Boundary%20GA%20-%20Transform%20Equation.mml">
  <mi mathvariant="double-struck">X</mi>
  <mo>=</mo>
  <mi mathvariant="double-struck">T</mi>
  <mi mathvariant="double-struck">R</mi>
  <mi mathvariant="double-struck">S</mi>
</math>
                </inlineequation>, with:
                <variablelist>
                  <varlistentry>
                    <term>
                      <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/T%20Matrix.mml">
  <mi mathvariant="double-struck">T</mi>
</math>
                      </inlineequation>
                    </term>
                    <listitem>
                      the 2D translation along the vector from the origin to the 
                      start point of the original boundary
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                      <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/R%20Matrix.mml">
  <mi mathvariant="double-struck">R</mi>
</math>
                      </inlineequation>
                    </term>
                    <listitem>
                      the 2D rotation by the angle between 
                      <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/V_o.mml">
  <msub>
    <mi>V</mi>
    <mi>o</mi>
  </msub>
</math>
</inlineequation> and 
                      <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/V_r.mml">
  <msub>
    <mi>V</mi>
    <mi>r</mi>
  </msub>
</math>

</inlineequation>
                    </listitem>
                  </varlistentry>
                  <varlistentry>
                    <term>
                      <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/S%20Matrix.mml">
  <mi mathvariant="double-struck">S</mi>
</math>
                      </inlineequation>
                    </term>
                    <listitem>
                      the 2D scaling by the ratio <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Ratio%20V_o%20to%20V_r.mml">
  <mfrac linethickness="thin">
    <mfenced open="|" close="|">
      <msub>
        <mi>V</mi>
        <mi>o</mi>
      </msub>
    </mfenced>
    <mfenced open="|" close="|">
      <msub>
        <mi>V</mi>
        <mi>r</mi>
      </msub>
    </mfenced>
  </mfrac>
</math>

</inlineequation>                  
                      </listitem>
                  </varlistentry>
                </variablelist>
              </step>
            </substeps>
          </step>
        </procedure>
        <para>
          At this point, the original boundary has been replaced with a 
          suitable, refined version, and the operation is complete.
        </para>
      </section>

    </section>

    <section id="Terrain Library Analysis">
      <title>Terrain Analysis &amp; Comparison</title>
      <para>
        The second algorithmic aspect I discuss is the way in which 
        <citetitle>Terrainosaurus</citetitle> analyzes and compares height 
        fields. The ability to recognize geometric and statistical similarities 
        between height fields is central to 
        <citetitle>Terrainosaurus</citetitle>'s design-by-example paradigm, 
        allowing much of the labor of the terrain construction process to be 
        transferred off of the user and onto the computer.
      </para>

      <section>
        <title>Analyzing a Single Height Field</title>
        <para>
          The ultimate goal of <citetitle>Terrainosaurus</citetitle> is the 
          creation of terrain models that, to a human viewer, are recognizable, 
          plausible reproductions of the kinds of terrain that the user supplied 
          as inputs. Therefore, the central question that must be asked is this: 
          what gives a "kind" of terrain its identity in the mind of the viewer?  
          A comprehensive answer to this question would involve aspects of a 
          number of disciplines, including geology, ecology, linguistics, and 
          human cognition, and is certainly outside of the scope of this 
          research. Nevertheless, for our purposes, we must arrive at a partial 
          answer to this question, one that can be quantified in terms of height 
          field geometry.
        </para>
        <para>
          Intuitively, several ways of characterizing the geometry of a height 
          field seem to be reasonable candidates for terrain type analysis.  
          First, there are the elevations and slopes in the height field (i.e., 
          the zeroth and first derivatives of the height field surface).  
          Everyday experience tells us that different kinds of terrain often 
          have very different elevation ranges and steepnesses; desert terrain, 
          for example, is generally rather flat, while mountainous terrain can 
          be extremely steep, even completely vertical in places.  Furthermore, 
          some kinds of terrain occur at characteristically different altitudes 
          (it would be unusual indeed to find a sandy beach at 10,000 feet of 
          elevation!). Empirical investigation of a number of example terrains 
          indicated that the statistical distributions of elevation and slope 
          tended to be similar between height fields of the same terrain type 
          (<xref linkend="Empirical Analysis"/>).
        </para>
        <para>
          Another way of quantitatively characterizing a height field is by the 
          presence and size of certain identifiable "features": things like 
          peaks, ridges, cliffs, rivers and gorges. Again, experience teaches us 
          to expect mountain ranges to have more pronounced peaks and ridges 
          than most other kinds of terrain, and that plains areas contain 
          primarily smooth, relatively flat ground.  Empirical investigation 
          also indicated that edge statistics tended to be similar within the 
          same terrain type.
        </para>
        <para>
          This list of height field characteristics is by no means exhaustive: a 
          number of other measures seem worthy of future investigation as 
          potential ways of terrain characterization and may ultimately turn out 
          to be more effective for comparing terrains (several possibilities are 
          discussed in <xref linkend="Enhanced Similarity Function"/>).  Even 
          so, the characteristics already mentioned are sufficient starting 
          material for a similarity function.
        </para>
      </section>

      <section>
        <title>Comparing a Height Field to a Reference Terrain Type</title>
        <para>
          Having observed that real-world examples of the same terrain types 
          appear to exhibit similarities in their statistical behavior, we need 
          a way of quantifying this similarity. Conventional statistical 
          hypothesis tests, such as <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/chi%5E2.mml">
  <msup>
    <mi>χ</mi>
    <mn>2</mn>
  </msup>
</math>

                        </inlineequation>, the KS test, and the t 
          test were considered, but ultimately rejected as not adaptable enough.  
          First of all, it is not enough just to test whether the means of two 
          distributions come from the same population: the mean is an ambiguous 
          indicator of terrain type (Gill remarks that the same is true when 
          distinguishing between ice and sea water in SAR imagery <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Ice Cover Discrimination"/>), and also tells us nothing 
          about the shape or roughness of the terrain.  Second, we need to be 
          able to accommodate <emphasis>multiple</emphasis> reference terrain 
          samples; it is not clear how to adapt a KS test, for example, to use 
          multiple reference distributions. Thus, a new kind of test is needed.
        </para>
        <para>
          Towards this end, we introduce the concept of <firstterm>Gaussian 
          curve projection</firstterm>, a technique for comparing unbounded 
          scalar values to determine the <firstterm>similarity</firstterm> of a 
          <firstterm>test value</firstterm> to one or more scalar 
          <firstterm>reference values</firstterm>.  With this as a building 
          block, we define a <firstterm>statistical distribution similarity 
          measure</firstterm> for comparing a test distribution (e.g., of 
          elevation values) to one or more reference distributions.  Finally, we 
          define an <firstterm>aggregate similarity measure</firstterm> 
          combining the distribution similarities to form an estimate of the 
          overall similarity between a height field and one or more reference 
          height fields (i.e., the height fields composing a terrain type).
        </para>

        <section id="Gaussian Curve Projection">
          <title>Gaussian Curve Projection</title>
          <para>
            Gaussian curve projection is a simple means of transforming an 
            arbitrary scalar <firstterm>test value</firstterm> into a bounded 
            <firstterm>similarity measure</firstterm>, given one or more scalar 
            <firstterm>reference values</firstterm> against which to compare the 
            test value.  The test and reference values may be either bounded or 
            unbounded, but the resulting similarity measure is guaranteed to 
            fall in the range <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B0,1%5D.mml">
  <mfenced open="[" close="]">
    <mn>0</mn>
    <mn>1</mn>
  </mfenced>
</math>

</inlineequation>, with values near 
            one indicating "very similar" and values near zero indicating "very 
            dissimilar".
          </para>
          <figure id="Gaussian Curve Projection Overview Diagram" float="0">
            <title>Gaussian Curve Projection</title>
            <mediaobject>
              <caption>
                Gaussian curve projection is a flexible technique for 
                transforming bounded or unbounded values into the 
                <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B0,1%5D.mml">
  <mfenced open="[" close="]">
    <mn>0</mn>
    <mn>1</mn>
  </mfenced>
</math>

</inlineequation> range, by 
                evaluating a Gaussian function (with a suitable mean and 
                standard deviation) at those values.
              </caption>
              <imageobject>
                <imagedata fileref="Terrain Comparison - GCP Overview Diagram.svg"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            This is accomplished by constructing a Gaussian curve based on the 
            reference values, and then finding the projection of the test value 
            onto that curve (<xref linkend="Gaussian Curve Projection Overview Diagram"/>).  The curve has a height of one unit at its peak, has a 
            center value <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/mu_G.mml">
  <msub>
    <mi>μ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> equal to the mean of 
            the reference values, and has a standard deviation 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> chosen 
            "appropriately" (how <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> should be determined 
            is discussed later).  The resulting function (<xref linkend="Gaussian Curve Projection Equation"/>) is capable of 
            handling any scalar value, positive or negative, yields a value of 
            one when evaluated at <inlineequation>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x%20mu_G.mml">
  <mi>x</mi>
  <mo>=</mo>
  <msub>
    <mi>μ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation>, and 
            yields values asymptotically approaching zero as 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>

                            </inlineequation> diverges from 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/mu_G.mml">
  <msub>
    <mi>μ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation>, with the rate of 
            falloff governed by the value of <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>
</inlineequation>.
          </para>
          <equation id="Gaussian Curve Projection Equation">
            <title>Gaussian Curve Projection Equation</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Terrain%20Comparison%20-%20Gaussian%20Curve%20Projection%20Equation.mml">

  <mi>G</mi>
  <mfenced>
    <mi>x</mi>
  </mfenced>
  <mo>=</mo>
  <msup>
    <mi>e</mi>
    <mfrac linethickness="thin">
      <msup>
        <mfenced separators=" ">
          <mrow>
            <mi>x</mi>
            <mo>−</mo>
            <msub>
              <mi>μ</mi>
              <mi>G</mi>
            </msub>
          </mrow>
        </mfenced>
        <mn>2</mn>
      </msup>
      <mrow>
        <mo>−</mo>
        <mn>2</mn>
        <mo>⁢</mo>
        <msubsup>
          <mi>σ</mi>
          <mi>G</mi>
          <mn>2</mn>
        </msubsup>
      </mrow>
    </mfrac>
  </msup>
</math>
          </equation>
          <para>
            The only missing piece in the above formulation is the determination 
            of <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation>, which I have saved 
            for last because it deserves a slightly longer discussion.  This 
            value behaves as a sort of tolerance, controlling how wide a range 
            of values around <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/mu_G.mml">
  <msub>
    <mi>μ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> is considered  
            acceptable.  There is no "one size fits all" formula for setting 
            this parameter; instead, the parameter must be set in a manner 
            appropriate to the context in which Gaussian curve projection is 
            being used. Here are some suggestions for determining 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>
</inlineequation>:
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              If the values being compared are bounded, 
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

</inlineequation> may be chosen as 
              some fraction of the total possible range of values.
            </listitem>
            <listitem>
              If the number of reference values is sufficiently large, then
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

</inlineequation> can be chosen to 
              be the sample standard deviation of the reference values.  This 
              has the drawback that the resulting function will report some of 
              the reference values themselves as having low similarity.  This is 
              likely not what is desired, leading to the next suggestion.
            </listitem>
            <listitem>
              If the number of reference values is sufficiently large, then 
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                                </inlineequation> can be chosen such 
              that all reference values evaluate to a similarity value greater 
              than or equal to some <firstterm>baseline similarity 
              value</firstterm>, <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/G_B.mml">
  <msub>
    <mi>G</mi>
    <mi>B</mi>
  </msub>
</math>
                                </inlineequation> (<xref linkend="Baseline Similarity Sigma Diagram"/>).  Given a choice of 
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/G_B.mml">
  <msub>
    <mi>G</mi>
    <mi>B</mi>
  </msub>
</math>
</inlineequation>, 
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                                </inlineequation> may be determined  
              according to <xref linkend="Baseline Similarity Sigma Equation"/>, 
              which is obtained by rearranging <xref linkend="Gaussian Curve Projection Equation"/>. This guarantees that all reference values 
              will be reported as having high similarity, and results in a 
              larger value of <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

</inlineequation> than would be 
              produced by the previous formulation.
            </listitem>
            <listitem>
              If the number of reference values is too small to derive a 
              meaninful value of <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

</inlineequation>, but there are 
              other, similar sets of reference values for which 
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

</inlineequation> has already 
              been determined, it may be possible to arrive at an acceptable 
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                                </inlineequation> by deriving it 
              from the other <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

</inlineequation>'s (e.g., by taking 
              their mean).
            </listitem>
          </itemizedlist>
          <para>
            These last two suggestions are what 
            <citetitle>Terrainosaurus</citetitle> employs: when a suitably large 
            set of example height fields (more than one) are available for any 
            given terrain type, <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> is calculated using 
            <xref linkend="Baseline Similarity Sigma Equation"/>, with a 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/G_B.mml">
  <msub>
    <mi>G</mi>
    <mi>B</mi>
  </msub>
</math>

                            </inlineequation> of 0.9; otherwise, 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> cannot be determined 
            from the terrain type, and instead, the mean 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> of all the terrain 
            types for which <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>
                            </inlineequation> 
            <emphasis>could</emphasis> be determined is used as a fallback.
          </para>
          <equation id="Baseline Similarity Sigma Equation">
            <title>Baseline Similarity Equation</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Terrain%20Comparison%20-%20Baseline%20Similarity%20Sigma%20Equation.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
  <mo>=</mo>
  <mo>max</mo>
  <msqrt>
    <mfrac linethickness="thin">
      <msup>
        <mfenced>
          <mrow>
            <mi>x</mi>
            <mo>−</mo>
            <msub>
              <mi>μ</mi>
              <mi>G</mi>
            </msub>
          </mrow>
        </mfenced>
        <mn>2</mn>
      </msup>
      <mrow>
        <mo>−</mo>
        <mn>2</mn>
        <mo>⁢</mo>
        <mo mathvariant="italic">ln</mo>
        <mfenced>
          <msub>
            <mi>G</mi>
            <mi>B</mi>
          </msub>
        </mfenced>
      </mrow>
    </mfrac>
  </msqrt>
</math>
          </equation>
          <figure id="Baseline Similarity Sigma Diagram" float="0">
            <title>Determining Sigma G for Multiple 
            Reference Values Using a Baseline Similarity</title>
            <mediaobject>
              <caption>
                When sufficient reference values are available, 
                <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                                    </inlineequation> may be 
                determined by choosing a baseline similarity value, 
                <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/G_B.mml">
  <msub>
    <mi>G</mi>
    <mi>B</mi>
  </msub>
</math>

                                    </inlineequation> (in this 
                example, 0.9), and selecting <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

</inlineequation> such that 
                all reference values project to a similarity value greater 
                than or equal to this baseline value.
              </caption>
              <imageobject>
                <imagedata fileref="Terrain Comparison - GCP Baseline Similarity Sigma Diagram.svg"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>

        <section id="Statistical Distribution Comparison">
          <title>Comparing Statistical Distributions</title>
          <para>
            With this new tool in hand, we can now move on to comparing entire 
            statistical distributions of things (elevations, slopes, etc.). To 
            do this, we define an adaptive <firstterm>distribution similarity 
            measure</firstterm> that compares a test distribution to the 
            reference distributions on the basis of four statistical measures 
            describing the distributions:
            <itemizedlist spacing="compact">
              <listitem>
                the sample mean <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/mu.mml">
  <mi>μ</mi>
</math>
</inlineequation>
              </listitem>
              <listitem>
                the sample standard deviation <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma.mml">
  <mi>σ</mi>
</math>
</inlineequation>
              </listitem>
              <listitem>
                the sample skewness <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/gamma_1.mml">
  <msub>
    <mi>γ</mi>
    <mn>1</mn>
  </msub>
</math>
</inlineequation>
              </listitem>
              <listitem>
                the sample kurtosis excess <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/gamma_2.mml">
  <msub>
    <mi>γ</mi>
    <mn>2</mn>
  </msub>
</math>

</inlineequation>
              </listitem>
            </itemizedlist>
            In each of these statistics, the similarity of the test distribution 
            to the reference distribution(s) is calculated using Gaussian curve 
            projection as defined above. The combined distribution similarity is 
            the weighted average of the resulting four individual similarity 
            measures (<xref linkend="Distribution Similarity Equation"/>).
          </para>
          <equation id="Distribution Similarity Equation">
            <title>Distribution Similarity Equation</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Terrain%20Comparison%20-%20Distribution%20Similarity%20Equation.mml">
  <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mfenced open="{" close="}">
      <mi>μ</mi>
      <mi>σ</mi>
      <msub>
        <mi>γ</mi>
        <mn>1</mn>
      </msub>
      <msub>
        <mi>γ</mi>
        <mn>2</mn>
      </msub>
    </mfenced>
  </mrow>
  <mo>:</mo>
  <msub>
    <mi>S</mi>
    <mi>D</mi>
  </msub>
  <mo>=</mo>
  <munder>
    <mi>∑</mi>
    <mrow>
      <mo>∀</mo>
      <mi>i</mi>
    </mrow>
  </munder>
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
  <mo>⁢</mo>
  <msub>
    <mi>S</mi>
    <mi>i</mi>
  </msub>
</math>
          </equation>
          <para>
            The weights assigned to the four statistics (the 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/w_i.mml">
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
</math>

                            </inlineequation>'s) must sum to 1.0, in 
            order to ensure that the combined distribution similarity measure 
            stays within the <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B0,1%5D.mml">
  <mfenced open="[" close="]">
    <mn>0</mn>
    <mn>1</mn>
  </mfenced>
</math>

                            </inlineequation> range, but they 
            are not, in general, equal. As I alluded to earlier, this 
            distribution similarity measure (<inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/S_D.mml">
  <msub>
    <mi>S</mi>
    <mi>D</mi>
  </msub>
</math>
                            </inlineequation>) is 
            <emphasis>adaptive</emphasis>, giving greater weight to individual 
            statistics (the <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/S_i.mml">
  <msub>
    <mi>S</mi>
    <mi>i</mi>
  </msub>
</math>

                            </inlineequation>'s) in which the 
            reference distributions are more unified and, similarly, giving 
            lesser weight to those in which the reference distributions diverge.  
            To understand the necessity of this adaptability, consider the case 
            where a "hills" terrain type is defined with four example height 
            fields having nearly identical distributions of elevation values, 
            except that each has a significantly different mean elevation from 
            the others (<xref linkend="The Need For Adaptability"/>).
          </para>
          <figure id="The Need For Adaptability" float="0">
            <title>The Need for Adaptability</title>
            <mediaobject>
              <caption>
                Taking as an example the case where four distributions are 
                identical, with the exception of their mean values, the need for 
                an adaptive distribution similarity measure becomes apparent.
              </caption>
              <imageobject>
                <imagedata fileref="Terrain Comparison - The Need for Adaptability.svg"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            In this case, the <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> for the standard 
            deviation, skewness, and kurtosis are all extremely small, while 
            that of the mean elevation is quite large. If, when combining the 
            individual similarity measures to form the distribution similarity 
            measure, we were to assign each measure a uniform weight of 0.25, 
            this would have the undesirable consequence of giving undue merit
            to height fields whose elevation distributions are completely unlike 
            those of the reference height fields but happen to have a mean 
            elevation within the range spanned by the examples. Because the 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> for the mean 
            elevation is large, many height fields will have a mean elevation 
            falling in the "good" zone, and would be rewarded for this with a 
            minimum similarity score of approximately 0.25. As the divergence 
            with respect to mean elevation increases, the 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> grows to embrace 
            more and more of the range of possible values, and the mean becomes 
            less and less of a differentiator (<xref linkend="A Useless Statistical Measure"/>).
          </para>
          <figure id="A Useless Statistical Measure" float="0">
            <title>A Useless Statistical Measure</title>
            <caption>
              As the reference distributions diverge further and further from 
              one another, with respect to any particular statistic, that 
              statistic becomes progressively more worthless for judging the 
              similarity of a height field to that terrain type, because the 
              Gaussian function for the individual statistics's similarity grows 
              too wide to have any significant ability to differentiate.
              </caption>
            <mediaobject>
              <imageobject>
                <imagedata fileref="Terrain Comparison - A Useless Statistical Measure.svg"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            Another way of stating this problem is to say that, as the 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> for a statistic 
            grows in magnitude, that statistic becomes less and less meaningful 
            for answering the question "what gives this terrain type its 
            identity?".  In the extreme case of an enormous 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation>, the statistic is 
            totally worthless (<xref linkend="A Useless Statistical Measure"/>).  
            An obvious solution is to gradually ignore individual statistics as 
            they become less useful: as the reference height fields disagree 
            more strongly on a particular statistic, the 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/sigma_G.mml">
  <msub>
    <mi>σ</mi>
    <mi>G</mi>
  </msub>
</math>

                            </inlineequation> for that statistic 
            increases, and the corresponding <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/w_i.mml">
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
</math>

                            </inlineequation> for that statistic 
            should decrease (with the others increasing proportionately to keep 
            the sum of the <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/w_i.mml">
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
</math>

</inlineequation>'s at 1.0). Thus, for the 
            example above, the mean would be assigned a weight near 0, and the 
            other three statistics would be assigned weights near 0.33.
          </para>
          <para>
            In order to determine appropriate values for the weights, we 
            introduce another measure, the <firstterm>agreement</firstterm>.  
            The agreement describes how successfully a particular statistic 
            unites the reference distributions. We define the agreement as 1 
            minus the ratio of the curve variance to the variance of a Gaussian 
            curve that spans the entire terrain library, or zero, if the 
            variance of that statistic exceeds that of the library as a whole 
            (<xref linkend="Agreement Equation"/>).
          </para>
          <equation id="Agreement Equation">
            <title>Agreement Equation</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Terrain%20Comparison%20-%20Agreement%20Equation.mml">
  <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mfenced open="{" close="}">
      <mi>μ</mi>
      <mi>σ</mi>
      <msub>
        <mi>γ</mi>
        <mn>1</mn>
      </msub>
      <msub>
        <mi>γ</mi>
        <mn>2</mn>
      </msub>
    </mfenced>
  </mrow>
  <mo>:</mo>
  <msub>
    <mi>A</mi>
    <mi>i</mi>
  </msub>
  <mo>=</mo>
  <mo>max</mo>
  <mfenced>
    <mn>0</mn>
    <mrow>
      <mn>1</mn>
      <mo>−</mo>
      <msup>
        <mfenced>
          <mfrac linethickness="thin">
            <mrow>
              <msub>
                <mi>σ</mi>
                <mi>G</mi>
              </msub>
              <mfenced>
                <mi mathvariant="italic">i</mi>
                <mi mathvariant="italic">tt</mi>
              </mfenced>
            </mrow>
            <mrow>
              <msub>
                <mi>σ</mi>
                <mi>G</mi>
              </msub>
              <mfenced>
                <mi mathvariant="italic">i</mi>
                <mi mathvariant="italic">lib</mi>
              </mfenced>
            </mrow>
          </mfrac>
        </mfenced>
        <mn>2</mn>
      </msup>
    </mrow>
  </mfenced>
</math>
          </equation>
          <figure id="Agreement Diagram" float="0">
            <title>Agreement</title>
            <caption>
              The agreement of a terrain type, with respect to an individual 
              statistical measure, is a function of the ratio of that 
              statistic's similarity curve variance to that of a curve spanning 
              the whole library. Statistics that tightly cluster the example 
              height fields (<emphasis>tt1</emphasis>) are more useful and 
              exhibit a higher agreement than those in which the example height 
              fields diverge (<emphasis>tt2</emphasis>).
            </caption>
            <mediaobject>
              <imageobject>
                <imagedata fileref="Terrain Comparison - Agreement Diagram.svg"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            This measure (<xref linkend="Agreement Diagram"/>) gives an idea of 
            how much confidence may be placed in the effectiveness of this 
            statistic, and also gives us a way to set the 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/w_i.mml">
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
</math>
                            </inlineequation>'s in <xref linkend="Distribution Similarity Equation"/>: weights are chosen in 
            proportion to the agreement values, normalized such that they sum to 
            1 (<xref linkend="Distribution Weights Equation"/>).
          </para>
          <equation id="Distribution Weights Equation">
            <title>Distribution Weights Equation</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Terrain%20Comparison%20-%20Distribution%20Weights%20Equation.mml">
  <mi>i</mi>
  <mo>,</mo>
  <mi>j</mi>
  <mo>∈</mo>
  <mfenced open="{" close="}">
    <mi>μ</mi>
    <mi>σ</mi>
    <msub>
      <mi>γ</mi>
      <mn>1</mn>
    </msub>
    <msub>
      <mi>γ</mi>
      <mn>2</mn>
    </msub>
  </mfenced>
  <mo>:</mo>
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="thin">
    <msub>
      <mi>A</mi>
      <mi>i</mi>
    </msub>
    <mrow>
      <munder>
        <mo>∑</mo>
        <mrow>
          <mo>∀</mo>
          <mi>j</mi>
        </mrow>
      </munder>
      <msub>
        <mi>A</mi>
        <mi>j</mi>
      </msub>
    </mrow>
  </mfrac>
</math>
          </equation>
          <para>
            Finally, we define the <firstterm>distribution agreement</firstterm> 
            as the mean of the four individual agreement measures (<xref linkend="Distribution Agreement Equation"/>). This gives an estimate 
            of the measure of significance that the distribution similarity has: 
            if the example height fields are tightly clustered with respect to 
            each of the four individual statistics, the distribution agreement 
            will be very high.  Conversely, if all four statistics are 
            worthless, this value will be near zero.
          </para>
          <equation id="Distribution Agreement Equation">
            <title>Distribution Agreement Equation</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Terrain%20Comparison%20-%20Distribution%20Agreement%20Equation.mml">
  <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mfenced open="{" close="}">
      <mi>μ</mi>
      <mi>σ</mi>
      <msub>
        <mi>γ</mi>
        <mn>1</mn>
      </msub>
      <msub>
        <mi>γ</mi>
        <mn>2</mn>
      </msub>
    </mfenced>
  </mrow>
  <mo>:</mo>
  <msub>
    <mi>A</mi>
    <mi>D</mi>
  </msub>
  <mo>=</mo>
  <munder>
    <mi>∑</mi>
    <mrow>
      <mo>∀</mo>
      <mi>i</mi>
    </mrow>
  </munder>
  <mfrac linethickness="thin">
    <msub>
      <mi>A</mi>
      <mi>i</mi>
    </msub>
    <mn>4</mn>
  </mfrac>
</math>
          </equation>
        </section>

        <section id="Terrain Similarity Evaluation">
          <title>Terrain Similarity Evaluation</title>
          <para>
            Having defined a method of comparing the statistical distribution of  
            a quantity between a single test height field and a set of reference 
            height fields, only a small step further is required to be able to 
            compare entire height fields on the basis of multiple such 
            quantities. We define the <firstterm>terrain type 
            similarity</firstterm> between a test height field and a set of 
            reference height fields to be the weighted average of the 
            distribution similarities for the following quantities (<xref linkend="Terrain Type Similarity Equation"/>):
            <itemizedlist spacing="compact">
              <listitem>elevation</listitem>
              <listitem>slope</listitem>
              <listitem>edge scale</listitem>
              <listitem>edge length</listitem>
              <listitem>edge strength (detector response)</listitem>
            </itemizedlist>
          </para>
          <equation id="Terrain Type Similarity Equation">
            <title>Terrain Type Similarity Equation</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Terrain%20Comparison%20-%20Terrain%20Type%20Similarity%20Equation.mml">
  <mrow>
    <mi>i</mi>
    <mo>∈</mo>
    <mfenced open="{" close="}">
      <mrow>
        <mo>∀</mo>
        <mi>distrib.</mi>
      </mrow>
    </mfenced>
  </mrow>
  <mo>:</mo>
  <msub>
    <mi>S</mi>
    <mi mathvariant="italic">TT</mi>
  </msub>
  <mo>=</mo>
  <munder>
    <mo>∑</mo>
    <mrow>
      <mo>∀</mo>
      <mi>i</mi>
    </mrow>
  </munder>
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
  <mo>⁢</mo>
  <msub>
    <mi>S</mi>
    <mi>i</mi>
  </msub>
</math>
          </equation>
          <para>
            As you might expect, the <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/w_i.mml">
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
</math>

                            </inlineequation>'s are defined to be 
            proportional to the respective distribution agreements, as defined 
            in <xref linkend="Distribution Agreement Equation"/>, normalized 
            such that the <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/w_i.mml">
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
</math>
                            </inlineequation>'s sum to 1 (<xref linkend="Terrain Type Weights Equation"/>).
          </para>
          <equation id="Terrain Type Weights Equation">
            <title>Terrain Type Weights Equation</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Terrain%20Comparison%20-%20Terrain%20Type%20Weights%20Equation.mml">
  <mi>i</mi>
  <mo>,</mo>
  <mi>j</mi>
  <mo>∈</mo>
  <mfenced open="{" close="}">
    <mrow>
      <mo>∀</mo>
      <mi>distrib.</mi>
    </mrow>
  </mfenced>
  <mo>:</mo>
  <msub>
    <mi>w</mi>
    <mi>i</mi>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="thin">
    <msub>
      <mi>A</mi>
      <mi>i</mi>
    </msub>
    <mrow>
      <munder>
        <mo>∑</mo>
        <mrow>
          <mo>∀</mo>
          <mi>j</mi>
        </mrow>
      </munder>
      <msub>
        <mi>A</mi>
        <mi>j</mi>
      </msub>
    </mrow>
  </mfrac>
</math>
          </equation>
          <para>
            Just as the individual statistical agreements were used to attenuate 
            the effect  of a useless statistic, so also the distribution 
            agreements diminish the effect of whole distributions that do not 
            unify the reference height fields. For example, suppose that a 
            terrain type composed of 5 example height fields displays a high 
            degree of unanimity in the statistical distribution of slopes and 
            elevations, but a lesser degree of correspondence in the 
            distribution of edges.  Due to the difference in agreement measures, 
            when evaluating the similarity of a generated height field to the 
            reference terrain type, <citetitle>Terrainosaurus</citetitle> will 
            demand a high degree of conformity with respect to elevation and 
            slope in order to give a high score, but will pay less attention to 
            how the height field matches with respect to the other measures. 
            Thus, characteristics in which the examples for a particular terrain 
            type are strongly united will contribute more to the overall terrain 
            similarity than will characteristics in which they diverge.
          </para>
          <para>
            One advantage to this means of comparing height fields is that it is 
            relatively immune to differences in height field size and shape: 
            because the comparison is made on the basis of statistic 
            characteristics, the height fields may be of differing sizes and 
            shapes...even non-rectangular shapes. For 
            <citetitle>Terrainosaurus</citetitle>, this is crucial, as the 
            terrain regions in the user's map are highly unlikely to be 
            rectangular. However, very small or thin regions are likely to 
            perform less well than larger regions, both because of the smaller 
            sample sizes that they represent, and because the smaller areas that 
            they cover will inhibit the formation of longer features.
          </para>
        </section>

      </section>
    </section>

    <section id="Height Field GA">
      <title>Height Field Construction</title>
      <para>
        The final algorithmic aspect that I discuss in depth is the height field 
        construction step. This also employs a genetic algorithm, but to solve a 
        somewhat harder problem than the boundary refinement problem (<xref linkend="Boundary GA"/>).
      </para>

      <section id="Height Field GA Overview">
        <title>Overview</title>
        <para>
          The height field generation algorithm is, at its heart, a multi-scale 
          image synthesis operation: the goal of this process is a height field 
          (greyscale image) of the requested size and LOD, containing plausible 
          imitations of the examples in the terrain library, arranged according 
          to the user's map. At the beginning of this step, 
          <citetitle>Terrainosaurus</citetitle> has the following inputs from 
          the user (<xref linkend="Height Field GA - Inputs Diagram"/>):
        </para>
        <figure id="Height Field GA - Inputs Diagram" float="0">
          <title>Height Field GA Inputs</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Height Field GA - Inputs Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <itemizedlist spacing="compact">
          <listitem>
            a 2D vector map, expressing the user's desired layout for the height 
            field
          </listitem>
          <listitem>
            a world-space, rectangular "active" chunk of this map, indicating 
            the particular area of the map for which a height field should be 
            generated
          </listitem>
          <listitem>
            the target LOD to generate
          </listitem>
          <listitem>
            a library of terrain samples, serving as examples of what the 
            terrain types referenced by the user's map should look like
          </listitem>
        </itemizedlist>
        <para>
          The height field construction process proceeds in an iterative 
          fashion, starting from the coarsest possible LOD and continuing until 
          the target LOD has been reached. The coarsest LOD is constructed in a 
          naïve fashion, by simply pasting together chunks of elevation data 
          from the appropriate terrain types. Each subsequent LOD is constructed 
          by the genetic algorithm, using the previous LOD as a rough "pattern" 
          to follow.
        </para>
        <para>
          The GA does not attempt to synthesize the height field from scratch; 
          instead, it takes advantage of the fact that we already 
          <emphasis>have</emphasis> realistic data for each terrain type...in 
          the terrain library. Conceptually, the genetic algorithm searches for 
          a way to blend together small chunks of terrain from the library, 
          such that the resulting terrain "makes sense":
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            each region of the height field resembles its corresponding terrain 
            type
          </listitem>
          <listitem>
            the transition between regions at each boundary is smooth, without 
            unrealistic discontinuities
          </listitem>
          <listitem>
            the entire height field has the same macro-scale shape as the 
            previous LOD
          </listitem>
        </itemizedlist>
        <para>
          The necessity of the first two of these constraints should be 
          obvious: we want the terrain to look real. The reason for the third 
          may require some further explanation. Recall that the LOD strategy 
          used by <citetitle>Terrainosaurus</citetitle> is progressive 
          refinement (<xref linkend="Progressive Refinement Methods"/>).  
          During any run of the GA, earlier LODs have already established the 
          macro-scale features of the terrain; the job of the current run of the 
          GA is simply to add new, fine-scale detail, not to re-invent the 
          coarse-scale structure.
        </para>
      </section>

      <section id="Analyzing the Map">
        <title>Analyzing the Map</title>
        <para>
          The map the user created is a vector drawing. This makes a lot of 
          sense from a user-interface standpoint, since we have no way of 
          knowing <foreignphrase>a priori</foreignphrase> what LOD the user will 
          want to generate (the user himself may not know this, and even if he 
          does have a particular LOD in mind, there is no guarantee he won't 
          later decide that he needs a more detailed model). Representing the 
          map with the (virtually) infinite resolution of a vector drawing 
          allows us to defer this decision until the height field is actually 
          generated.
        </para>
        <para>
          However, since the height field we are going to generate is a raster 
          object, it will be much more convenient to have the map in a similar 
          form (i.e., a raster with the same dimensions as the height field).  
          Furthermore, once the height field generation process begins, we 
          <emphasis>do</emphasis> know the resolution of the height field we 
          are to generate, so we can safely convert the map to a raster form, 
          since the additional precision afforded by the vector representation 
          is no longer useful. At the same time, we can do some extra analysis 
          on the rasterized map that will be helpful later on. Specifically, for 
          each grid cell in the rasterized map, the quantities we calculate are:
          <itemizedlist spacing="compact">
            <listitem>
              the terrain type ID
            </listitem>
            <listitem>
              the distance to the nearest region boundary
            </listitem>
            <listitem>
              the unique ID for the enclosing terrain region
            </listitem>
          </itemizedlist>
          The first of these is simply the result of rasterizing the map. The 
          second two are derived from the first, and require segmenting the map 
          back into contiguous regions. It is worth noting that the regions 
          found at this stage may not have a 1-to-1 correspondence with those 
          in the vector-drawn map, for a variety of reasons:
          <itemizedlist spacing="compact">
            <listitem>
              two adjacent regions with the same terrain type are 
              indistinguishable from one another, and will be merged
            </listitem>
            <listitem>
              a region that is too tiny to cover any raster cells, or which 
              falls outside of the active area of the map, will not appear in 
              the rasterized map at all, and will be eliminated
            </listitem>
            <listitem>
              a concave region that only partially intersects the active area 
              of the map may have multiple, distinct fragments that fall within 
              the active area, in which case it will create multiple regions
            </listitem>
          </itemizedlist>
        </para>
      </section>

      <section id="Creating the Initial LOD">
        <title>Creating the Initial LOD</title>
        <para>
          Since the GA requires a "pattern" height field to follow when 
          constructing the next LOD, we cannot begin the generation process 
          without a base LOD with which to prime the GA. Obviously, this base 
          LOD cannot be constructed by the GA, so some other way of creating a 
          height field is needed.
        </para>
        <para>
          An easy way of creating this base height field is to randomly select 
          appropriately shaped chunks of elevation data from the corresponding 
          LODs of the terrain samples in the library. The discontinuities that 
          would otherwise exist at the edges between terrain types can be 
          avoided by making the selected chunks a few pixels wider around the 
          border and blending between chunks where they overlap. This can be 
          done as an image compositing operation, by constructing an 
          appropriately shaped alpha mask with an alpha value of 1 in the 
          region interior, fading to 0 just outside the region boundaries 
          (<xref linkend="Height Field GA Alpha Mask Diagram"/>). 5 pixels of 
          overlap seems to work well.
        </para>
        <figure id="Height Field GA Alpha Mask Diagram" float="0">
          <title>Alpha Mask for Constructing the Base LOD</title>
          <caption>
            The base LOD is not constructed by the GA, but is instead created 
            by combining chunks of raw data of the appropriate sizes and 
            shapes, taken from the terrain library. These chunks are blended 
            together, using an alpha mask with a linear falloff across the 
            boundaries.
          </caption>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Height Field GA - Region Alpha Mask Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Encoding &amp; Decoding a Height Field</title>
        <para>
          Once again, the problem must be expressed in a genetic encoding so 
          that the GA can work on it. In this case, the thing that needs to be 
          transformed into a set of genes is a height field.
        </para>
        <para>
          Perhaps the simplest encoding would be for every pixel in the height 
          field to be its own gene. We rejected this approach as being too 
          fine-grained: a height field of any substantial size would contain 
          thousands or millions of genes, and it is difficult to envision 
          meaningful mutation operators to work on such an encoding.
        </para>
        <para>
          In the encoding we selected, each gene represents a small, 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/NxN.mml">
  <mi>N</mi>
  <mo>×</mo>
  <mi>N</mi>
</math>

                        </inlineequation>-pixel 
          chunk of the height field, and has a terrain type and a 
          transformation associated with it.  A gene does not directly contain 
          the elevation data for its chunk of the height field; instead, it 
          holds a pointer to one of the example terrains for its terrain type, 
          and the <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>

                        </inlineequation> 
          coordinates within that terrain from which to copy its source data.  
          The transformation allows the source data to be rotated, translated 
          and scaled before being blended into their target location (<xref linkend="Height Field GA Encoding Diagram"/>).
        </para>
        <figure id="Height Field GA Encoding Diagram" float="0">
          <title>The Encoding of a Gene in the Height Field GA</title>
          <caption>
          </caption>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Height Field GA - Encoding Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          A chromosome is a 2D grid of such genes, arranged such that each 
          gene overlaps slightly with those on each side of it (<xref linkend="Height Field GA Gene Grid Diagram"/>). To prevent unseemly 
          seams from appearing between adjacent genes, we blend between adjacent 
          genes using a 2D Gaussian blending function.
        </para>
        <figure id="Height Field GA Gene Grid Diagram" float="0">
          <title>The Gene Grid</title>
          <caption>
            A chromosome in the height field GA is a 2D grid of overlapping 
            genes. Each gene has a local area of influence, within which it is 
            responsible for determining elevation values of the height field.  
            In the overlapping areas, two or more genes contribute to the height 
            field elevations, with the areas of influence smoothly blended 
            between them.
          </caption>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Height Field GA - Gene Grid Diagram.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          One benefit of this encoding is that it is relatively compact. By 
          keeping only a <emphasis>reference</emphasis> to the source height 
          field data within the gene, the chromosomes are able to be 
          substantially smaller than they would be if they carried the pixel 
          data internally (a single <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/1024x1024.mml">
  <mn>1024</mn>
  <mo>×</mo>
  <mn>1024</mn>
</math>

</inlineequation> height field stored 
          in IEEE single-precision floating-point format is four megabytes in 
          size!). As a result, memory is not a significant factor in 
          determining the GA population size (instead, processing time is the 
          limiting factor).
        </para>
        <para>
          A second, less obvious benefit is that it is computationally 
          inexpensive. Since the gene transformation is only applied to the 
          pixel data when the chromosome is decoded, mutation operations that 
          only modify the transformation parameters can be very fast.  Also, 
          because no pixel data is stored in the gene, crossover operations are  
          faster as well.  Furthermore, many queries about the geometric 
          characteristics of a gene (mean elevation, gradient, etc.) can be 
          made quite inexpensive by precomputing these quantities for each of 
          the reference terrain samples. Then, to query these properties for a 
          gene, all that needs to be done is to look up the precomputed 
          property for the gene's source data location, accounting for any 
          transformation applied to the data.
        </para>
        <para>
          Another not-so-obvious trait of this encoding is that it is a 
          <emphasis>lossless</emphasis> encoding: it is possible to encode and 
          decode a height field using this scheme, recovering the original 
          height field exactly. It also is relatively robust against numerical 
          drift: the transformation parameters for each gene can be tweaked 
          indefinitely without corrupting the elevation data, since the 
          transformation is only applied when the chromosome is decoded back 
          into a height field, and it is always applied to the original data.
        </para>
      </section>

      <section id="Height Field GA Operators">
        <title>Genetic Operators</title>
        <para>
          With this encoding, a wide variety of genetic operators is possible; 
          virtually any image processing operation is a candidate, though not 
          all operations are equally reasonable. For example, a "vortex" 
          transformation on a gene is not likely to improve the terrain 
          configuration substantially, and in many cases would introduce 
          unrealistic shapes to the generated height field. On the other hand, 
          an image "rotation" transformation corresponds directly to a 
          geometric rotation of the height field surface, and could be quite 
          useful for rearranging the genes.
        </para>
        <para>
          We use a varied set of genetic operators to operate on the 
          chromosomes for the height field GA.
        </para>
        <variablelist>
          <varlistentry>
            <term> Rectangular Region Copy (crossover) </term>
            <listitem>
              This crossover operator exchanges rectangular clusters of 
              corresponding genes (i.e., genes with the same grid indices) 
              between two chromosomes.  The height and width of the copy 
              rectangle are both selected randomly from the range  
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B1,N%5D.mml">
  <mfenced open="[" close="]">
    <mn>1</mn>
    <mi>N</mi>
  </mfenced>
</math>

</inlineequation>, thus, the 
              number of copied genes falls into the range 
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B1,N%5E2%5D.mml">
  <mo>[</mo>
  <mfenced open="" close="">
    <mn>1</mn>
    <msup>
      <mi>N</mi>
      <mn>2</mn>
    </msup>
  </mfenced>
  <mo>]</mo>
</math>

</inlineequation>.  The location 
              of the copy rectangle within the gene grid is randomly selected 
              such that the entire rectangle is within the grid.  This operator 
              corresponds to an image copy operation.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> Vertical Offset (mutation) </term>
            <listitem>
              This mutation operator modifies the vertical offset component of 
              a gene's transformation, effectively altering the mean elevation 
              of the gene. It tends to transform the gene in the direction of 
              the pattern height field's mean elevation in the vicinity of that 
              gene. This operator is similar to an image brightness adjustment 
              operation.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> Vertical Scale (mutation) </term>
            <listitem>
              This mutation operator modifies the vertical scale component of a 
              gene's transformation, changing the elevation range of the gene 
              without altering its mean elevation. It tends to transform the 
              gene towards having the same elevation range as the pattern 
              height field has in the vicinity of the gene. This operator 
              corresponds to linearly stretching or compressing the contrast of 
              an image.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> Rotation (mutation) </term>
            <listitem>
              This mutation operator modifies the rotation component of a 
              gene's transformation, effectively rotating the contents of the 
              gene about the horizontal center point of the gene. It tends to 
              transform the gene toward having the same gradient direction as 
              the pattern height field has in the vicinity of the gene. This 
              operator corresponds directly to an image rotation operation.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> Random Source Data Selection (mutation) </term>
            <listitem>
              This mutation operator completely replaces the source data (i.e., 
              the pointer to the source height field, and the coordinates 
              within that height field) in a gene. The new source height field 
              is randomly chosen from among the examples for the gene's terrain 
              type, and the new source coordinates are randomly chosen from 
              within that example.
            </listitem>
          </varlistentry>

          <varlistentry>
            <term> Horizontal Offset (mutation) </term>
            <listitem>
              This mutation operator modifies the coordinates within the source 
              terrain sample from which the gene takes its data. Like the 
              previous operator, this one has the effect of replacing the 
              gene's contents with new data, but the effect is likely to be 
              less drastic, as it keeps the same source height field and only 
              picks new source coordinates within that height field.
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          I said of several of the mutation operators (those that modify the 
          gene's transformation parameters) that they "tend to" adjust the 
          transformation towards conformity with the pattern height field. This 
          works by introducing a random change to the transformation parameter, 
          drawn from a Gaussian distribution centered over the value that would 
          conform the gene to the pattern (thus, this value has the highest 
          probability of being chosen, but a nearby value may be chosen 
          instead).
        </para>
      </section>

      <section id="Height Field GA Fitness Evaluation">
        <title>Fitness Evaluation</title>
        <para>
          Finally, we come to the crux of the matter: how does the GA discern 
          between good height fields and bad ones? The fitness evaluation is 
          separated into two aspects, and we calculate the overall fitness as a 
          weighted combination of the two (<xref linkend="Height Field Fitness Equation"/>).
        </para>
        <equation id="Height Field Fitness Equation">
          <title>Height Field Fitness Equation</title>
          <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Height%20Field%20GA%20-%20Fitness%20Equation.mml">
  <mrow>
    <mi>F</mi>
    <mo>=</mo>
    <mfenced>
      <mrow>
        <mn>1</mn>
        <mo>−</mo>
        <mi>α</mi>
      </mrow>
    </mfenced>
    ⁢
    <msub>
      <mi>C</mi>
      <mi>g</mi>
    </msub>
    <mo>+</mo>
    <mi>α</mi>
    ⁢
    <msub>
      <mi>S</mi>
      <mi>r</mi>
    </msub>
  </mrow>
</math>
        </equation>
        <variablelist>
          <varlistentry>
            <term>
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/C_g.mml">
  <msub>
    <mi>C</mi>
    <mi>g</mi>
  </msub>
</math>
</inlineequation>
            </term>
            <listitem>
              geometric compatibility
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/S_r.mml">
  <msub>
    <mi>S</mi>
    <mi>r</mi>
  </msub>
</math>
</inlineequation>
            </term>
            <listitem>
              regional terrain type similarity
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Alpha.mml">
  <mi>α</mi>
</math>
</inlineequation>
            </term>
            <listitem>
              a weighting coefficient, controlling how strongly each component 
              affects the overall fitness; 0.5 was found experimentally to be a 
              reasonable value
            </listitem>
          </varlistentry>
        </variablelist>

        <section>
          <title>Geometric Compatibility</title>
          <para>
            <firstterm>Geometric compatibility</firstterm> describes how well 
            the height field encoded in the chromosome matches the "pattern" 
            provided by the previous LOD. This is important for ensuring that 
            the generated LOD is conforming to the macro-scale features 
            constructed by the previous LODs. The compatibility of a chromosome 
            can be estimated directly from the genetic representation, by 
            comparing the mean elevation and the mean gradient over each gene's 
            area of influence with those values for the corresponding areas of 
            the pattern height field.
          </para>
          <para>
            In comparing these geometric properties, we encounter the same 
            difficulty that we did earlier, in our discussion of comparing 
            statistical distributions: we are trying to compare two unbounded 
            quantities, to get a compatibility measure in the bounded range 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B0,1%5D.mml">
  <mfenced open="[" close="]">
    <mn>0</mn>
    <mn>1</mn>
  </mfenced>
</math>

                            </inlineequation>.  We employ the 
            same solution to this problem here as we did to the other instance: 
            a Gaussian curve projection.  In this case, the  curve mean is the 
            value of the pattern height field that we're trying to match, and 
            the curve standard deviation is chosen to be one fourth the range 
            for the gene's terrain type (e.g., for a "mountain" gene, the curve 
            standard deviation would be one fourth of the elevation range for 
            the "mountain" terrain type).  Again, the choice of standard 
            deviation is somewhat arbitrary, but this value seems to work well, 
            allowing a moderate amount of disagreement between a gene and the 
            pattern before the gene starts to be heavily penalized. The total 
            compatibility of a gene is then calculated from <xref linkend="Gene Compatibility Equation"/>.
          </para>
          <equation id="Gene Compatibility Equation">
            <title>Gene Compatibility Equation</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Height%20Field%20GA%20-%20Gene%20Compatibility%20Equation.mml">
  <msub>
    <mi>C</mi>
    <mi mathvariant="italic">g,i</mi>
  </msub>
  <mo>=</mo>
  <mfrac linethickness="thin">
    <mrow>
      <mi>G</mi>
      <mfenced>
        <mrow>
          <msub>
            <mi>E</mi>
            <mi>i</mi>
          </msub>
        </mrow>
      </mfenced>
      <mo>+</mo>
      <mi>G</mi>
      <mfenced>
        <mrow>
          <msub>
            <mi>M</mi>
            <mi>i</mi>
          </msub>
        </mrow>
      </mfenced>
      <mo>+</mo>
      <mi>G</mi>
      <mfenced>
        <mrow>
          <msub>
            <mi>A</mi>
            <mi>i</mi>
          </msub>
        </mrow>
      </mfenced>
    </mrow>
    <mn>3</mn>
  </mfrac>
</math>
          </equation>
          <variablelist>
            <varlistentry>
              <term>
                <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/C_g,i.mml">
  <msub>
    <mi>C</mi>
    <mi mathvariant="italic">g,i</mi>
  </msub>
</math>
</inlineequation>
              </term>
              <listitem>
                overall compatibility for gene <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/i.mml">
  <mi>i</mi>
</math>

</inlineequation>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/E_i.mml">
  <msub>
    <mi>E</mi>
    <mi>i</mi>
  </msub>
</math>
</inlineequation>
              </term>
              <listitem>
                mean elevation over gene <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/i.mml">
  <mi>i</mi>
</math>

</inlineequation>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/M_i.mml">
  <msub>
    <mi>M</mi>
    <mi>i</mi>
  </msub>
</math>
</inlineequation>
              </term>
              <listitem>
                mean gradient magnitude (slope) over gene 
                <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/i.mml">
  <mi>i</mi>
</math>

</inlineequation>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/A_i.mml">
  <msub>
    <mi>A</mi>
    <mi>i</mi>
  </msub>
</math>
</inlineequation>
              </term>
              <listitem>
                mean gradient angle over gene <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/i.mml">
  <mi>i</mi>
</math>

</inlineequation>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>
            The aggregate compatibility of the entire chromosome 
            (<inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/C_g.mml">
  <msub>
    <mi>C</mi>
    <mi>g</mi>
  </msub>
</math>

                            </inlineequation>) is 
            then simply the mean of all of the <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/C_g,i.mml">
  <msub>
    <mi>C</mi>
    <mi mathvariant="italic">g,i</mi>
  </msub>
</math>

</inlineequation>'s.
          </para>
        </section>

        <section>
          <title>Regional Terrain Type Similarity</title>
          <para>
            The second aspect of height field fitness is the regional terrain 
            type similarity: how similar each region is to the examples that 
            make up its corresponding terrain type, in terms of measurable 
            characteristics.
          </para>
          <para>
            The similarity of each individual region is calculated just as 
            described in <xref linkend="Terrain Library Analysis"/>. For the 
            aggregate similarity of the whole height field, however, rather than 
            simply using the arithmetic mean of the individual regional 
            similarities, we instead calculate the area-weighted mean, using the 
            proportion of pixels within each region as the weight for that 
            region's similarity. This reduces the impact that small regions have 
            on the overall fitness of the terrain.
          </para>
        </section>

        <section id="Localized Guidance">
          <title>Localized Guidance of the Genetic Algorithm</title>
          <para>
            As is the case for many things, the GA's great strength can also be 
            a weakness. GAs can solve optimization problems in which the 
            effects of changes are not well understood, precisely because the 
            GA is agnostic about the internal interactions, only evaluating the 
            outcomes. Unfortunately, this also means that a standard GA is 
            rather "dumb": it does not take advantage of domain-specific 
            knowledge that might help guide the GA more quickly in the direction 
            of an optimal solution (or, at least, <emphasis>away</emphasis> from 
            truly horrible solutions).  When the chromosome size is large, the 
            contribution of any individual gene to the overall fitness is highly 
            diluted, thus an "error" in a gene may take a long time to be fixed, 
            and convergence will be slow.
          </para>
          <para>
            To address this, we modify the GA to retain additional information 
            from the fitness evaluation, and we use this information to adjust 
            the probability of a mutation occurring in a gene and also to 
            influence the probability distribution function for choosing which 
            mutation operator is invoked.
          </para>
          <para>
            We do this in several places in the GA. At the region level, we 
            retain the region similarity measure, using it to increase or 
            decrease the mutation probabilities of the genes within that region.  
            Similarly, at the gene level, we retain the individual compatibility 
            components, as well as the overall compatibility measure. The 
            probability of a gene being mutated is calculated using <xref linkend="Height Field GA Mutation Probability Equation"/>:
          </para>
          <equation id="Height Field GA Mutation Probability Equation">
            <title>Gene Mutation Probability</title>
            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/Height%20Field%20GA%20-%20Mutation%20Probability%20Equation.mml">
  <msub>
    <mi>P</mi>
    <mi>i</mi>
  </msub>
  <mo>=</mo>
  <msub>
    <mi>P</mi>
    <mi>m</mi>
  </msub>
  <mo>⁢</mo>
  <mfenced>
    <mrow>
      <mfrac linethickness="thin">
        <mn>1</mn>
        <mn>2</mn>
      </mfrac>
      <mo>+</mo>
      <mfrac linethickness="thin">
        <mrow>
          <mn>1</mn>
          <mo>−</mo>
          <msub>
            <mi>S</mi>
            <mi>r</mi>
          </msub>
        </mrow>
        <mn>4</mn>
      </mfrac>
      <mo>+</mo>
      <mfrac linethickness="thin">
        <mrow>
          <mn>1</mn>
          <mo>−</mo>
          <msub>
            <mi>C</mi>
            <mi mathvariant="italic">g,i</mi>
          </msub>
        </mrow>
        <mn>4</mn>
      </mfrac>
    </mrow>
  </mfenced>
</math>
          </equation>
          <para>
            where <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/P_m.mml">
  <msub>
    <mi>P</mi>
    <mi>m</mi>
  </msub>
</math>

</inlineequation> 
            is the baseline probability of mutation.  With this formulation, 
            the baseline mutation probability still has a strong effect, but 
            genes in highly dissimilar regions and genes that are highly 
            incompatible with the underlying pattern are substantially more 
            likely to be mutated.
          </para>
          <para>
            Once the GA decides to mutate a particular gene, it still has to 
            choose which mutation operator it will apply. An attractive feature 
            of this enhancement to the GA is that smart and dumb mutation 
            operators may be freely intermixed. A <firstterm>smart</firstterm> 
            mutation operator is one that has a predictable relationship to 
            some component of the fitness evaluation (e.g., 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/E_i.mml">
  <msub>
    <mi>E</mi>
    <mi>i</mi>
  </msub>
</math>

                            </inlineequation>, the 
            mean elevation of a gene, is directly affected by the "vertical 
            offset" operator).  In contrast, a <firstterm>dumb</firstterm> 
            genetic operator produces unpredictable effects, or else cannot 
            easily be related to any part of the fitness evaluation (e.g., the 
            "pick new source location" operator). When deciding which operator 
            to use, the GA modifies the mutation operator probability 
            distribution function (PDF), giving higher probabilities to smart 
            operators that are needed by the current gene and lower 
            probabilities to smart operators that are not.  Probabilities for 
            dumb operators remain fixed.
          </para>
          <para>
            One way to understand these changes to the GA is as additional, 
            tighter feedback loops within the GA, essentially creating several 
            child GAs within the height field generation GA, who are better 
            equipped to handle particular aspects of the problem. One point 
            that deserves to be mentioned is that, despite incorporating this 
            additional guidance, the algorithm is still a 
            <emphasis>probabilistic</emphasis> algorithm, not a deterministic 
            one. While a speedier convergence rate is generally a good thing, we 
            want to retain the randomness and diversity of the GA, so as not to 
            lose the ability to escape local maxima in the solution space (i.e., 
            terrains that are "OK" but not "great").
          </para>
        </section>

        <section>
          <title>Cleaning Up the Final Result</title>
          <para>
            A final improvement we can make concerns those few genes that are 
            out-of-place at the end of the GA. Given enough evolution cycles, 
            the GA is generally successful at bringing 
            <emphasis>most</emphasis> of the genes into alignment, however, 
            since it is a probabilistic algorithm, it is not unlikely that a 
            handful of genes out of the dozens (or hundreds) in the chromosome 
            might escape being brought into conformity with the rest. Such 
            genes are especially noticeable if they have a substantially 
            different elevation from the surrounding terrain; they look sort of  
            like squarish "fingers" poking up from the ground (<xref linkend="Terrain Fingers"/>).
          </para>
          <figure id="Terrain Fingers" float="0">
            <title>Unaligned Genes Look Like "Fingers"</title>
            <mediaobject>
              <imageobject>
                <imagedata scalefit="1" width="4in" fileref="Terrain Fingers.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>
            These remaining artifacts can be removed by applying a 
            <firstterm>conform</firstterm> operator to these aberrant genes.  
            The conform operator simply sets the gene's transformation 
            parameters so as to give the gene a compatibility value
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/C_g,i.mml">
  <msub>
    <mi>C</mi>
    <mi mathvariant="italic">g,i</mi>
  </msub>
</math>

</inlineequation> of 1; in effect, it 
            forces the gene to fit the pattern height field as closely as 
            possible.
          </para>
        </section>
      </section>
    </section>

  </section>
</chapter>
  <chapter id="Implementation" xml:base="implementation.xml">
  <title>Implementation</title>
  <para>
    In this chapter, I discuss some of the architectural features of the 
    prototype implementation of <citetitle>Terrainosaurus</citetitle>, covering  
    some of the more significant design decisions that were made and how some of 
    the technical challenges were dealt with. In so doing, I hope to save other 
    developers some of the difficulties I encountered during this research.
  </para>
  <para>
    In this chapter, I present the following topics:
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      the choice of development platform and technologies used
    </listitem>
    <listitem>
      a discussion of the application architecture
    </listitem>
    <listitem>
      suggested optimizations and simplifications
    </listitem>
  </itemizedlist>

  <section>
    <title>Technologies</title>
    <para>
      The <citetitle>Terrainosaurus</citetitle> algorithm could be implemented 
      using any number of programming languages and libraries, both commercial 
      and free, proprietary and open-source.  While these decisions are 
      ultimately up to the programmer(s) implementing the algorithm, it may be 
      productive to consider the decisions made in the design of the current 
      implementation, and the reasons for them.
    </para>

    <section>
      <title>Development Platform</title>
      <para>
        The current implementation of <citetitle>Terrainosaurus</citetitle> was 
        developed in C++, with heavy reliance on the Standard Template Library 
        (STL) and a number of the Boost libraries. C++ was selected for a number 
        of reasons, including the following:
        <itemizedlist spacing="compact">
          <listitem>
            C++ is a multi-paradigm programming language, allowing the developer  
            a great deal of freedom in selecting the best approach to a 
            particular problem. Object-oriented techniques, for example, are 
            well-suited to implementing user interfaces, whereas generic 
            programming techniques are appropriate for low-level utilities and 
            complex algorithms.
          </listitem>
          <listitem>
            C++ gives the programmer a great deal of freedom in managing 
            resources (such as memory), and typically does not incur the cost 
            of compiler-generated run-time checks, meaning that a carefully 
            written program can be very fast. Languages such as C# and Java 
            provide nice additional features (run-time array bounds checking, 
            garbage collection, etc.), but these come at the cost of run-time 
            performance; thus, a well-written C++ program will always be faster 
            than an equivalent program in C# or Java. Of course, the risk of 
            foregoing these features is that bugs may be harder to track down, 
            and as a result, it may take longer to develop the application.
          </listitem>
          <listitem>
            Good compilers for C++ exist for all major computing platforms, such 
            as Microsoft's compiler for the Win32 platform and GCC for the many 
            UNIX variant platforms.
          </listitem>
          <listitem>
            Third-party libraries, of both the commercial and free varieties, 
            are widely available for C++, solving a diverse spectrum of 
            problems.
          </listitem>
        </itemizedlist>
      </para>
      <para>
        Another means of implementing <citetitle>Terrainosaurus</citetitle> that 
        was considered is as an extension to a general-purpose numeric 
        processing application, such as <citetitle>Matlab</citetitle> or its 
        free cousin, <citetitle>Octave</citetitle>.  These programs provide 
        native implementations of mathematical constructs such  as vectors and 
        matrices, have a (limited) graphical user interface, and have an 
        impressive array of add-on "toolboxes" providing additional 
        functionality, including statistical analysis, image processing, and 
        pattern analysis. Because <citetitle>Matlab</citetitle> is an 
        interpreted language it is especially useful for rapid prototyping of 
        algorithms.
      </para>
      <para>
        Although it was considered, <citetitle>Matlab</citetitle> was ultimately 
        rejected as a development platform, for two main reasons.
        <orderedlist spacing="compact" inheritnum="ignore" continuation="restarts">
          <listitem>
            <citetitle>Matlab</citetitle> is a commercial product; if 
            implemented as a <citetitle>Matlab</citetitle> toolbox, 
            <citetitle>Terrainosaurus</citetitle> would only be usable by 
            persons having access to a copy of <citetitle>Matlab</citetitle>. A 
            person interested in modeling terrain is not especially likely to be 
            a <citetitle>Matlab</citetitle> user.
          </listitem>
          <listitem>
            <citetitle>Matlab</citetitle>'s programming language does not 
            provide sufficient facilities for modularization, type safety, and 
            code reuse to make development of a medium- to large-scale 
            application feasible.
          </listitem>
        </orderedlist>
      </para>
    </section>

    <section>
      <title>Graphics API</title>
      <para>
        <citetitle>OpenGL</citetitle> was chosen as the 3D rendering API, 
        because of its cross-platform availability and familiarity.  Another 
        immediate-mode rendering API (e.g., <citetitle>Direct3D</citetitle>) 
        could have been used equivalently.
      </para>
      <para>
        Another possibility for displaying the results is to implement an 
        interface to one of the commercially available modeling and rendering  
        systems (e.g., <citetitle>Maya</citetitle>, <citetitle>3D 
          Studio</citetitle>).  Then, rather than being rendered directly, the 
        results would be used to instantiate objects in the modeling system's 
        scene graph. In this way, one could get high-quality rendering support 
        "for free".
      </para>
    </section>
  </section>

  <section>
    <title>Supporting Libraries</title>
    <para>
      While almost any needed functionality could, in principle, be implemented 
      directly in C++, this is wasted effort when there already exist mature, 
      freely available C/C++ libraries and tools providing good solutions for 
      these problems. In order to simplify the development process, a 
      third-party library was used wherever possible, as long as the following 
      things were true of it:
      <orderedlist spacing="compact" inheritnum="ignore" continuation="restarts">
        <listitem>
          The library is fairly mature, providing a robust, full-featured 
          solution to the problem domain it addresses. Incomplete and 
          alpha-quality libraries are not desirable.
        </listitem>
        <listitem>
          The library has adequate documentation, and is under active 
          development/maintenance. This gives some degree of confidence that 
          the developers of the library are committed to its continued 
          existence and improvement.
        </listitem>
        <listitem>
          The library is cross-platform, and does not have dependencies on 
          proprietary libraries. This keeps 
          <citetitle>Terrainosaurus</citetitle> from being bound to a particular 
          operating system variant.
        </listitem>
        <listitem>
          The library is distributed under fairly liberal licensing terms. A 
          "do (mostly) whatever you want" style license, such as the Apache 
          License or the LGPL is preferable, but a GPL'd library  was considered 
          acceptable if it is also available under a commercial license. This 
          leaves open the possibility of future commercial development.
        </listitem>
      </orderedlist>
    </para>

    <section>
      <title>File Parsing</title>
      <para>
        For small-scale projects, it may be sufficient to hard-code 
        configuration constants and algorithm parameters directly into the 
        source code. An application of any significant size and complexity, 
        though, generally needs to be able to accept configurable parameters 
        from data files (and ideally, in a robust way, so that a malformed data 
        file does not cause the application to crash). Besides adding to the 
        overall quality of the application, having the ability to read 
        configurable parameters from a file can also drastically cut down on the 
        amount of time needed to tune a complex algorithm, by eliminating the 
        edit/compile/run cycle.
      </para>
      <para>
        Writing robust file parsing code can be both difficult and tedious, so 
        some sort of higher-level solution is desirable.  
        <citetitle>ANTLR</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="ANTLR"/> is one such 
        tool, allowing a developer to write a description of the grammar for his 
        file format and generating Java, C#, C++, or Python code for parsing 
        files in that format. The generated code is human readable (unlike that 
        produced by other tools like yacc), and generates fairly good error 
        messages for  malformed files.  Once familiar with 
        <citetitle>ANTLR</citetitle>, a developer can modify or extend the 
        format of the file with very little effort.
      </para>
    </section>

    <section>
      <title>Fourier Transform</title>
      <para>
        Frequency-domain signal analysis generally implies calculating the 
        discrete Fourier transform (DFT) of a spatial-domain or time-domain 
        signal (this is needed in <citetitle>Terrainosaurus</citetitle> for 
        speeding up the feature detection step, as described in <xref linkend="Frequency Domain Convolution"/>).  However, writing an 
        efficient discrete Fourier transform (DFT) implementation is tricky 
        indeed—a research area in its own right.
        Fortunately, a very complete and highly optimized C library exists for 
        performing many variations on the DFT, called 
        <citetitle>FFTW</citetitle> (the "Fastest Fourier Transform in the 
        West") <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="FFTW"/>.  <citetitle>FFTW</citetitle> is 
        available from the Massachusetts Institute of Technology under both the 
        GPL and a commercial license.
      </para>
    </section>
  </section>

  <section>
    <title>Application Architecture</title>
    <para>
      A suggested general architecture for an implementation of 
      <citetitle>Terrainosaurus</citetitle> is pictured in <xref linkend="Implementation - Architecture Overview Diagram"/>. To a large 
      degree, this is a straightforward reflection of the concepts described in 
      <xref linkend="Methods"/>.
    </para>
    <para>
      In this section, I discuss the following aspects of this suggested 
      architecture in greater depth:
      <itemizedlist spacing="compact">
        <listitem>how LOD is expressed in the architecture</listitem>
        <listitem>inputs and outputs of the algorithm</listitem>
        <listitem>the data structures</listitem>
        <listitem>the user interface</listitem>
        <listitem>implementing the genetic algorithms</listitem>
      </itemizedlist>
    </para>
    <figure id="Implementation - Architecture Overview Diagram" float="0">
      <title>A Suggested Application Architecture</title>
      <mediaobject>
        <imageobject>
          <imagedata fileref="Implementation - Architecture Overview.svg"/>
        </imageobject>
      </mediaobject>
    </figure>

    <section>
      <title>LOD Handling</title>
      <para>
        <firstterm>Level of detail</firstterm> is a concept fundamental to 
        <citetitle>Terrainosaurus</citetitle>, and is important for a number of 
        things. As discussed in <xref linkend="Methods"/>, LOD is central to the 
        height field generation algorithm: starting from a coarse LOD, the 
        algorithm builds progressively finer-scale height fields, until reaching 
        the user's desired LOD. In each iteration, the algorithm uses real-world 
        elevation data of that LOD, either taken directly from GIS data 
        available at that LOD, or else resampled from GIS data at a different 
        LOD. LOD is also important in other, less obvious ways. For example, the 
        desired LOD tells us how finely the map boundaries must be subdivided in 
        order for there not to be any straight boundaries in the resulting 
        height field. Also, when rendering a height field, it is necessary to 
        know the LOD: this specifies how to scale the 
        <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>
                    </inlineequation> 
        and <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/y.mml">
  <mi>y</mi>
</math>

</inlineequation> dimensions of the height field 
        in order to be in correct proportion to the vertical axis.
      </para>
      <para>
        Because we are working with USGS elevation data, the choice of LODs 
        has already been made for us, to a large degree. USGS DEMs are 
        commonly available in resolutions of 1/9 arc-second (3 1/3 meters per 
        sample), 1/3 arc-second (10 meters per sample) and 1 arc-second (30 
        meters per sample). Because of this, a power-of-three relationship 
        between LODs is most convenient, as it requires the least amount of 
        resampling, because the standard-resolution DEMs can be used directly.  
        Following this power-of-three relationship, coarser LODs can be derived 
        with resolutions of 90m, 270m, 810m (<xref linkend="Implementation - LOD Breakdown Chart"/>).  Further resolutions, such as 2.4km and 
          coarser, are less useful because standard USGS 10m and 30m DEMs become 
          unusably small when resampled to such coarse resolutions (around 4x4 
          samples).
      </para>
      <figure id="Implementation - LOD Breakdown Chart" float="0">
        <title>Choice of Levels of Detail</title>
        <caption>
          USGS digital elevation maps come in a range of LODs, with a 
          power-of-three relationship between successive resolutions.  This 
          scheme can be extended to include additional resolutions for which 
          data is not typically available (in these cases, the 
          standard-resolution maps must be resampled).
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Implementation - LOD Breakdown Chart.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        Because LOD is so ubiquitous throughout 
        <citetitle>Terrainosaurus</citetitle>, it is natural that its data 
        structures would directly support multiple levels of detail. The 
        diagrams in this chapter depict the multi-LOD components of the data 
        structures as in <xref linkend="Implementation - Multi-LOD Object Diagram"/>.
      </para>
      <figure id="Implementation - Multi-LOD Object Diagram" float="0">
        <title>Multi-LOD Objects</title>
        <caption>
          Most of the data structures suggested for 
          <citetitle>Terrainosaurus</citetitle> have at least some attributes 
          that are LOD-specific.
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Implementation - Multi-LOD Object.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Inputs &amp; Outputs</title>
      <para>
        <xref linkend="Implementation - Architecture Overview Diagram"/> depicts 
        the inputs and outputs of an implementation of 
        <citetitle>Terrainosaurus</citetitle>.  Assuming that 
        <citetitle>Terrainosaurus</citetitle> is not embedded in the context of 
        a larger application, this generally implies that 
        <citetitle>Terrainosaurus</citetitle> is reading/writing files from/to 
        machine storage (e.g., the computer's hard drive).
      </para>
      <para>
        The input and output files include:
        <itemizedlist spacing="compact">
          <listitem>
            the terrain type library (TTL) file—this describes the user's 
            classification of example height fields into a taxonomy of terrain 
            types and is read to determine what elevation map files should be 
            loaded (see <xref linkend="TTL Example Listing"/> in <xref linkend="Data Structure - Terrain Library"/> for a suggested format 
            for this file)
          </listitem>
          <listitem>
            terrain type map (MAP) files—these contain the map designs 
            authored by the user, and are both read and written by 
            <citetitle>Terrainosaurus</citetitle> (see <xref linkend="MAP Example Listing"/> in <xref linkend="Data Structure - Map"/> for a 
            suggested format for these files)
          </listitem>
          <listitem>
            digital elevation map (DEM) files—these contain height field 
            elevation data, and are read to load the example height fields, and  
            written to save the height fields generated by 
            <citetitle>Terrainosaurus</citetitle> (see <xref linkend="Data Structure - Terrain Sample"/> for a discussion of file formats for 
            height fields)
          </listitem>
          <listitem>
            image (IMG) files—these encode the terrain type of each point in 
            a height field as a pixel color and are generated as a by-product of 
            the map-rasterization process; they may be used for 
            terrain-type-based postprocessing of the generated height fields
          </listitem>
        </itemizedlist>
      </para>
    </section>

    <section>
      <title>Suggested Data Structures</title>
      <para>
        The way in which data is organized is of great importance in the design 
        of most kinds of software. A poorly structured data model will adversely 
        impact the design of the rest of the system and may be difficult to 
        change once the rest of the system has been built. As an aid to future 
        implementors, I offer the following suggested organization of data 
        structures.
      </para>

      <section id="Data Structure - Terrain Library">
        <title>Terrain Library</title>
        <figure id="Terrain Library Diagram" float="0">
          <title>The Terrain Library Data Structure</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Implementation - Terrain Library.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          The Terrain Library structure 
          (<xref linkend="Terrain Library Diagram"/>) is primarily a container 
          for the other data structures, but it also holds aggregate statistics 
          for the entire library of height fields. The important components of 
          the Terrain Library are:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            a set of Terrain Type objects representing the various types of 
            terrain defined by the user
          </listitem>
          <listitem>
            a set of Terrain Seam objects representing the properties of the 
            seams between each possible pair of Terrain Types
          </listitem>
          <listitem>
            terrain statistics aggregated from all of the Terrain Samples in the 
            library; these are used to establish the significance of the 
            agreement between the Terrain Samples of a Terrain Type
          </listitem>
          <listitem>
            similarity parameters aggregated from all of the Terrain Types in 
            the library; these are used as a fallback when a Terrain Type does 
            not have enough Terrain Samples to calculate its own similarity 
            parameters
          </listitem>
        </itemizedlist>
        <para>
          Because the Terrain Library, once constructed, is essentially static, 
          it makes sense to store this information in a file, and to load it at 
          application startup. A simple way to accomplish this is with a file 
          format resembling the Windows .ini format, essentially a 
          human-readable list of key/value pairs grouped into sections (<xref linkend="TTL Example Listing"/>).
        </para>
        <figure id="TTL Example Listing" float="0">
          <title>An Example Terrain Type Library (.ttl) File</title>
          <programlisting format="linespecific">
# A Terrain Type entry
[Terrain Type: California_Coast_Hills]
  color = &lt;0.6, 0.6, 0.3, 1.0&gt;
  sample = "35120e8 - Cypress Mountain, CA"
  sample = "35120f8 - Lime Mountain, CA"
  sample = "35121f1 - Pebblestone Shut-in, CA"
  sample = "33116b7 - Mesa Grande, CA"
.
.
# A Terrain Seam entry
[Terrain Seam: Colorado_Small_Mountains &amp; Colorado_Large_Mountains]
  smoothness = 0.3
.
.
# Terrain statistics aggregated across the whole library for an LOD
[Aggregate: LOD_30m]

  # Whole-library variances, used to calculate agreement
  elevation_mean_variance     = 8.18938e+008f
  elevation_stddev_variance   = 2.14651e+006f
  elevation_skewness_variance = 11.5058f
  elevation_kurtosis_variance = 85.087f
.
.
  # Whole-library averages, used when a terrain type has
  # insufficient samples to calculate its own values
  default_elevation_mean_variance     = 2.48967e+006f
  default_elevation_stddev_variance   = 68969.8f
  default_elevation_skewness_variance = 1.74482f
  default_elevation_kurtosis_variance = 4.5054f
.
.
          </programlisting>
        </figure>
      </section>

      <section id="Data Structure - Terrain Type">
        <title>Terrain Type</title>
        <figure id="Terrain Type Diagram" float="0">
          <title>The Terrain Type Data Structure</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Implementation - Terrain Type.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          A Terrain Type (<xref linkend="Terrain Type Diagram"/>) represents a 
          single, conceptual type of terrain, having one or more concrete 
          examples. Its important components are:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            a name, describing the terrain type in a way that is meaningful to 
            the user (e.g., "Mountains")
          </listitem>
          <listitem>
            an integer ID, uniquely identifying this Terrain Type within the 
            parent Terrain Library; this ID is used by other data structures to 
            reference this Terrain Type
          </listitem>
          <listitem>
            a set of Terrain Sample objects, the example terrains that make up 
            this Terrain Type
          </listitem>
          <listitem>
            terrain statistics aggregated from all the Terrain Samples belonging 
            to this Terrain Type; these are used to calculate the similarity 
            parameters used when measuring how "like" this Terrain Type a 
            generated height field is
          </listitem>
        </itemizedlist>
      </section>

      <section id="Data Structure - Terrain Sample">
        <title>Terrain Sample</title>
        <figure id="Terrain Sample Diagram" float="0">
          <title>The Terrain Sample Data Structure</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Implementation - Terrain Sample.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          The Terrain Sample class (<xref linkend="Terrain Sample Diagram"/>) 
          represents a single, rectangular chunk of terrain, and can be thought 
          of as an enhanced height field. It serves two similar, but distinct 
          functions:
        </para>
        <orderedlist spacing="compact" inheritnum="ignore" continuation="restarts">
          <listitem>
            it represents the example GIS terrains within the Terrain Library, 
            in which case it has a parent Terrain Type
          </listitem>
          <listitem>
            it represents the under-construction terrains, in which case it has 
            a Map Rasterization and does <emphasis>not</emphasis> have a parent 
            Terrain Type
          </listitem>
        </orderedlist>
        <para>
          The important components of a Terrain Sample are:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            if this is an example terrain in the terrain library, a reference to 
            the parent Terrain Type
          </listitem>
          <listitem>
            if this is a height field being generated by 
            <citetitle>Terrainosaurus</citetitle>, a reference to a Map 
            Rasterization describing where the terrain regions are located and 
            what the terrain type is at each point in the height field
          </listitem>
          <listitem>
            a rectangular grid of height field elevations (pictured above in 
            yellow)
          </listitem>
          <listitem>
            a rectangular grid of 2D vectors representing the gradient at each 
            point in the height field (pictured above in green)
          </listitem>
          <listitem>
            lists of features (peaks, edges, ridges, etc.) located within the 
            height field; each feature contains one or more 4-dimensional 
            points, giving the <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>

</inlineequation> location within the 
            height  field, the scale at which the detector gave the strongest 
            response, and the value of that detector response
          </listitem>
          <listitem>
            calculated statistics for each region in the height field (encoded 
            in the associated Map Rasterization); these statistics need to be 
            evaluated separately for each region because each region must be 
            evaluated against its corresponding Terrain Type
          </listitem>
          <listitem>
            raster objects containing windowed statistical measurements of the 
            Terrain Sample, such as the mean elevation, mean gradient and 
            minimum/maximum elevation, calculated over the 
            <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/NxN.mml">
  <mi>N</mi>
  <mo>×</mo>
  <mi>N</mi>
</math>

</inlineequation> neighborhood surrounding 
            each cell of the raster; these are precalculated when the Terrain 
            Sample is studied, and are during the height field construction GA 
            to perform efficient queries of the geometry of individual genes
            (pictured above in blue)
          </listitem>
        </itemizedlist>
        <para>
          The vast majority of the data processed by 
          <citetitle>Terrainosaurus</citetitle> comes from terrain elevation 
          maps. Height field data are commonly found in either the DEM (Digital 
          Elevation Map) format <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="DEM Specification"/> or the 
          SDTS (Spatial Data Transfer Standard) format <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="SDTS Specification"/>, with newer data available only in the SDTS format. 
          The DEM format is an ASCII text format with fixed-length records, a 
          relatively simple format, but also rather bulky—a typical 30m DEM 
          is larger than a megabyte. SDTS, in contrast, is a binary file format, 
          and is much more compact, but also much more complicated, as SDTS is 
          the USGS's "Swiss Army Knife" format, capable of storing a wide range 
          of raster and vector map data.
        </para>
        <para>
          While the preceding discussion may sound disheartening, the 
          developer of terrain processing software actually has quite a bit of 
          latitude in selecting a terrain file format. This is because, while 
          GIS data sources typically use only the aforementioned formats, there 
          exist public-domain utilities for converting between these formats 
          and a wide array of raster formats, including TIFF, Targa, raw XYZ 
          coordinates, POV (the <citetitle>POV-Ray</citetitle> ray tracer file 
          format), and <citetitle>AutoCAD</citetitle> DXF. The 
          <citetitle>Virtual Terrain Project</citetitle> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="VTP"/> also describes an additional, terrain-specific format, 
          the Binary Terrain (BT) format, which also offers better compression 
          than ASCII formats.
        </para>
        <para>
          In the current implementation of 
          <citetitle>Terrainosaurus</citetitle>, we chose to implement a parser 
          for the DEM format, because DEM is easy to read and because PC 
          environments typically have plenty of hard drive space, so the data 
          expansion is not a huge problem.  Image file formats are not ideal for 
          storing terrain data because, in order to  encode a height field into 
          such a format, the elevations must be scaled to fit within the range 
          of legal pixel values (often <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B0,1%5D.mml">
  <mfenced open="[" close="]">
    <mn>0</mn>
    <mn>1</mn>
  </mfenced>
</math>
                        </inlineequation> or 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B0,255%5D.mml">
  <mfenced open="[" close="]">
    <mn>0</mn>
    <mn>255</mn>
  </mfenced>
</math>

</inlineequation>; doing so loses 
          the absolute scale of the data, and makes it impossible to compare 
          elevations between different height fields.
        </para>
        <para>
          One important "gotcha" to be wary of, when using DEM or SDTS data, is 
          that the real-world tiles covered by the data in an elevation map are 
	  often non-rectangular, due to the curvature of the Earth (<xref linkend="Geodetic Mapping"/>). As a result, the actual, valid region 
          of a DEM or SDTS height field may be a trapezoid (or even an arbitrary 
          quadrilateral, depending on the mapping coordinate system used); grid 
          cells outside of this valid region will be marked "void".  A simple 
          solution for dealing with this is to trim some number of pixels off of 
          each edge (30 pixels seems to be sufficient), thereby ensuring a 
          rectangular valid region.
        </para>
        
      </section>

      <section id="Data Structure - Terrain Seam">
        <title>Terrain Seam</title>
        <figure id="Terrain Seam Diagram" float="0">
          <title>The Terrain Seam Data Structure</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Implementation - Terrain Seam.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          The Terrain Seam class (<xref linkend="Terrain Seam Diagram"/>) 
          represents characteristics of the boundary between two different 
          Terrain Types (two adjacent regions of the same Terrain Type are 
          considered to be a single, contiguous region; thus, a Terrain Type 
          cannot have a boundary with itself). The components of a Terrain Seam 
          are:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            a scalar in the range <inlineequation>
                                <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B0,1%5D.mml">
  <mfenced open="[" close="]">
    <mn>0</mn>
    <mn>1</mn>
  </mfenced>
</math>

</inlineequation> indicating the 
            target smoothness for that boundary type
          </listitem>
          <listitem>
            references to the two Terrain Types this Terrain Seam separates
          </listitem>
        </itemizedlist>
      </section>

      <section id="Data Structure - Map">
        <title>Map</title>
        <figure id="Map Diagram" float="0">
          <title>The Map Data Structure</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Implementation - Map.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
         The Map class (<xref linkend="Map Diagram"/>) represents a 
         user-authored, vector-drawn Terrain Type map.
        </para>
        <para>
          The Map can be implemented as a 2-dimensional connected polygonal mesh 
          (using, for example, a variation of the winged-edge <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Winged Edge"/> data structure): polygonal regions in the map 
          correspond to mesh faces, and boundaries between regions correspond to 
          mesh edges.  The usefulness of this approach is that conventional 
          polygon-modeling tools and techniques may be used to author the map.  
          Furthermore, most 3D modeling packages already contain robust tools 
          for editing polygon meshes, possibly simplifying implementation of 
          <citetitle>Terrainosaurus</citetitle> as part of such a package.
        </para>
        <para>
          In order to use a polygon mesh structure to represent the map, it 
          must be augmented with some additional data fields. Instead of 
          conventional polygon mesh attributes like 3D positional coordinates, 
          texture coordinates, vertex colors and normals, the map mesh needs 
          the following attributes:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            2D positional coordinates for each vertex in the map
          </listitem>
          <listitem>
            the Terrain Type for each region (face) in the map
          </listitem>
          <listitem>
            the sequence of 2D points representing the boundary refinement for 
            each edge in the map
          </listitem>
        </itemizedlist>
        <para>
          Because the Map is implemented as a topologically connected polygon 
          mesh, it must also be stored this map in a format that preserves this 
          information. A simple way to do this is with a trimmed-down version of 
          the Wavefront OBJ file format <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="OBJ Specification"/>.  The only record types of the OBJ format that are 
          needed are a 2D version of the vertex record ('v'), a terrain type 
          declaration ('tt', analogous to the material declaration), and a face 
          record ('f') (see <xref linkend="MAP Example Listing"/>).
        </para>
        <figure id="MAP Example Listing" float="0">
          <title>An Example Terrain Type Map File</title>
          <caption>
            One way of persisting the user's terrain type map is with a 
            variation on the ubiquitous Wavefront OBJ file format.
          </caption>
          <programlisting format="linespecific">
# Map vertices
v -700.0 -700.0     # 1
v -400.0 -400.0     # 2
.
.
# Map regions (faces)
tt California_Coast_Hills
f 1 2 3 4 5 6
.
.
          </programlisting>
        </figure>
      </section>

      <section id="Data Structure - Map Rasterization">
        <title>Map Rasterization</title>
        <figure id="Map Rasterization Diagram" float="0">
          <title>The Map Rasterization Data Structure</title>
          <mediaobject>
            <imageobject>
              <imagedata fileref="Implementation - Map Rasterization.svg"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>
          The Map Rasterization class (<xref linkend="Map Rasterization Diagram"/>) is a raster version of a Map, and is usually associated
          with one or more Terrain Samples of the same dimensions.  Besides
          being useful during the height field generation process, as described
          in <xref linkend="Analyzing the Map"/>, the Map Rasterization is also
          useful for exporting a representation of the map in a form useful for
          downstream processing of the height field: the raster of terrain type
          IDs can be saved in a conventional image format (PNG or Targa, for
          example), and used to do further computation, such as assigning
          texture coordinates to the terrain, or populating the terrain with
          trees, rocks, or other objects. The components of a Map Rasterization
          are:
        </para>
        <itemizedlist spacing="compact">
          <listitem>
            a raster object containing the integer terrain type ID for each grid 
            cell
          </listitem>
          <listitem>
            a raster object containing the integer region ID for the region 
            enclosing each grid cell
          </listitem>
          <listitem>
            a raster object containing the scalar distance from the center of 
            the grid cell to the nearest region boundary; this is used to 
            generate the alpha masks for creating the coarsest LOD to prime the 
            generation process (<xref linkend="Creating the Initial LOD"/>)
          </listitem>
          <listitem>
            the number of distinct regions present in the Map Rasterization
          </listitem>
          <listitem>
            the Terrain Type, pixel-area, axis-aligned bounding box of each 
            region, and a pixel located inside of that region (needed to 
            flood-fill the region)
          </listitem>
        </itemizedlist>
      </section>

    </section>

    <section>
      <title>Suggested User Interface</title>
      <para>
        Ideally, a graphical user interface for 
        <citetitle>Terrainosaurus</citetitle> should allow the user to view, 
        navigate and edit the terrain type map in an intuitive fashion, and to 
        invoke the height field generation GA, and to visualize the results. At 
        a minimum, the interface should support the following operations:
        <itemizedlist spacing="compact">
          <listitem>load map</listitem>
          <listitem>save map</listitem>
          <listitem>create region</listitem>
          <listitem>delete region</listitem>
          <listitem>move vertex</listitem>
          <listitem>set terrain type</listitem>
          <listitem>refine boundary</listitem>
          <listitem>select region to generate</listitem>
          <listitem>save terrain</listitem>
        </itemizedlist>
      </para>
      <para>
        The prototype implementation of <citetitle>Terrainosaurus</citetitle> 
        accomplishes these operations with two user interface windows: a map 
        editor window and a terrain viewer window.
      </para>
      <para>
        The map editor window (<xref linkend="Map Editor Window"/>) allows the 
        user to select regions, boundaries, and vertices by clicking on them or 
        "lasso selecting" them with the mouse. When selecting individual objects 
        or adding regions to the map, the mouse pointer will snap to nearby 
        vertices and edges, making it possible to create connected polygons.  
        Loading, saving and editing operations are triggered by keyboard 
        commands.
      </para>
      <figure id="Map Editor Window" float="0">
        <title>The Map Editor Window</title>
        <caption>
          The map editor window allows the user to view, navigate and edit a 
          terrain type map using polygon modeling operations.
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="4in" fileref="Implementation - Map Editor Window.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        The terrain viewer window (<xref linkend="Terrain Viewer Window"/>) is 
        a 3D height field viewer, allowing the user to explore the generated 
        height field (or one of the example height fields) in 3D.  One minor 
        "trick" that deserves mentioning is that, when displaying a height 
        field, the height field geometry (or the camera) should be offset in 
        the vertical direction by the mean elevation of the height field. This   
        is necessary in order to have the height field in the viewport; if 
        this transformation is not done, the height field surface may be 
        located far above or below the camera in the 3D space, making it 
        difficult to find.
      </para>
      <figure id="Terrain Viewer Window" float="0">
        <title>The Terrain Viewer Window</title>
        <caption>
          The terrain viewer window allows the user to view the generated 
          terrain at different levels of detail and from any angle.
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="4in" fileref="Implementation - Terrain Viewer Window.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Implementing the Genetic Algorithms</title>
      <para>
        Because GAs are used in multiple places in 
        <citetitle>Terrainosaurus</citetitle>, it is advantageous to write the 
        bulk of the GA code in a reusable manner and then to specialize it as 
        needed for each of the GAs. To do this, however, is slightly more 
        complicated than writing reusable library functions, since the parts of 
        the algorithm that need to be specialized are embedded deep within the 
        algorithm (i.e., the reused functionality is the over-arching algorithm, 
        not the low-level functions and objects, as is normally the case when 
        creating a reusable code library).
      </para>

      <section>
        <title>A Generic GA Framework</title>
        <para>
          This pattern of interaction between the reusable and 
          application-specific parts of the code is sometimes referred to 
          <firstterm>inversion of control</firstterm>, and implementations of 
          this principle are commonly called <firstterm>frameworks</firstterm>.  
          Frameworks can be implemented in a structured programming language 
          through the use of callback functions (the GLU polygon tessellator 
          code is a small example of this), but object-oriented and generic 
          programming constructs (inheritance, polymorphism and templates) make 
          framework implementation much simpler and cleaner.  The usual method 
          of creating a framework is for the <firstterm>hotspots</firstterm> 
          (application-specific parts of the framework) to be implemented as 
          abstract interfaces, and the rest of the framework to be implemented 
          in terms of these abstract objects.  Then, to specialize the framework 
          for a particular application, all that a developer needs to do is to 
          create application-specific objects to fit into those hotspots.
        </para>
        <variablelist>
          <para>
            A suggested way of decomposing a GA as a framework is as follows. To 
            use the framework to solve a particular problem, the developer would 
            subclass some or all of the following classes to implement 
            problem-specific functionality.
          </para>
          <varlistentry>
            <term>Genetic Algorithm</term>
            <listitem>
              the top-level object of the framework. This object has a number of 
              parameters specifying the overall behavior of the algorithm, such 
              as the population size, number of evolution cycles, and the 
              probabilities of mutation and crossover. In addition to setting 
              these parameters, the developer must add one or more specialized 
              Operator objects to the GA. Once configured, the GA is launched by 
              calling its run() function.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Chromosome</term>
            <listitem>
              the representation of an individual solution in the algorithm.  
              This class should contain some number of Genes, and the 
              specialized Operators should be written to work on it.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Gene</term>
            <listitem>
              an atomic sub-part of a Chromosome. Mutation and crossover 
              operators work on these.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Initialization Operator</term>
            <listitem>
              an operator for performing some arbitrary initialization on a 
              Chromosome. These are called to initialize new Chromosomes as they 
              are introduced into the population (e.g., to replace those that 
              were killed off in the previous evolution cycle).
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Crossover Operator</term>
            <listitem>
              an operator for performing some sort of exchange of genetic 
              material between two Chromosomes. The probability of a crossover 
              operator being invoked on a pair of Chromosome is controlled by 
              the Genetic Algorithm's <emphasis>crossover probability</emphasis> 
              parameter.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Mutation Operator</term>
            <listitem>
              an operator for performing some arbitrary mutation on a Gene.  The 
              probability of a mutation operator being invoked on a gene is 
              controlled by the Genetic Algorithm's <emphasis>mutation 
              probability</emphasis> parameter.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Fitness Operator</term>
            <listitem>
              an operator for calculating a fitness value (a scalar in the range 
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/%5B0,1%5D.mml">
  <mfenced open="[" close="]">
    <mn>0</mn>
    <mn>1</mn>
  </mfenced>
</math>

</inlineequation>) for a 
              Chromosome.
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          A Genetic Algorithm must have <emphasis>at least</emphasis> one 
          initialization operator and one fitness operator, but it may have as 
          many operators of each type as desired, and may optionally assign a 
          weight to each registered operator.  For the initialization, 
          crossover, and mutation operators, these weights are used to construct 
          a cumulative probability distribution function, which is then used to 
          select which of the available operators is used (with probabilistic 
          preference given to operators with higher weights). In the case of the 
          fitness operators, <emphasis>each</emphasis> registered operator is 
          invoked on the chromosome, and the weights are used to determine how 
          significant each fitness component is to the overall fitness 
          calculation.
        </para>
      </section>

      <section>
        <title>The Boundary Refinement GA</title>
        <para>
          The boundary refinement GA is relatively straightforward to implement, 
          with each gene containing only a relative angle from the previous 
          segment and the absolute angle with respect to the 
          <inlineequation>
                            <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>

</inlineequation> 
          axis. The operators defined on this GA are:
        </para>
        <variablelist>
          <varlistentry>
            <term>Init: <emphasis>Random Angle</emphasis>
</term>
            <listitem>
              an initialization operator that populates a chromosome with random 
              angles in each gene (subject to the max absolute angle constraint)
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Init: <emphasis>Straight Line</emphasis>
</term>
            <listitem>
              an initialization operator that populates a chromosome with an 
              angle of zero between consecutive segments
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Cross: <emphasis>Splice Subsequences</emphasis>
</term>
            <listitem>
              a crossover operator that chooses a split-point and exchanges the 
              subsequences following that point between two chromosomes
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Mutate: <emphasis>Random Bend</emphasis>
</term>
            <listitem>
              a mutation operator that introduces a random change to the angle 
              in a single gene
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Fitness: <emphasis>Smoothness</emphasis>
</term>
            <listitem>
              a fitness operator that evaluates the fitness of a chromosome 
              according to the scheme described in <xref linkend="Boundary GA Fitness"/>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>
          The boundary refinement GA itself has only one additional parameter 
          beyond the standard parameters belonging the the Genetic Algorithm 
          framework:
        </para>
        <variablelist>
          <varlistentry>
            <term>
                                <emphasis>max absolute angle</emphasis>
</term>
            <listitem>
              the maximum allowed deviation from the <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>
                                </inlineequation> axis; see <xref linkend="Accumulated Angle Discussion"/> in <xref linkend="Discussion"/> for further discussion of the problems and 
              implications associated with this.
            </listitem>
          </varlistentry>
        </variablelist>
      </section>

      <section>
        <title>The Height Field Generation GA</title>
        <para>
          The height field GA is a bit more complicated than that for the 
          boundary refinement. The Chromosome for this GA contains a 2D grid of 
          Genes, each of which contains pointers to its source Terrain Sample 
          and Terrain Type, as well as a set of transformation parameters. Also, 
          the Chromosome retains the results of the last fitness evaluation (the 
          regions' similarity and gene compatibility measurements), and uses 
          these values to bias the operator probabilities towards operators that 
          are more likely to be helpful (<xref linkend="Height Field GA Fitness Evaluation"/>).
        </para>
        <variablelist>
          <para>
            The operators defined for the height field GA are:
          </para>
          <varlistentry>
            <term>Init: <emphasis>Random Source Data</emphasis>
</term>
            <listitem>
              an initialization operator that initializes each Gene with a 
              randomly selected source Terrain Sample from the appropriate 
              Terrain Type, and randomly chosen <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>

</inlineequation> coordinates within 
              that Terrain Sample from which to get its elevation data.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Cross: <emphasis>Swap Rectangular Region</emphasis>
</term>
            <listitem>
              a crossover operator that swaps rectangular clusters of Genes 
              between two Chromosomes
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Mutate: <emphasis>Reset Transform</emphasis>
</term>
            <listitem>
              a mutation operator that resets the transformation parameters in a 
              Gene.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Mutate: <emphasis>Vertical Offset</emphasis>
</term>
            <listitem>
              a mutation operator that adjusts the mean elevation of a Gene.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Mutate: <emphasis>Vertical Scale</emphasis>
</term>
            <listitem>
              a mutation operator that adjusts the vertical range spanned by a 
              Gene.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Mutate: <emphasis>Vertical Rotate</emphasis>
</term>
            <listitem>
              a mutation operator that adjusts the rotation around the vertical 
              applied to the elevation values for a Gene.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Mutate: <emphasis>Horizontal Translate</emphasis>
</term>
            <listitem>
              a mutation operator that adjusts the <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/(x,y).mml">
  <mfenced>
    <mi>x</mi>
    <mi>y</mi>
  </mfenced>
</math>

</inlineequation> coordinates used for 
              the source height field data for a Gene.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Fitness: <emphasis>Gene Compatibility</emphasis>
</term>
            <listitem>
              a fitness operator that evaluates the similarity between the 
              approximate geometric shape of the elevations controlled by each 
              Gene and the corresponding area of the "pattern" height field from 
              the previous LOD.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>Fitness: <emphasis>Region Similarity</emphasis>
</term>
            <listitem>
              a fitness operator that evaulates the similarity between each 
              region of generated terrain and the corresponding terrain type 
              that that region is supposed to emulate.
            </listitem>
          </varlistentry>
        </variablelist>
        <variablelist>
          <para>
            Also, the height field GA has several additional parameters beyond 
            the standard parameters belonging the the Genetic Algorithm 
            framework:
          </para>
          <varlistentry>
            <term>
                                <emphasis>gene size</emphasis>
</term>
            <listitem>
              the width/height (in pixels) of a single Gene—larger values 
              result in fewer Genes being required to cover the entire height 
              field, but also permit less fine-scale modification to the height 
              field; values around 16 pixels seem to work well, at least for 
              lower resolution height fields (up to 90m).
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
                                <emphasis>overlap factor</emphasis>
</term>
            <listitem>
              the percentage of linear overlap between adjacent Genes (see <xref linkend="Height Field GA Gene Grid Diagram"/>); this controls how 
              much blending occurs between adjacent Genes—a value of zero 
              implies no blending, and would result in discontinuities at gene 
              boundaries; values around 20% seem to work well.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
                                <emphasis>max crossover width</emphasis>
</term>
            <listitem>
              the width of the largest rectangular chunk of Genes that will be 
              swapped during a single crossover operation; if this value is 
              <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/N.mml">
  <mi>N</mi>
</math>

                                </inlineequation>, this implies that, at 
              most, <inlineequation>
                                    <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/N%5E2.mml">
  <msup>
    <mi>N</mi>
    <mn>2</mn>
  </msup>
</math>

</inlineequation> Genes will be swapped.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
                                <emphasis>max vertical scale</emphasis>
</term>
            <listitem>
              the maximum factor by which to scale a Gene's elevation values 
              during a single mutation; this controls how drastic of a change 
              the GA is allowed to make.
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
                                <emphasis>max vertical offset</emphasis>
</term>
            <listitem>
              the maximum amount by which to change a Gene's mean elevation 
              during a single mutation; this controls how drastic of a change 
              the GA is allowed to make.
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
  </section>

  <section>
    <title>Optimizations &amp; Simplifications</title>
    <para>
      <citetitle>Terrainosaurus</citetitle> is a computationally expensive 
      algorithm; as such, anything that can be done to increase its efficiency 
      is a welcome improvement. Furthermore, it will be easier to implement if 
      existing technologies can be leveraged to solve some of its sub-problems.  
      Toward these ends, I offer several ideas for optimizing and/or 
      simplifying the implementation of the algorithm that were used in 
      implementing the prototype. Further suggestions for optimizing the 
      process that have not yet been explored are discussed in <xref linkend="Future Work"/>.
    </para>

    <section>
      <title>Caching the Analysis of Library Terrain Samples</title>
      <para>
        The height field analysis step is, by far, the most expensive part of 
        the algorithm. While this cost cannot be completely eliminated (as each 
        generated height field must be evaluated for fitness), it is at least 
        possible to avoid repeatedly analyzing those height fields belonging to 
        the Terrain Library, since these are essentially 
        static. One way to do this is to dump the results of analyzing an LOD of 
        a height field into a file as soon as it is analyzed. Then, whenever 
        that LOD of that particular height field is needed thereafter, if the 
        dump file is newer than the .dem file from which it was generated, the 
        analysis can be skipped, and the previously calculated results just 
        rehydrated from the file.
      </para>
      <para>
        In fact, if the dump file is created as a <emphasis>binary</emphasis> 
        dump of the Terrain Sample's data structures, the 
        analysis results can be loaded very quickly, even more quickly than 
        loading the original .dem file that they originally came from! This can 
        be attributed to the rather bad compression of the .dem file format, and 
        to the cost of parsing ASCII text into numeric data, which is avoided by 
        reading and writing as binary.  One word of warning though: during 
        active development, it is easy to change a data structure, while 
        forgetting the impact that this will have on the dump files. Be sure to 
        verify that your dump files are the size your data structures expect 
        them to be.
      </para>
    </section>

    <section>
      <title>Optimizing the Feature Detection Step</title>
      <para>
        Feature detection is the most computationally expensive part of the 
        height field fitness evaluation—speeding this up will result in a 
        significant reduction in overall execution time. Several things can be 
        done to accelerate this step.
      </para>

      <section id="Frequency Domain Convolution">
        <title>Do Convolution in the Frequency Domain</title>
        <para>
          The first step in scale-space feature detection is to generate the 
          scale-space representation of height field (height field), which  
          requires convolving the image with Gaussian filters of various sizes.  
          As the size of the filter increases, the convolution becomes more and 
          more computationally expensive to perform in the spatial domain.  
          Fortunately, because of the properties of the Fourier transform, the 
          expensive spatial-domain operation of convolving two images is 
          equivalent to performing ordinary, element-wise  multiplication of 
          their frequency domain representations (i.e., their Fourier 
          transforms). The computational cost of this multiplication does not 
          increase as the filter size grows. Therefore, if the amount of 
          convolution to be done is large enough, the computational savings of 
          doing this convolution in the frequency domain will more than offset 
          the expense of  performing the forward and inverse Fourier transforms, 
          for a net increase in speed.
        </para>
      </section>

      <section>
        <title>Save &amp; Reuse Computations</title>
        <para>
          At the risk of stating the obvious, one way of reducing the expense 
          of feature detection is to cache the results of computations rather 
          than recomputing them each time they are needed. Feature detectors 
          typically use first, second, and third, or even higher partial 
          derivatives of the image to compute their response, and these 
          derivatives occur multiple times in the evaluation. Because of this, a 
          significant speed-up can be realized (at the cost of higher memory  
          usage) by creating additional rasters to cache the various 
          derivatives. Furthermore, different detectors often have some of their 
          sub-computations in common; thus, the overall cost of doing both edge 
          and ridge detection can be reduced by keeping the intermediate results 
          from the edge detector and reusing them for the ridge detector.
        </para>
      </section>

      <section>
        <title>Limit the Number of Scales</title>
        <para>
          The cost of feature detection is proportional to the number of scales 
          being searched. Thus, a good way to limit the expense is to reduce 
          the number of scales. Because of the known, power-of-three 
          relationship between successive LODs of the terrain, it may be 
          possible (or even preferable) to limit the scales searched by the 
          feature detection step to a small number. How significantly this will 
          affect the performance of the GA fitness function is not clear, and is 
          an area for future research (<xref linkend="Performance Improvements"/>).
        </para>
      </section>
    </section>

    <section>
      <title>Optimizing the Computation of Windowed Statistics</title>
      <para>
        In the "studying" phase of analysis for a 
        Terrain Sample, several statistics are calculated 
        over <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/NxN.mml">
  <mi>N</mi>
  <mo>×</mo>
  <mi>N</mi>
</math>

                    </inlineequation> cell 
        neighborhoods around each cell of the height field. Computing these 
        quantities is very similar to performing convolution with an 
        <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/NxN.mml">
  <mi>N</mi>
  <mo>×</mo>
  <mi>N</mi>
</math>

                    </inlineequation> pixel 
        filter. Just like many filters, these operations are 
        <firstterm>separable</firstterm>, meaning that they can be done more 
        efficiently by being evaluated as two sequential 1-dimensional 
        operations: first the statistic is evaluated across the 
        <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/x.mml">
  <mi>x</mi>
</math>

                    </inlineequation>-coordinate, and then across 
        the <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/y.mml">
  <mi>y</mi>
</math>

</inlineequation>-coordinate of the result.
      </para>
    </section>

    <section>
      <title>Simplifying Rasterization of the Map</title>
      <para>
        Generating the Map Rasterization from the Map is a somewhat difficult 
        problem, primarily because, especially with the addition of the refined 
        boundaries, the polygons that make up the map tend to have many, many 
        edges, and to be highly non-convex.
      </para>
      <para>
        Fortunately, this problem has already been solved. The <citetitle>GL 
        Utilities (GLU) Library</citetitle> includes a tessellator for 
        transforming (possibly self-intersecting) non-convex polygons into 
        triangles, which can be rendered easily. Then, to create the Map 
        Rasterization, we need only render these triangles, with an 
        appropriately chosen viewport, and then to read back the rendered pixels 
        from the framebuffer. For this to work, the color with which each 
        triangle is rendered needs to encode the terrain type ID for its 
        corresponding region. Also, it is important to 
        <emphasis>disable</emphasis> lighting, antialiasing and alpha blending, 
        so that the rendering system does not interpolate colors (thus 
        destroying this encoding).
      </para>
      <para>
        Another potential solution, if using <citetitle>OpenGL</citetitle> is 
        impossible or undesirable, is to rasterize the boundaries between 
        regions, and then to use a flood-fill algorithm to fill in the regions.
      </para>
    </section>

  </section>

</chapter>
  <chapter id="Discussion" xml:base="discussion.xml">
  <title>Results &amp; Discussion</title>
  <para>
    In this chapter, I will discuss the results achieved with 
    <citetitle>Terrainosaurus</citetitle>, both successes and problems, and 
    with running times and generated images. The sequence of topics will 
    parallel that of the previous chapters:
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      the boundary refinement algorithm
    </listitem>
    <listitem>
      the terrain comparison algorithm
    </listitem>
    <listitem>
      the height field construction algorithm
    </listitem>
  </itemizedlist>

  <section id="Boundary GA Discussion">
    <title>Boundary Refinement</title>
    <para>
      The boundary refinement operation offers the user a simple means of 
      creating irregular boundaries between regions of terrain, without having 
      to draw every bend in the curve by hand (<xref linkend="Map Refinement (Smooth)"/>, <xref linkend="Map Refinement (Rough)"/>).  In many (if 
      not most) cases, this amount of control is sufficient for the user's 
      needs.  It is also a very fast computation (refining the boundaries for 
      an entire map is virtually instantaneous from the user's point of view, 
      using 20 evolution cycles and a population size of 5 for the GA).
    </para>
    <figure id="Map Refinement (Smooth)" float="0">
      <title>Map Boundaries Refined With S = 0.9</title>
      <mediaobject>
        <imageobject>
          <imagedata scalefit="1" width="4in" fileref="Map Refinement - Smooth.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <figure id="Map Refinement (Rough)" float="0">
      <title>Map Boundaries Refined With S = 0.1</title>
      <mediaobject>
        <imageobject>
          <imagedata scalefit="1" width="4in" fileref="Map Refinement - Rough.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>
      There are, however, several aspects that deserve some additional 
      discussion.
    </para>

    <section id="Accumulated Angle Discussion">
      <title>The Accumulated Angle Constraint</title>
      <para>
       One item of interest regarding this operation is the global constraint 
       we impose, that the absolute angle is not allowed to exceed a certain 
       threshold at any point. This was found to be necessary in order to force 
       the boundary to make progress in the direction of the end point.   
       Without this constraint it is very possible for the curve to double back 
       on itself, especially if the smoothness parameter is low (thus allowing 
       sharper turns with each segment). This is problematic for a number of 
       reasons.
      </para>
      <para>
        First of all, it is easy for the curve to intersect itself, producing 
        loops in the boundary. We consider this behavior to be undesirable, 
        since it effectively creates additional regions, and it is not 
        completely clear which of the two adjacent terrain types should fill 
        the new regions (<xref linkend="Self-intersecting Boundary"/>).
      </para>
      <figure id="Self-intersecting Boundary" float="0">
        <title>A Self-intersecting Boundary</title>
        <caption>
          If no constraints are placed on the boundary GA, it can generate 
          boundaries that loop back on themselves.
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Self-intersecting Boundary.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        Second, it is possible for the generated start and end points to be 
        very near to each other (i.e., the boundary wanders far away, but ends 
        up back near the place from which it started). Such a boundary is a very 
        poor approximation of the original. Worse still, a generated boundary 
        with this characteristic will have to be scaled enormously in order to 
        get the start and end points to line up with the original boundary. The 
        result of this is that the boundary will be magnified to  absurd 
        proportions, as compared to the rest of the map, and will probably also 
        intersect several nearby boundaries (<xref linkend="Backtracking Boundary"/>).
      </para>
      <figure id="Backtracking Boundary" float="0">
        <title>A Badly Scaled, Backtracking Boundary</title>
        <caption>
          If a boundary's end point is too close to its start, then the scale 
          factor required to place the generated end points on top of the 
          original end points is huge, causing the boundary to be scaled to 
          absurd proportions.
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata fileref="Backtracking Boundary.svg"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        A third problem, related to the previous two, is that as the refined 
        boundary becomes less linear, the scale factor needed to bring the end 
        points into alignment increases. As the scale factor increases, so do 
        the lengths of the line segments that make up the boundary, thereby 
        thwarting one of the objectives of the boundary refinement operation 
        (i.e., to keep the lengths of individual segments small).
      </para>
      <para>
        These problems are all prevented or minimized by the global constraint 
        on accumulated angle. Unfortunately, this simplification also excludes 
        certain, valid boundary shapes, in much the same way that height fields 
        cannot represent certain, valid terrain features. Thus, it would be 
        nice to be able to lift this restriction, but in order to do this, we 
        would need some other way of avoiding the aforementioned problems; this 
        is an area for future work.
      </para>
    </section>

    <section>
      <title>Smoothness and Level of Detail</title>
      <para>
        Another topic worth discussing is the effect of the smoothness 
        parameter. In order to keep the curve well-behaved, both locally and at  
        larger scales, we evaluate its fitness at several levels of detail, 
        using the same smoothness value. Thus, the generated curves will 
        display similar behavior at several scales (i.e., they are 
        fractal-like). As a result, the operation is somewhat limited in the 
        kinds of boundaries it can produce: rough, meandering boundaries and 
        smooth, straight boundaries are both possible, but smooth, meandering 
        boundaries are not (since this would imply sharper turns at larger 
        scales and softer turns at finer scales). This behavior could be made 
        more controllable with the introduction of additional smoothness 
        parameters for coarser levels of detail, though the additional benefit  
        might not be worth the added complexity.
      </para>
    </section>

    <section>
      <title>Additional Constraints</title>
      <para>
        As mentioned previously, one of the benefits of a genetic algorithm is 
        its flexibility. While the only constraint currently imposed on the 
        generated boundaries is that they have a user-specified, characteristic 
        smoothness, it would be relatively straightforward to incorporate 
        additional constraints into the fitness evaluation, such as:
        <itemizedlist spacing="compact">
          <listitem>
            In addition to matching the locations of the endpoints of the 
            original boundary, the refined boundary should also match specific 
            angles at the endpoints. This would make it possible to eliminate 
            sharp "corners" from regions.
          </listitem>
          <listitem>
            The refined boundary should not intersect other, nearby boundaries.
          </listitem>
          <listitem>
            The refined boundary should not have any self-intersections, nor 
            should it end near to where it began. This would help to address 
            the problems discussed in the previous section about the global 
            constraint on the accumulated angle.
          </listitem>
          <listitem>
            The refined boundary should remain within a user-defined 
            "envelope". This would provide the user with additional control 
            over the shape of the boundary.
          </listitem>
        </itemizedlist>
      </para>
    </section>

  </section>

  <section>
    <title>Terrain Library Analysis</title>
    <section id="Empirical Analysis">
      <title>Empirical Analysis</title>
      <para>
        In order to validate the claim that the statistics used are suitable 
        for establishing similarity, we examined 56 terrains taken from 7 US 
        states. The terrains were grouped into 18 terrain types, the smallest 
        of which contained only one example, and the largest of which contained 
        8 examples. Classification was done based on visual inspection by one 
        user.
      </para>
      <para>
        Visual comparison of histograms in <citetitle>Matlab</citetitle> 
        revealed a high degree of similarity between the histograms of the same 
        terrain type, when compared to those of other terrain types. In most 
        cases, the mean values were fairly close, and the histogram had the 
        same approximate shape (the example in <xref linkend="Terrain Type Elevation Histograms"/> is fairly typical).  Because of this, we 
        conclude that these statistics <emphasis>are</emphasis> meaningful in 
        evaluating similarity.
      </para>
      <figure id="Terrain Type Elevation Histograms" float="0">
        <title>Elevation Histograms from the California Coast Hills</title>
        <caption>
          The elevation histograms for several samples of similar terrain, taken 
          from a region of southern California. The overall histogram shapes 
          correspond fairly well to one another.
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="4in" fileref="California Coast Hills Elevation.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>
        The terrain library also scored well against the similarity function.  
        Of course, every terrain sample received a self-fitness score above 
        90%—this is true by definition, so it means nothing. What is 
        significant is that agreement measurements were also high, typically 
        above 90% for most measurements.  In contrast, when a sample of steep, 
        Wyoming mountains was "misclassified" among samples of Florida flatland, 
        many of the agreement measurements dropped from 97%–99% to under 60% 
        (and in once case, nearly to 0%). This agrees with conclusions drawn 
        from visual inspection of the histograms.
      </para>
    </section>

    <section>
      <title>The Similarity Function</title>
      <para>
        The most difficult part of <citetitle>Terrainosaurus</citetitle> was 
        constructing an effective terrain type similarity measurement.  While 
        there is certainly room for improvement, the function described in 
        <xref linkend="Terrain Library Analysis"/> does a reasonably good job of 
        favoring more realistic terrain, at least with the terrain types used to 
        test it (e.g.,
        <xref linkend="Florida Comparison Reference"/>,
        <xref linkend="Florida Comparison Generated"/>,
        <xref linkend="Washington Comparison Reference"/>,
        <xref linkend="Washington Comparison Generated"/>).
        This success can be attributed to several desirable characteristics:
      </para>
      <itemizedlist spacing="compact">
        <listitem>
          it scores all of the reference height fields highly (similarity of 90% 
          or better) without over-fitting the data; this allows it to generalize 
          effectively in order to accept new data
        </listitem>
        <listitem>
          it is able to detect when a particular measurement is useless for 
          evaluating a particular terrain type and ignore that measurement; 
          furthermore, it can also detect when its overall discriminating power 
          is weak due to bad input data
        </listitem>
        <listitem>
          it is not sensitive to any similarity between terrain samples 
          belonging to different terrain types; this allows it to be tolerant 
          of overlapping (or even identical) terrain types created by the user
        </listitem>
      </itemizedlist>
      <figure id="Florida Comparison Reference" float="0">
        <title>A Reference Height Field from Florida</title>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="3.5in" fileref="Florida Flatland reference.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <figure id="Florida Comparison Generated" float="0">
        <title>A Generated Height Field Based on the Florida Reference</title>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="3.5in" fileref="Florida Flatland generated.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <figure id="Washington Comparison Reference" float="0">
        <title>A Reference Height Field from Washington</title>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="3.5in" fileref="Washington Mountains reference.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <figure id="Washington Comparison Generated" float="0">
        <title>A Generated Height Field Based on the Washington Reference</title>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="3.5in" fileref="Washington Mountains generated.png"/>
          </imageobject>
        </mediaobject>
      </figure>

      <section id="Classifying Well">
        <title>On the Importance of Classifying Well</title>
        <para>
          The user's only job in the terrain library analysis process is to 
          segregate the example terrains into meaningful terrain types. It is not 
          important for these terrain types to be <emphasis>disjoint</emphasis> 
          with respect to one another (i.e., no overlap in measured statistics); 
          to require this of the user would be overly taxing, and is not 
          reflective of the real world either (many diverse terrain types share 
          similar mean elevations, for example). One of the strengths of this 
          algorithm is that the user is allowed to create as many, 
          finely-distinguished terrain types as he needs to suit his purposes.
        </para>
        <para>
          It <emphasis>is</emphasis> important, however, that each terrain type 
          be <emphasis>coherent</emphasis>. The similarity function is designed 
          to adapt itself to whatever patterns it is able to discover within the 
          examples given to it—if the examples given to it are essentially 
          unrelated, the function will be unable to learn anything meaningful, 
          and will, accordingly, produce garbage. When the similarity function 
          described in this paper was originally implemented, it produced 
          initially poor results; this turned out to be the result of several 
          badly-classified examples.
        </para>
        <para>
          A related issue that also poses problems for the similarity analysis is 
          the presence of <emphasis>multiple</emphasis> terrain types within a 
          single terrain sample, such as a lake in the midst of mountainous 
          terrain, or mountains trailing off into a flat plain. These situations 
          can yield statistical distributions that are uncharacteristic of 
          <emphasis>any</emphasis> of the terrain types involved, often 
          significantly skewed or multi-modal. Because 
          <citetitle>Terrainosaurus</citetitle> does not currently detect these 
          conditions, such example terrains cannot be used.
        </para>
        <para>
          Addressing these issues would go a long way towards improving the 
          overall user experience in this phase, and is an area for future 
          work (<xref linkend="Computer-aided Classification"/>).
        </para>
      </section>

      <section id="Failures">
        <title>Things that Didn't Work</title>
        <para>
          In arriving at this similarity function, a number of things were 
          attempted that turned out not to work effectively. I mention a few of 
          them here in the hopes of providing guidance and inspiration to future 
          researchers in this area: guidance—that the dead-ends of the past 
          need not be revisited—and inspiration—that one of these failed 
          ideas might be the seed that one day sprouts into an idea that 
          <emphasis>does</emphasis> work.
        </para>
        
        <section>
          <title>Direct Height Field to Height Field Comparison</title>
          <para>
            Early in the research process, we attempted to use the RMS (root mean 
            square) difference between the generated height field and a reference 
            example as an estimate of their similarity. This was never intended 
            to be the final similarity function, but only a temporary, partial 
            solution. Just the same, it is instructive to consider the problems 
            from which it suffers, as similar pixel-wise approaches will likely 
            have many of the same failings:
          </para>
          <itemizedlist spacing="compact">
            <listitem>
              it is quite sensitive to the precise placement of features in  the 
              terrain; as such, it is too restrictive to be the basis for a real 
              similarity function, as it cannot even relate similar 
              <emphasis>example</emphasis> terrains to one another; consider 
              comparing a sloping terrain to its mirror image—this would 
              receive a low similarity score even though it is comparing a 
              terrain <emphasis>to itself</emphasis>!
            </listitem>
            <listitem>
              it is not clear how to generalize a pixel-by-pixel comparison such 
              as this to handle multiple example terrains in a terrain type
            </listitem>
            <listitem>
              it is extremely sensitive to the mean elevation of the terrains: a 
              large difference in mean elevations will inordinately penalize two 
              otherwise very similar terrains
            </listitem>
            <listitem>
              it is not even clear how to compare two rectangular terrains of 
              different dimensions, much less two non-rectangular regions
            </listitem>
            <listitem>
              as the RMS difference between two terrains is effectively 
              unbounded, this value cannot, by itself serve as a similarity 
              measure, and it is unclear how to adequately transform this 
              unbounded value into a bounded value (this is only an issue if 
              fitness-proportional selection is used in the GA; an unbounded 
              fitness function can still work if tournament selection is used in 
              the GA)
            </listitem>
          </itemizedlist>
        </section>

        <section id="Failures - Fourier Transform">
          <title>Comparing the Fourier Transform</title>
          <para>
            Another idea we attempted was to compare the Fourier transforms of 
            terrains. This gets around the problem of the previous idea, that the 
            height fields needed to be of the same size, since the Fourier 
            transforms can be resampled to the same size and compared directly.  
            However, attempting to compare the FFTs magnitudes of apparently 
            similar terrains did not yield promising results, and so we abandoned 
            this approach.
          </para>
        </section>

        <section>
          <title>Linear Pattern Analysis</title>
          <para>
            As a third approach, we tried to apply standard pattern analysis 
            tools to discover automatically the relationships between examples 
            of the same terrain type. The main difficulty motivating this 
            approach was that of identifying which characteristics of a set of 
            terrains are most important. In order to choose which terrain 
            chromosomes to keep and which to "recycle" during the GA, a good 
            means of ranking them is needed...but given the wide variety of 
            possible characteristics that could be used, it is hard to see 
            which should be given preference (or whether all should be weighted 
            equally).
          </para>
          <para>
            <firstterm>Fisher's linear discriminant (FLD)</firstterm> <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Pattern Recognition"/> is a common pattern recognition 
            technique for <firstterm>dimensionality reduction</firstterm>, in 
            which a large number of characteristics can be projected down to a 
            smaller set. FLD chooses the projection that maximizes separation 
            between the different classes of data (i.e., in our case, the 
            terrain types). It also calculates a separability ratio, which can 
            be used as a relative measurement of how well a set of 
            characteristics separates the classes. Using this separability 
            ratio, we thought to find an optimal set of characteristics (and 
            weights for those characteristics) with which to compare and 
            evaluate terrain height fields.
          </para>
          <para>
            While this approach initially showed some promise, it turned out to 
            have some serious problems. The fatal flaw with using FLD is that 
            it solves the wrong problem: it produces the combination of 
            characteristics that <emphasis>show the biggest 
              difference</emphasis> between the terrain types in the library.  
            This has the effect of ignoring characteristics that all terrain  
            types have in common, even if those characteristics turn out to be 
            important for producing that terrain type. What we actually want is 
            the set of characteristics that <emphasis>most strongly 
              characterize</emphasis> each terrain type—this set might be 
            different for each terrain type. Given a terrain height field, FLD 
            would be useful for helping to answer the question "To which of 
            terrain type does it most likely belong?", whereas the 
            <emphasis>real</emphasis> question we want to answer is "How much 
            like its reference terrain type is it?".
          </para>
          <para>
            A strange consequence of using a similarity function based on FLD 
            is that the similarity between two height fields of the same 
            terrain type cannot be determined <emphasis>except through 
              opposition to every other terrain type</emphasis>. This is wildly 
            counter-intuitive: adding new terrain types or adding new examples 
            to an existing terrain type should have no effect on the 
            <emphasis>other</emphasis> terrain types.
          </para>
          <para>
            Related to this, in order for an FLD-based similarity function to 
            work, all terrain types must be significantly different from one 
            another. This places an extra burden on the user: he must ensure, 
            not only that the examples in each terrain type are similar to each 
            other, but also that they are different from all of the other 
            terrain types. Furthermore, such a similarity function is 
            conceptually opposite to what is really wanted: a classifier-based 
            system attempts to maximize separability; that is, 
            <emphasis>differences</emphasis> between terrain types are made more 
            important than the <emphasis>similarities</emphasis> within a 
            terrain type.
          </para>
          <para>
            A final problem with FLD is that it requires a significant number 
            of examples in each class to work (if there are too few samples, a 
            matrix becomes singular and thus cannot be inverted). As the number 
            of characteristics under consideration increases, the requisite 
            number of examples increases as well. Because of this, FLD is not a 
            good candidate for a similarity fitness function: it doesn't work 
            at all with too few samples.
          </para>
        </section>

        <section>
          <title>Histogram Aggregation</title>
          <para>
            A fourth approach, which bears a stronger resemblance to the
            similarity function we ultimately used, but still turned out to be
            fatally flawed was to create one giant, terrain-type-wide
            <firstterm>super histogram</firstterm> (<xref linkend="Super Histogram"/>) for each statistic (e.g., elevation, slope) used in
            the comparison.  These would be computed by adding together the
            individual histograms from each sample in the terrain type, and
            normalizing the super histogram to have an area of 1.  In theory
            this composite histogram would be smoother than those of the
            individual examples, and would better represent the terrain type as
            a whole.  Then, to evaluate the similarity of a generated height
            field to this terrain type, one need only calculate the RMS
            difference between the height field's normalized histogram and the
            terrain type's super histogram.
          </para>
          <para>
            While this idea led to the similarity function described earlier, it 
            has several problems. The first problem is the difficulty of 
            combining histograms with different bucket sizes, though this might 
            be solved by resampling the histogram. The more serious problem is 
            that, unless the distribution means are very close, the resulting 
            super histogram will be multi-modal. Obviously, such a distribution 
            will not compare well to the (usually) unimodal distributions that 
            produced it.
          </para>
          <figure id="Super Histogram" float="0">
            <title>A "Super Histogram"</title>
            <caption>
              Concatenating the histograms of multiple terrain samples turned 
              out to be a fatally flawed approach.
            </caption>
            <mediaobject>
              <imageobject>
                <imagedata fileref="Super Histogram.svg"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>

      </section>
    </section>
  </section>

  <section>
    <title>Height Field Construction</title>
    <para>
      The height field construction algorithm is able to create a reasonably 
      good imitation of the example terrains given to it, providing a 
      computationally-expensive, but low effort means of generating terrain.
    </para>

    <section id="Runtime Complexity">
      <title>Performance of the GA</title>
      <para>
        The height field GA is, without a doubt, the most computationally 
        intensive part of the application. As the LOD increases, so does the 
        computation time (see <xref linkend="Running Times Table"/>).
      </para>
      <table id="Running Times Table">
        <title>Height field generation running times</title>
        <tgroup cols="2" align="left">
          <colspec colname="Level of Detail"/>
          <colspec colname="Generation Time"/>
          <thead>
            <row>
              <entry>LOD</entry>
              <entry>Time (s)</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>270m</entry>
              <entry>40 s</entry>
            </row>
            <row>
              <entry>90m</entry>
              <entry>270 s</entry>
            </row>
            <row>
              <entry>30m</entry>
              <entry>2070 s</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
        These numbers are for one run on a 1.2 GHz Pentium III with 256 MB of 
        RAM.  The running time ratios between successive LODs are unsurprising:   
        each successive LOD takes between 6 and 8 times as long as the one 
        before. The GA itself (ignoring the fitness function) is linear in the 
        number of genes in a chromosome.  Similarly,the fitness function is 
        linear in the number of pixels in the height field. Since each 
        successive LOD is approximately 9 times larger than the previous, it 
        makes sense that the running times would scale similarly.
      </para>
      <para>
        Obviously, scalability is an issue with this algorithm. As it is now, 
        the 30m LOD is at least reachable. Unfortunately, the 10m LOD can be 
        expected to take a 6 to 8 times as long again. Before the algorithm can 
        be pushed to these higher LODs, it must be accelerated somehow, whether 
        via a GPU implementation, or some other form of parallelism.
      </para>
    </section>

    <section>
      <title>Successfulness of the GA</title>
      <para>
        From the figures in this section, it is obvious that the algorithm 
        works fairly well, at least at the 270m (<xref linkend="Thirds Map Height Field (270m)"/>) and 90m (<xref linkend="Thirds Map Height Field (90m)"/>) LODs.  The terrain types bear a significant resemblance to 
        their reference examples, and the transitions between regions work well 
        too.  Unfortunately, when going to the 30m LOD (<xref linkend="Thirds Map Height Field (30m)"/>), this does not hold true.  According to 
        several GA researchers with whom I spoke at a recent conference on 
        evolutionary programming, as the size of the problem increases, the GA 
        population size should increase accordingly. This is problematic, as the 
        running time for the 30m LOD is already quite large.
      </para>

      <figure id="Thirds Map Height Field (270m)" float="0">
        <title>"Thirds" at 270m</title>
        <caption>
          At the 270m resolution, the terrain types display characteristically 
          different elevation patterns.
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="3.5in" fileref="Thirds Height Field - 270m.png"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure id="Thirds Map Height Field (90m)" float="0">
        <title>"Thirds" at 90m</title>
        <caption>
          At the 90m resolution, the terrain types still look fairly reasonable, 
          though it would be nice to see larger, more coherent features in the 
          hilly terrain (yellow).
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="3.5in" fileref="Thirds Height Field - 90m.png"/>
          </imageobject>
        </mediaobject>
      </figure>

      <figure id="Thirds Map Height Field (30m)" float="0">
        <title>"Thirds" at 30m</title>
        <caption>
          At the 30m resolution, the size of the terrain has exceeded the 
          ability of the GA to bring it all together.
        </caption>
        <mediaobject>
          <imageobject>
            <imagedata scalefit="1" width="3.5in" fileref="Thirds Height Field - 30m.png"/>
          </imageobject>
        </mediaobject>
      </figure>

      <para>
        Further research into tuning the GA parameters is likely to yield 
        better results; still, there are some other ways in which the 
        construction process could be improved as well. Probably the most 
        noticeable flaw in the 30m height field (<xref linkend="Thirds Map Height Field (30m)"/>) is the "tiling" effect visible in the flatter 
        areas. This effect can also be seen in the mountainous, yellow area, 
        though it is a bit less glaring due to the already rugged terrain in 
        that area. This effect is the result of the genes not aligning well 
        with one another. One possible way of dealing with this issue would be 
        to subdivide the genes into smaller patches (<inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/2x2.mml">
  <mn>2</mn>
  <mo>×</mo>
  <mn>2</mn>
</math>
                    </inlineequation> or <inlineequation>
                        <math xmlns="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" overflow="scroll" xml:base="resources/3x3.mml">
  <mn>3</mn>
  <mo>×</mo>
  <mn>3</mn>
</math>

</inlineequation> would be a good start) for the 
        purpose of calculating gene compatibility. This would yield a more 
        accurate estimate of the shape of a gene, and would hopefully lead to 
        finding genes that naturally fit well to the pattern height field, 
        which would reduce or eliminate the tiling effect.
      </para>
    </section>
  </section>

</chapter>
  <chapter id="Future Work" xml:base="future-work.xml">
  <title>Future Work</title>
  <para>
    While the results achieved with this method are respectable, numerous 
    extensions and improvements are possible, offering greater performance, a 
    higher degree of realism, greater ease of use, and/or additional control 
    over the generated terrain.
  </para>

  <section>
    <title>User Study</title>
    <para>
      One of the main objectives of this research has been to develop a method 
      of generating terrain that is easy and intuitive for a user to use. In 
      pursuit of this goal, I have had to make a number of judgments as to the 
      user-friendliness of particular aspects, armed primarily with my own 
      intuition as a user and creator of graphically-oriented software. While I 
      have some degree of experience using painting, illustration, modeling and 
      animation software, I am unquestionably more technically adept than the 
      average user of such software. Furthermore, as the programmer of 
      <citetitle>Terrainosaurus</citetitle>, I have the luxury/handicap of 
      knowing all the details of its implementation. Hence, it would be 
      beneficial to evaluate the effectiveness of 
      <citetitle>Terrainosaurus</citetitle> with groups of professional 3D 
      artists, architects, and simulation/game designers to see how effectively 
      they are able to use it, what features they like, and what features they 
      find to be either constraining or conspicuously absent.
    </para>
  </section>

  <section>
    <title>Placement of Features</title>
    <para>
      In <citetitle>Terrainosaurus</citetitle>, the user's control over the 
      design of his terrain is region-based: all user modifications to the 
      shape of the terrain are made through creating regions of various shapes 
      and sizes, and assigning terrain types to them.  If the user wants a 
      finer degree of control over one area of the map, he creates smaller 
      regions and/or a finer taxonomy of terrain types. This works well enough 
      for exercising fine control over the size and shape of regions, and the 
      spatial relationships between them, but is less effective at guaranteeing 
      the presence of particular features (e.g., rivers, volcanoes, cliffs etc.) 
      in the places the user wants them.
    </para>
    <para>
      A very useful extension to this method would be to allow the user to 
      specify the geometric attributes of particular features (e.g., the path 
      of a river, the location and elevation of a mountain peak, etc.) during 
      the design phase. In the generation phase, these feature specifications 
      would impose additional, localized constraints for the GA to meet, and 
      would influence or override the shape of the generated terrain in that 
      area. Such an extension would provide the user a whole new level of 
      control over the generation process, with no necessary increase in 
      complexity (if the user doesn't care about the placement of specific 
      features, he can simply not use that extension; then the terrain 
      generation process is no different than described above).
    </para>
    <para>
      There are at least two challenges in creating such an extension. First, 
      the definition of what constitutes a "feature" in this context is a bit 
      hazy. How large of an area around a user-placed mountain peak should be 
      considered "the mountain"? And what sort of data structure should be used 
      to represent the "feature"? One possibility is to let features be areas 
      (not necessarily rectangular) of height field data isolated from the input 
      terrain samples. This has the benefit of providing a natural relationship 
      between the identified features and the terrain types in which they 
      occur, but it is not clear how this would encompass features like rivers 
      (since they can be of arbitrary length).
    </para>
    <para>
      Besides the difficulty of defining and representing distinct features, 
      there is also the problem of maintaining physically correct relationships 
      in the vicinity of these features. For example, if the user places a 
      cliff or a waterfall in a particular location, then it becomes necessary 
      to ensure that the area "above" that cliff/waterfall has a higher 
      elevation than the ground "below" the feature. Or, to give another 
      example, when placing rivers, it may be necessary to create lakes or cut 
      gorges in order to maintain the constraint that a river can never flow 
      uphill.
    </para>
    <para>
      Both of these challenges suggest that terrain synthesis using  
      individually placed features may add a significant amount of complexity 
      to the generation process. A good first step toward understanding this 
      problem might be to identify a representative set of features (mountains,  
      rivers, gorges, waterfalls, alluvial fans, cliffs, etc.) and to analyze 
      the geometric "environment" in which each feature can exist. This might 
      give some insight into how to represent a feature and how to incorporate its 
      constraints into the generation process.
    </para>
  </section>

  <section>
    <title>Automatic Map Construction</title>
    <para>
      In the usual case, a user of <citetitle>Terrainosaurus</citetitle> will 
      want to exercise control over the general layout of the terrain, so 
      leaving the layout of the terrain type map in the hands of the user makes 
      a lot of sense.  Nevertheless, there are cases in which it would be useful 
      to be able to create a plausible map automatically, such as a game engine 
      creating random worlds, or an artist looking for inspiration. Therefore, 
      some sort of higher-level mechanism for automatic map construction 
      (possibly another GA), could be a useful extension.
    </para>
  </section>

  <section>
    <title>Automatic Generation of Textures &amp; Objects</title>
    <para>
      As lovely as the terrains generated by <citetitle>Terrainosaurus</citetitle> are, they are a bit 
      lacking in visual realism without appropriate textures and objects.  
      Without these sorts of visual cues, the illusion of "the real world" will  
      never be complete. Thus, an important companion task to the generation of 
      the landscape is the synthesis and placement of realistic textures and 
      objects.
    </para>
    <para>
      Although the generated terrain model could be textured in a number of 
      ways, ideally we would like to be able to texture the generated model 
      automatically, using the geometry of the height field and the terrain-type 
      map to guide the process. A genetic algorithm approach similar to that 
      employed for generating the height field might be very successful at 
      generating believable textures.  Taking this idea a bit further, the 
      placement of three-dimensional objects (such as natural objects like 
      rocks and trees, or man-made objects like bridges and houses) could also 
      be automated. By taking the geometry and terrain type into account, more 
      realistic results could be achieved (e.g., trees should not be placed 
      above the treeline elevation, houses built on swamp land could be built 
      on stilts).
    </para>
  </section>

  <section id="Computer-aided Classification">
    <title>Computer-aided Terrain Classification &amp; Segmentation</title>
    <para>
      Currently, the most tedious and error-prone part of this approach is the 
      construction of the terrain type library: the process is completely 
      dependent on a human to classify terrain samples correctly, and also 
      requires the person doing the classification to avoid samples containing 
      mixtures of terrain types (such as lakes, seashore, etc.).
    </para>
    <para>
      A useful extension would be to incorporate the feature analysis into this 
      earlier stage as well. The computer could analyze new terrain samples as 
      they are being added, compare them to those already present in the 
      library, and inform the user of how similar it is to those already in the 
      library, and how a particular classification of the sample would affect 
      the aggregate statistics that control the similarity function (i.e., 
      would adding this terrain to the "mountains" category significantly 
      diminish the agreement between "mountains" examples?). This information 
      could help the user to make a better decision in classifying the 
      sample.
    </para>
    <para>
      Ideally, the terrain library would be able to admit any height field as a 
      terrain sample. As discussed in <xref linkend="Classifying Well"/>, 
      terrain samples containing multiple terrain types, are currently unusable. 
      In order to make them usable, the terrain library needs to handle 
      non-rectangular sub-regions of the height field, allowing a terrain sample 
      to be segmented into its constitutent terrain types. Some of this can be 
      done automatically (since a body of water has constant elevation, the 
      computer should be able to segment water from non-water quite easily), 
      but segmenting other types of terrain would require fuzzy boundaries and 
      more sophisticated segmentation algorithms. Perhaps an adaptation of the 
      user-initiated classification procedure described in Gill's paper on ice 
      classification <xref xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:svg="http://www.w3.org/2000/svg" linkend="Ice Cover Discrimination"/> would be 
      effective for this.
    </para>
  </section>

  <section>
    <title>Terrain Type Interpolation</title>
    <para>
      Some types of terrain occur only near certain other types. For example, 
      it would be unusual to find sandy terrain in the middle of a grassy plain 
      (unless it's a golf course). On the other hand, sandy beaches are 
      ubiquitous near the ocean. Terrain types such as this could be viewed as 
      <firstterm>transitionary</firstterm> types and could be introduced 
      automatically near the user-generated regions of the neighboring terrain 
      type. So, for example, the user could create a region of "plains" 
      adjacent to "mountains" and the height field construction algorithm would 
      introduce some "mountain foothills" around the boundary between them.
    </para>
  </section>

  <section>
    <title>More Intelligent Construction of the Base LOD</title>
    <para>
      One weakness of <citetitle>Terrainosaurus</citetitle>, in the normal case where multiple terrain 
      types are present in the map, is that the algorithm for constructing the 
      coarsest LOD is rather naive: a simple copy-and-paste operation with 
      blending near the seams to prevent sharp drops. This can have a 
      disconcerting, unrealistic effect when the mean elevations are 
      significantly different. A more intelligent means of constructing this 
      initial LOD could eliminate this problem.
    </para>
  </section>

  <section id="Enhanced Similarity Function">
    <title>Enhanced Similarity Function</title>
    <para>
      The current fitness function evaluates generated terrain regions for 
      similarity to the reference terrain type by comparing a few of the more 
      obvious characteristics of terrain. There must be other characteristics 
      that could be incorporated to give additional discriminating power to the 
      similarity function and thus improve the quality of the generated 
      terrains. Some ideas for future investigation are:
      <itemizedlist spacing="compact">
        <listitem>
          the spatial "density" of features—how close together they 
          typically occur, how "clumped" they are
        </listitem>
        <listitem>
          the distance to the terrain type boundary—how far from the 
          transition between terrain types certain features typically occur 
          (e.g., we would expect a mountain peak of any significant size to 
          occur towards the interior of a mountainous region)
        </listitem>
        <listitem>
          "directionality" of features—to what extent certain features 
          exhibit the same directional tendency; this might be necessary to 
          reproduce terrains strongly affected by wind erosion, for example
        </listitem>
        <listitem>
          frequency-spectrum information—though direct comparison of Fourier 
          transform coefficients did not yield useful results (<xref linkend="Failures"/>), it may be that a more 
          sophisticated frequency analysis would do so
        </listitem>
        <listitem>
          higher-order derivatives of the surface—how the curvature varies 
          across the terrain surface
        </listitem>
      </itemizedlist>
    </para>
  </section>

  <section>
    <title>Cross-LOD Analysis</title>
    <para>
      The iterative, multi-LOD height field generation approach used in 
      <citetitle>Terrainosaurus</citetitle> is based on the observation that different features become 
      visible at different scales. Hence, it is reasonable to consider them as 
      "belonging" to different LODs and generate them accordingly. No attempt 
      has been made, however, to look for relationships between features at 
      different LODs. It might be, for example, that fine-scale ridges tend to 
      occur nearby and perpendicular to larger-scale ridges in certain types of 
      mountain ranges. It seems likely that there would be many relationships 
      of this sort that could be exploited to achieve more believable terrain 
      models, though how to discover and apply these relationships is unclear.
    </para>
  </section>

  <section>
    <title>Enhanced Mutation &amp; Crossover Operators</title>
    <para>
      In conjunction with a better terrain similarity function, it would also 
      be nice to have some smarter mutation and crossover operators. One way in 
      which the operators might be made more intelligent is with regard to the 
      formation of features in the terrain. Rather than naively copying 
      rectangular regions, a crossover operator could copy contiguous genes 
      that span an identified feature. Similarly, a mutation operator might push 
      the source coordinates for a gene closer to or further from a feature 
      detected in the source height field, in an attempt to find more plausible 
      source material, given the state of features forming in the generated 
      height field.
    </para>
  </section>

  <section id="Performance Improvements">
    <title>Performance Improvements</title>
    <para>
      Unfortunately, the height field generation phase is a bit on the slow 
      side. This is partially attributable to the use of a genetic algorithm, 
      but there are also other areas of the process that contribute to its 
      slowness.
    </para>
    <para>
      The use of a genetic algorithm in the height field generation process has 
      certain benefits, such as the enormous amount of flexibility it affords, 
      but is not without its drawbacks. The most obvious of these is its runtime 
      complexity, as discussed in <xref linkend="Runtime Complexity"/>. It might 
      be possible to achieve similar results using a different, more efficient  
      optimization algorithm (though doing so might preclude the implementation 
      of some of the other improvements described above).
    </para>
    <para>
      The most CPU-intensive part of the fitness analysis is the feature 
      detection step; scale-space feature detection is a rather expensive 
      operation. A useful topic for future research would be to investigate how 
      the diagnostic power of the feature detector changes as the range and 
      number of scales searched decreases. Because the terrain construction 
      process focuses at each step on generating detail at a particular LOD (the 
      detail at coarser LODs is already essentially fixed, and the detail at 
      finer LODs does not exist yet), it might even be that a single-scale 
      detector could perform as well as or better than a multi-scale detector.
    </para>
    <para>
      Another aspect of the algorithm with a lot of potential for optimization 
      is its inherent parallelizability. A large proportion of the computations 
      performed during the height field generation algorithm are done once per 
      element (whether an "element" is a pixel, a height field cell, or a gene), 
      with relatively few conditional branches and data dependencies, and so 
      might be able to benefit from a symmetric multiprocessing system, or 
      better yet, implementation on a modern GPU. The large memory sizes and 
      programmability features of recent GPU architectures suggest that it 
      might be possible to run large parts of the construction algorithm 
      entirely on the GPU.
    </para>
  </section>

</chapter>
  <chapter id="Conclusion" xml:base="conclusion.xml">
  <title>Conclusion</title>
  <para>
    Terrain generation is a topic of interest to practitioners in a number of 
    fields, some of which are entertainment- and art-related, with others being 
    more utilitarian in nature. This topic has received significantly less 
    treatment in the literature than has the related topic of real-time terrain 
    visualization. Terrain generation methods currently in practice are usually  
    fractal in nature, and are often difficult to control.
  </para>
  <para>
    <citetitle>Terrainosaurus</citetitle> is a new, user-friendly method of 
    generating an effectively unlimited diversity of 3D terrain models. It 
    differs from current state-of-the-art methods for terrain generation in a 
    number of ways, in particular:
    <itemizedlist>
      <listitem>
        it uses user-provided, real-world elevation data as raw material.  
        Because of this, a user can extend the capabilities of the system 
        without changing the fundamental algorithm, simply by adding examples of 
        new types of terrain.
      </listitem>
      <listitem>
        it follows a user-centric design paradigm, where types of terrain are 
        described by example, and the desired arrangement of these terrain types 
        is specified in an intuitive manner (i.e., by drawing a map). In this 
        paradigm, the user is freed from nearly all of the manual labor that 
        characterizes manual "sculpting" methods for height field creation, and 
        is not required to learn esoteric skills in order to get a desired 
        result, as in many procedural methods.
      </listitem>
      <listitem>
        it uses artificial intelligence techniques, specifically genetic 
        algorithms, to generate a height field approximating the user's design 
        and manifesting the appropriate terrain characteristics in each distinct 
        region. To my knowledge, this is the first significant attempt to apply 
        artificial intelligence techniques to the problem of terrain 
        generation.
      </listitem>
    </itemizedlist>
  </para>
  <para>
    The second contribution of <citetitle>Terrainosaurus</citetitle> is a 
    paradigm for terrain generation in which the user is freed from almost all 
    of the burden of constructing the terrain, while at the same time still 
    retaining some control over the shape of the terrain. All of the inputs 
    expected of the user are intuitive to grasp. Furthermore, it is not 
    necessary for the user to understand how 
    <citetitle>Terrainosaurus</citetitle> works in order to use it effectively.  
    These characteristics will become increasingly important in the future as 
    the scale of virtual worlds continues to increase—development teams 
    simply will not have the time to design the terrain manually.
  </para>
  <para>
    The third contribution of <citetitle>Terrainosaurus</citetitle> is a new 
    method of performing approximate comparisons of terrain height fields using 
    a variation on statistical distribution matching. This comparison method is 
    adaptive, is not highly sensitive to differences in the size or shape of 
    the terrains being compared, and has a built-in measure of how well it is 
    performing in any given case.
  </para>
  <para>
    <citetitle>Terrainosaurus</citetitle>, while not as trivial to implement as 
    more simplistic algorithms, could be of enormous use in a studio authoring 
    environment, especially when integrated with 3D modeling tools for manual 
    fine-tuning. Towards this end, it would be useful to implement this 
    algorithm as a plugin for one or more currently popular 3D modeling 
    packages.
  </para>
  <para>
    Obviously, terrain generation is not yet a solved problem. The positive 
    results produced by <citetitle>Terrainosaurus</citetitle> suggest that even 
    more promising results will emerge with additional research. It is my 
    belief that future research in this field ought to pursue a course similar 
    to <citetitle>Terrainosaurus</citetitle>'s—the use of artificial 
    intelligence techniques seems a promising road (and perhaps the 
    <emphasis>most</emphasis> promising) for doing terrain generation in a way 
    that is both realistic and user-friendly.
  </para>
</chapter>

  
  <bibliography label="References" xml:base="references.xml">
<title>References</title>
<biblioentry id="Winged Edge">
<abbrev>Baumgart 1975</abbrev>
<title>Winged Edge Polyhedron Representation for Computer Vision</title>
<author>
      <surname>Baumgart</surname>
      <firstname>Bruce</firstname>
      <othername role="mi">G</othername>
    </author>
<confgroup>
      <conftitle>National Computer Conference</conftitle>
      <confsponsor>American Federation of Information Processing Societies (AFIPS)</confsponsor>
      <confdates>May 1975</confdates>
    </confgroup>
<bibliosource role="compilation">Proceedings of the 1975 National Computer Conference</bibliosource>
<publisher>
      <publishername>AFIPS Press</publishername>
      <address format="linespecific">
        <city>Arlington</city>
        <state>VA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>1975</pubdate>
<artpagenums>589–596</artpagenums>
</biblioentry>
<biblioentry id="Halo 2" role="software">
<abbrev>Bungie 2004</abbrev>
<title>Halo 2</title>
<corpauthor xreflabel="Bungie">Bungie Studios</corpauthor>
<publisher>
      <publishername>Microsoft Corporation</publishername>
      <address format="linespecific">
        <city>Redmond</city>
        <state>WA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2004</pubdate>
</biblioentry>
<biblioentry id="Area51" role="website">
<abbrev>Burke 1996</abbrev>
<title>Generating Terrain</title>
<author>
      <surname>Burke</surname>
      <firstname>Carl</firstname>
    </author>
<pubdate>1996</pubdate>
<bibliomisc role="url">http://www.geocities.com/Area51/6902/terrain.html</bibliomisc>
</biblioentry>
<biblioentry id="Algorithms" role="book">
<abbrev>Cormen et al. 2001</abbrev>
<title>Introduction to Algorithms, 2nd Ed.</title>
<authorgroup>
      <author>
        <surname>Cormen</surname>
        <firstname>Thomas</firstname>
        <othername role="mi">H</othername>
      </author>
      <author>
        <surname>Leiserson</surname>
        <firstname>Charles</firstname>
        <othername role="mi">E</othername>
      </author>
      <author>
        <surname>Rivest</surname>
        <firstname>Ronald</firstname>
        <othername role="mi">L</othername>
      </author>
      <author>
        <surname>Stein</surname>
        <firstname>Clifford</firstname>
      </author>
    </authorgroup>
<isbn>0-262-03293-7</isbn>
<publisher>
      <publishername>MIT Press</publishername>
      <address format="linespecific">
        <city>Cambridge</city>
        <state>MA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2001</pubdate>
</biblioentry>
<biblioentry id="Bryce 3D" role="software">
<abbrev>DAZ 2006</abbrev>
<title>Bryce 3D</title>
<corpauthor xreflabel="DAZ">DAZ Productions</corpauthor>
<publisher>
      <publishername>DAZ Productions</publishername>
      <address format="linespecific">
        <city>Draper</city>
        <state>UT</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.daz3d.com/program/bryce/</bibliomisc>
</biblioentry>
<biblioentry id="ROAM" role="proceedings">
<abbrev>Duchaineau et al. 1997</abbrev>
<title>ROAMing Terrain: Real-time Optimally Adapting Meshes</title>
<authorgroup>
      <author>
        <surname>Duchaineau</surname>
        <firstname>Mark</firstname>
      </author>
      <author>
        <surname>Wolinsky</surname>
        <firstname>Murray</firstname>
      </author>
      <author>
        <surname>Sigeti</surname>
        <firstname>David</firstname>
        <othername role="mi">E</othername>
      </author>
      <author>
        <surname>Miller</surname>
        <firstname>Mark</firstname>
        <othername role="mi">C</othername>
      </author>
      <author>
        <surname>Aldrich</surname>
        <firstname>Charles</firstname>
      </author>
      <author>
        <surname>Mineev-Weinstein</surname>
        <firstname>Mark</firstname>
        <othername role="mi">B</othername>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>Visualization '97</conftitle>
      <confsponsor>IEEE</confsponsor>
    </confgroup>
<bibliosource role="compilation">Proceedings of IEEE Visualization '97</bibliosource>
<publisher>
      <publishername>IEEE Computer Society Press</publishername>
      <address format="linespecific">
        <city>Los Alamitos</city>
        <state>CA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>October, 1997</pubdate>
<artpagenums>81–88</artpagenums>
</biblioentry>
<biblioentry id="SimCity 4" role="software">
<abbrev>Electronic Arts 2003</abbrev>
<title>SimCity 4</title>
<corpauthor>Electronic Arts</corpauthor>
<publisher>
      <publishername>Electronic Arts</publishername>
    </publisher>
<pubdate>2003</pubdate>
<bibliomisc role="url">http://simcity.ea.com/</bibliomisc>
</biblioentry>
<biblioentry id="UT 2004" role="software">
<abbrev>Epic Games 2004</abbrev>
<title>Unreal Tournament 2004</title>
<corpauthor xreflabel="Epic Games">Epic Games, Inc</corpauthor>
<publisher>
      <publishername>Atari, Inc</publishername>
      <address format="linespecific">
        <city>Lyon</city>
        <country>France</country>
      </address>
    </publisher>
<pubdate>2004</pubdate>
<bibliomisc role="url">http://www.unrealtournament.com/</bibliomisc>
</biblioentry>
<biblioentry id="ArcGIS" role="software">
<abbrev>ESRI 2006</abbrev>
<title>ArcGIS</title>
<corpauthor>ESRI</corpauthor>
<publisher>
      <publishername>ESRI</publishername>
      <address format="linespecific">
        <city>Redlands</city>
        <state>CA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.esri.com/software/arcgis/</bibliomisc>
</biblioentry>
<biblioentry id="Lighthouse 3D" role="website">
<abbrev>Fernandez 2006</abbrev>
<title>Lighthouse 3D - Terrain Tutorial</title>
<author>
      <surname>Fernandez</surname>
      <firstname>António Ramires</firstname>
    </author>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.lighthouse3d.com/opengl/terrain/index.php3</bibliomisc>
</biblioentry>
<biblioentry id="MPD Method" role="journal">
<abbrev>Fournier et al. 1982</abbrev>
<title>Computer Rendering of Stochastic Models</title>
<authorgroup>
      <author>
        <surname>Fournier</surname>
        <firstname>Alain</firstname>
      </author>
      <author>
        <surname>Fussell</surname>
        <firstname>Don</firstname>
      </author>
      <author>
        <surname>Carpenter</surname>
        <firstname>Loren</firstname>
      </author>
    </authorgroup>
<bibliosource role="compilation">Communications of the ACM</bibliosource>
<volumenum>25</volumenum>
<issuenum>6</issuenum>
<publisher>
      <publishername>ACM Press</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>June, 1982</pubdate>
<artpagenums>371–384</artpagenums>
</biblioentry>
<biblioentry id="Spectral Synthesis" role="website">
<abbrev>Franke 2000</abbrev>
<title>Spectral Synthesis Noise for Creating Terrain</title>
<author>
      <surname>Franke</surname>
      <firstname>Scott</firstname>
    </author>
<bibliosource role="compilation">GameDev.net</bibliosource>
<publisher>
      <publishername>GameDev.net</publishername>
    </publisher>
<pubdate>January 1, 2000</pubdate>
<bibliomisc role="url">http://www.gamedev.net/reference/articles/article900.asp</bibliomisc>
</biblioentry>
<biblioentry id="FFTW" role="software">
<abbrev>Friggo &amp; Johnson 2003</abbrev>
<title>FFTW: The Fastest Fourier Transform in the West, Version 3</title>
<authorgroup>
      <author>
        <surname>Friggo</surname>
        <firstname>Matteo</firstname>
      </author>
      <author>
        <surname>Johnson</surname>
        <firstname>Steven</firstname>
        <othername role="mi">G</othername>
      </author>
    </authorgroup>
<publisher>
      <publishername>Massachusetts Institute of Technology</publishername>
      <address format="linespecific">
        <city>Cambridge</city>
        <state>MA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>April, 2003</pubdate>
<bibliomisc role="url">http://www.fftw.org/</bibliomisc>
</biblioentry>
<biblioentry id="Positive Wavelet">
<abbrev>Gallant &amp; Hutchinson 1996</abbrev>
<title>Towards an Understanding of Landscape Scale and Structure</title>
<authorgroup>
      <author>
        <surname>Gallant</surname>
        <firstname>John</firstname>
        <othername role="mi">C</othername>
      </author>
      <author>
        <surname>Hutchinson</surname>
        <firstname>Michael</firstname>
        <othername role="mi">F</othername>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>Third International Conference/Workshop on Integrating GIS and Environmental Modeling</conftitle>
      <confsponsor>National Center for Geographic Information and Analysis</confsponsor>
      <confdates>January 21–25, 1996</confdates>
    </confgroup>
<bibliosource role="compilation">Proceedings of the Third International Conference/Workshop on Integrating GIS and Environmental Modeling</bibliosource>
<publisher>
      <publishername>National Center for Geographic Information and Analysis</publishername>
      <address format="linespecific">
        <city>Santa Barbara</city>
        <state>CA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>1996</pubdate>
<bibliomisc role="url">http://www.ncgia.ucsb.edu/conf/SANTA_FE_CD-ROM/sf_papers/gallant_john/paper.html</bibliomisc>
</biblioentry>
<biblioentry id="Gamasutra" role="website">
<abbrev>Gamasutra 2006</abbrev>
<title>Gamasutra: The Art &amp; Business of Making Games</title>
<corpauthor>Gamasutra</corpauthor>
<publisher>
      <publishername>CMP Media LLC</publishername>
      <address format="linespecific">
        <city>San Francisco</city>
        <state>CA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.gamasutra.com/</bibliomisc>
</biblioentry>
<biblioentry id="NeHe" role="website">
<abbrev>GameDev.net 2006</abbrev>
<title>NeHe Productions</title>
<publisher>
      <publishername>GameDev.net</publishername>
    </publisher>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://nehe.gamedev.net/</bibliomisc>
</biblioentry>
<biblioentry id="Ice Cover Discrimination">
<abbrev>Gill 2003</abbrev>
<title>SAR Surface Ice Cover Discrimination Using Distribution Matching</title>
<author>
      <surname>Gill</surname>
      <firstname>Rashpal</firstname>
      <othername role="mi">S</othername>
    </author>
<confgroup>
      <conftitle>POLinSAR 2003</conftitle>
      <confsponsor>European Space Agency</confsponsor>
      <confdates>January 14–16, 2003</confdates>
    </confgroup>
<pubdate>January 14, 2003</pubdate>
<bibliosource role="compilation">Proceedings of POLinSAR 2003</bibliosource>
<bibliomisc role="url">http://earth.esa.int/workshops/polinsar2003/pr.html</bibliomisc>
</biblioentry>
<biblioentry id="Pattern Recognition" role="website">
<abbrev>Gutierrez-Osuna 2004</abbrev>
<title>Lecture Notes: Course in Pattern Recognition</title>
<author>
      <surname>Gutierrez-Osuna</surname>
      <firstname>Ricardo</firstname>
    </author>
<publisher>
      <publishername>PRISM Group at Texas A&amp;M University</publishername>
      <address format="linespecific">
        <city>College Station</city>
        <state>TX</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2004</pubdate>
<bibliomisc role="url">http://research.cs.tamu.edu/prism/lectures.htm</bibliomisc>
</biblioentry>
<biblioentry id="Stream Erosion" role="proceedings">
<abbrev>Kelley et al. 1988</abbrev>
<title>Terrain Simulation Using a Model of Stream Erosion</title>
<authorgroup>
      <author>
        <surname>Kelley</surname>
        <firstname>Alex</firstname>
        <othername role="mi">D</othername>
      </author>
      <author>
        <surname>Malin</surname>
        <firstname>Michael</firstname>
        <othername role="mi">C</othername>
      </author>
      <author>
        <surname>Nielson</surname>
        <firstname>Gregory</firstname>
        <othername role="mi">M</othername>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>SIGGRAPH '88</conftitle>
      <confsponsor>ACM</confsponsor>
    </confgroup>
<bibliosource role="compilation">Proceedings of SIGGRAPH '88</bibliosource>
<publisher>
      <publishername>ACM Press</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>June 1988</pubdate>
<artpagenums>263–268</artpagenums>
</biblioentry>
<biblioentry id="Scale-space Blob">
    <abbrev>Lindeberg 1998,1</abbrev>
    <title>Feature Detection with Automatic Scale Selection</title>
    <author>
      <surname>Lindeberg</surname>
      <firstname>Tony</firstname>
    </author>
    <bibliosource role="compilation">International Journal of Computer Vision</bibliosource>
    <volumenum>30</volumenum>
    <issuenum>2</issuenum>
    <publisher>
      <publishername>Springer</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
    <pubdate>August 1998</pubdate>
    <artpagenums>77–116</artpagenums>
    <bibliomisc role="url">ftp://ftp.nada.kth.se/CVAP/reports/cvap198.pdf</bibliomisc>
  </biblioentry>
<biblioentry id="Scale-space Edge/Ridge">
    <abbrev>Lindeberg 1998,2</abbrev>
    <title>Edge Detection and Ridge Detection with Automatic Scale Selection</title>
    <author>
      <surname>Lindeberg</surname>
      <firstname>Tony</firstname>
    </author>
    <bibliosource role="compilation">International Journal of Computer Vision</bibliosource>
    <volumenum>30</volumenum>
    <issuenum>2</issuenum>
    <publisher>
      <publishername>Springer</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
    <pubdate>August 1998</pubdate>
    <artpagenums>117–154</artpagenums>
    <bibliomisc role="url">ftp://ftp.nada.kth.se/CVAP/reports/cvap191.pdf</bibliomisc>
  </biblioentry>
<biblioentry id="Feature-based CLOD" role="proceedings">
<abbrev>Li et al. 2003</abbrev>
<title>Feature-based Visibility-driven CLOD for Terrain</title>
<authorgroup>
      <author>
        <surname>Li</surname>
        <firstname>Sheng</firstname>
      </author>
      <author>
        <surname>Liu</surname>
        <firstname>Xuehui</firstname>
      </author>
      <author>
        <surname>Wu</surname>
        <firstname>Enhua</firstname>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>Pacific Graphics 2003</conftitle>
    </confgroup>
<bibliosource role="compilation">Proceedings of Pacific Graphics 2003</bibliosource>
<publisher>
      <publishername>IEEE Computer Society Press</publishername>
      <address format="linespecific">
        <city>Los Alamitos</city>
        <state>CA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>October, 2003</pubdate>
<artpagenums>313–322</artpagenums>
</biblioentry>
<biblioentry id="Geometry Clipmaps" role="proceedings">
<abbrev>Losasso &amp; Hoppe 2004</abbrev>
<title>Geometry Clipmaps: Terrain Rendering Using Nested Regular Grids</title>
<authorgroup>
      <author>
        <surname>Losasso</surname>
        <firstname>Frank</firstname>
      </author>
      <author>
        <surname>Hoppe</surname>
        <firstname>Hugues</firstname>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>SIGGRAPH 2004</conftitle>
      <confsponsor>ACM</confsponsor>
    </confgroup>
<bibliosource role="compilation">Proceedings of SIGGRAPH 2004</bibliosource>
<publisher>
      <publishername>ACM Press</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>August, 2004</pubdate>
<artpagenums>769–776</artpagenums>
</biblioentry>
<biblioentry id="Mandelbrot" role="book">
<abbrev>Mandelbrot 1982</abbrev>
<title>The Fractal Geometry of Nature</title>
<author>
      <surname>Mandelbrot</surname>
      <firstname>Benoit</firstname>
    </author>
<publisher>
      <publishername>W. H. Freeman</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>August 15, 1982</pubdate>
</biblioentry>
<biblioentry id="Procedure Models" role="proceedings">
<abbrev>Marshall et al. 1980</abbrev>
<title>Procedure Models for Generating Three-Dimensional Terrain</title>
<authorgroup>
      <author>
        <surname>Marshall</surname>
        <firstname>Robert</firstname>
      </author>
      <author>
        <surname>Wilson</surname>
        <firstname>Rodger</firstname>
      </author>
      <author>
        <surname>Carlson</surname>
        <firstname>Wayne</firstname>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>SIGGRAPH '80</conftitle>
      <confsponsor>ACM SIGGRAPH</confsponsor>
      <confdates>July, 1980</confdates>
    </confgroup>
<bibliosource role="compilation">Proceedings of SIGGRAPH '80</bibliosource>
<publisher>
      <publishername>ACM Press</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>July, 1980</pubdate>
<artpagenums>154–162</artpagenums>
</biblioentry>
<biblioentry id="FS 2004" role="software">
<abbrev>Microsoft Game Studios 2004</abbrev>
<title>Flight Simulator 2004</title>
<corpauthor>Microsoft Game Studios</corpauthor>
<publisher>
      <publishername>Microsoft Corporation</publishername>
      <address format="linespecific">
        <city>Redmond</city>
        <state>WA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2004</pubdate>
<bibliomisc role="url">http://www.microsoft.com/games/flightsimulator/</bibliomisc>
</biblioentry>
<biblioentry id="Eroded Fractal Terrains" role="proceedings">
<abbrev>Musgrave et al. 1989</abbrev>
<title>The Synthesis and Rendering of Eroded Fractal Terrains</title>
<authorgroup>
      <author>
        <surname>Musgrave</surname>
        <firstname>F</firstname>
        <othername role="mi">Kenton</othername>
      </author>
      <author>
        <surname>Kolb</surname>
        <firstname>Craig</firstname>
        <othername role="mi">E</othername>
      </author>
      <author>
        <surname>Mace</surname>
        <firstname>Robert</firstname>
        <othername role="mi">S</othername>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>SIGGRAPH '89</conftitle>
      <confsponsor>ACM</confsponsor>
    </confgroup>
<bibliosource role="compilation">Proceedings of SIGGRAPH '89</bibliosource>
<publisher>
      <publishername>ACM Press</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>July, 1989</pubdate>
<artpagenums>41–50</artpagenums>
</biblioentry>
<biblioentry id="Genetic Algorithms" role="proceedings">
<abbrev>Obitko &amp; Skavík 1999</abbrev>
<title>Visualization of Genetic Algorithms in a Learning Environment</title>
<authorgroup>
      <author>
        <surname>Obitko</surname>
        <firstname>Marek</firstname>
      </author>
      <author>
        <surname>Skavík</surname>
        <firstname>Pavel</firstname>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>Spring Conference on Computer Graphics '99</conftitle>
    </confgroup>
<bibliosource role="compilation">Proceedings of Spring Conference on Computer Graphics '99</bibliosource>
<publisher>
      <publishername>Comenius University</publishername>
      <address format="linespecific">
        <city>Bratislava</city>
        <country>Slovakia</country>
      </address>
    </publisher>
<pubdate>1999</pubdate>
<artpagenums>101–106</artpagenums>
</biblioentry>
<biblioentry id="TIN">
<abbrev>Pajarola et al. 2002</abbrev>
<title>QuadTIN: Quadress-based Triangulated Irregular Networks</title>
<authorgroup>
      <author>
        <surname>Pajarola</surname>
        <firstname>Renato</firstname>
      </author>
      <author>
        <surname>Antonijuan</surname>
        <firstname>Marc</firstname>
      </author>
      <author>
        <surname>Lario</surname>
        <firstname>Roberto</firstname>
      </author>
    </authorgroup>
<bibliosource role="compilation">Proceedings of IEEE Visualization 2002</bibliosource>
<confgroup>
      <conftitle>Visualization 2002</conftitle>
      <confsponsor>IEEE</confsponsor>
      <confdates>2002</confdates>
    </confgroup>
<publisher>
      <publishername>IEEE Computer Society Press</publishername>
      <address format="linespecific">
        <city>Los Alamitos</city>
        <state>CA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2002</pubdate>
<artpagenums>395-402</artpagenums>
</biblioentry>
<biblioentry id="MojoWorld" role="software">
<abbrev>Pandromeda 2004</abbrev>
<title>MojoWorld</title>
<corpauthor xreflabel="Pandromeda">Pandromeda, Inc</corpauthor>
<publisher>
      <publishername>Pandromeda, Inc</publishername>
      <address format="linespecific">
        <city>New Creek</city>
        <state>WV</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2004</pubdate>
<bibliomisc role="url">http://www.pandromeda.com/</bibliomisc>
</biblioentry>
<biblioentry id="Procedural Cities">
<abbrev>Parish &amp; Müller 2001</abbrev>
<title>Procedural Modeling of Cities</title>
<authorgroup>
      <author>
        <surname>Parish</surname>
        <firstname>Yoav</firstname>
      </author>
      <author>
        <surname>Müller</surname>
        <firstname>Pascal</firstname>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>International Conference on Computer Graphics and Interactive Techniques</conftitle>
      <confsponsor>ACM SIGGRAPH</confsponsor>
      <confdates>2001</confdates>
    </confgroup>
<bibliosource role="compilation">Proceedings of the 28th Annual Conference on Computer Graphics and Interactive Techniques</bibliosource>
<publisher>
      <publishername>ACM Press</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2001</pubdate>
<artpagenums>301–308</artpagenums>
</biblioentry>
<biblioentry id="ANTLR" role="software">
<abbrev>Parr 2006</abbrev>
<title>ANTLR: ANother Tool for Language Recognition</title>
<author>
      <surname>Parr</surname>
      <firstname>Terence</firstname>
    </author>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.antlr.org/</bibliomisc>
</biblioentry>
<biblioentry id="Combat Simulation" role="proceedings">
<abbrev>Parry 1997</abbrev>
<title>The Generation and Use of Parameterized Terrain in Land Combat Simulation</title>
<author>
      <surname>Parry</surname>
      <firstname>Sam</firstname>
      <othername role="mi">H</othername>
    </author>
<confgroup>
      <conftitle>Winter Simulation Conference '77</conftitle>
    </confgroup>
<bibliosource role="compilation">Proceedings of Winter Simulation Conference '77</bibliosource>
<pubdate>December, 1997</pubdate>
<artpagenums>422–431</artpagenums>
</biblioentry>
<biblioentry id="Wavelet Synthesis" role="tech-report">
<abbrev>Pelton &amp; Atkinson 2003</abbrev>
<title>Flexible Generation and Lightweight View-Dependent Rendering of Terrain</title>
<authorgroup>
      <author>
        <surname>Pelton</surname>
        <firstname>Blake</firstname>
      </author>
      <author>
        <surname>Atkinson</surname>
        <firstname>Darren</firstname>
        <othername role="mi">C</othername>
      </author>
    </authorgroup>
<bibliosource role="catalog">School of Engineering Technical Report COEN-2003-01-22</bibliosource>
<publisher>
      <publishername>Santa Clara University, Department of Computer Engineering</publishername>
      <address format="linespecific">
        <city>Santa Clara</city>
        <state>CA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>January, 2003</pubdate>
</biblioentry>
<biblioentry id="Perlin Noise">
<abbrev>Perlin 1996</abbrev>
<title>An Image Synthesizer</title>
<author>
      <surname>Perlin</surname>
      <firstname>Ken</firstname>
    </author>
<bibliosource role="compilation">Proceedings of SIGGRAPH '85</bibliosource>
<confgroup>
      <conftitle>SIGGRAPH '85</conftitle>
      <confsponsor>ACM SIGGRAPH</confsponsor>
      <confdates>January 21–25, 1996</confdates>
    </confgroup>
<publisher>
      <publishername>ACM Press</publishername>
      <address format="linespecific">
        <city>New York</city>
        <state>NY</state>
        <country>USA</country>
      </address>
    </publisher>
<artpagenums>287–296</artpagenums>
</biblioentry>
<biblioentry id="Terragen" role="software">
<abbrev>Planetside 2006</abbrev>
<title>Terragen</title>
<corpauthor xreflabel="Planetside">Planetside Software</corpauthor>
<publisher>
      <publishername>Planetside Software</publishername>
      <address format="linespecific">
        <city>Ellesmere Port</city>
        <state>Cheshire</state>
        <country>UK</country>
      </address>
    </publisher>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.planetside.co.uk/terragen/</bibliomisc>
</biblioentry>
<biblioentry id="Mountains and Rivers" role="proceedings">
<abbrev>Prusinkiewicz &amp; Hammel 1993</abbrev>
<title>A Fractal Model of Mountains with Rivers</title>
<authorgroup>
      <author>
        <surname>Prusinkiewicz</surname>
        <firstname>Przemyslaw</firstname>
      </author>
      <author>
        <surname>Hammel</surname>
        <firstname>Mark</firstname>
      </author>
    </authorgroup>
<confgroup>
      <conftitle>Graphics Interface '93</conftitle>
    </confgroup>
<bibliosource role="compilation">Proceedings of Graphics Interface '93</bibliosource>
<pubdate>May 1993</pubdate>
<artpagenums>174–180</artpagenums>
</biblioentry>
<biblioentry id="GeoCommunity" role="website">
<abbrev>Qlinks 2006</abbrev>
<title>Geo Community Website</title>
<corpauthor xreflabel="Qlinks">Qlinks Media Group</corpauthor>
<publisher>
      <publishername>Qlinks Media Group</publishername>
      <address format="linespecific">
        <city>Niceville</city>
        <state>FL</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.geocomm.com/</bibliomisc>
</biblioentry>
<biblioentry id="GDC 2002" role="website">
<abbrev>Sanchez-Crespo 2002</abbrev>
<title>Science Imitates Nature at GDC</title>
<author>
      <surname>Sanchez-Crespo</surname>
      <firstname>Daniel</firstname>
    </author>
<bibliosource role="compilation">Gamasutra.com</bibliosource>
<publisher>
      <publishername>CMP Media LLC</publishername>
      <address format="linespecific">
        <city>San Francisco</city>
        <state>CA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>March 23, 2002</pubdate>
<bibliomisc role="url">http://www.gamasutra.com/gdc2002/features/nature/nature_01.htm</bibliomisc>
</biblioentry>
<biblioentry id="World Machine" role="software">
<abbrev>Schmidt 2006</abbrev>
<title>World Machine</title>
<author>
      <surname>Schmidt</surname>
      <firstname>Stephen</firstname>
    </author>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.world-machine.com/</bibliomisc>
</biblioentry>
<biblioentry id="L3DT" role="software">
<abbrev>Torpy 2006</abbrev>
<title>L3DT</title>
<author>
      <surname>Torpy</surname>
      <firstname>Aaron</firstname>
    </author>
<publisher>
      <publishername>Bundysoft</publishername>
    </publisher>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.bundysoft.com/L3DT/</bibliomisc>
</biblioentry>
<biblioentry id="Chunked LOD" role="course-notes">
<abbrev>Ulrich 2002</abbrev>
<title>Rendering Massive Terrains Using Chunked Level of Detail Control</title>
<author>
      <surname>Ulrich</surname>
      <firstname>Thatcher</firstname>
    </author>
<confgroup>
      <conftitle>SIGGRAPH 2001</conftitle>
      <confsponsor>ACM</confsponsor>
    </confgroup>
<bibliosource role="compilation">Proceedings of SIGGRAPH 2001</bibliosource>
<pubdate>April 14, 2002</pubdate>
<bibliomisc role="url">http://cvs.sourceforge.net/viewcvs.py/*checkout*/tu-testbed/tu-testbed/docs/sig-notes.pdf?rev=HEAD</bibliomisc>
</biblioentry>
<biblioentry id="SDTS Specification" role="website">
<abbrev>USGS 2003</abbrev>
<title>The SDTS Document</title>
<corpauthor>USGS</corpauthor>
<editor>
      <surname>Rinehart</surname>
      <firstname>Robert</firstname>
    </editor>
<publisher>
      <publishername>United States Geological Survey</publishername>
      <address format="linespecific">
        <city>Reston</city>
        <state>VA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>September 11, 2003</pubdate>
<bibliomisc role="url">http://rockyweb.cr.usgs.gov/nmpstds/demstds.html</bibliomisc>
</biblioentry>
<biblioentry id="DEM Specification" role="website">
<abbrev>USGS 2003</abbrev>
<title>National Mapping Program Standards</title>
<corpauthor>USGS</corpauthor>
<publisher>
      <publishername>United States Geological Survey</publishername>
      <address format="linespecific">
        <city>Reston</city>
        <state>VA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>April 10, 2003</pubdate>
<bibliomisc role="url">http://rockyweb.cr.usgs.gov/nmpstds/demstds.html</bibliomisc>
</biblioentry>
<biblioentry id="USGS Maps" role="website">
<abbrev>USGS 2004</abbrev>
<title>USGS Seamless Data Distribution</title>
<corpauthor>USGS</corpauthor>
<publisher>
      <publishername>United States Geological Survey</publishername>
      <address format="linespecific">
        <city>Reston</city>
        <state>VA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>April 14, 2004</pubdate>
<bibliomisc role="url">http://gisdata.usgs.net/Website/Seamless/viewer.php</bibliomisc>
</biblioentry>
<biblioentry id="USGS" role="website">
<abbrev>USGS 2006</abbrev>
<title>USGS Website</title>
<corpauthor>USGS</corpauthor>
<publisher>
      <publishername>United States Geological Survey</publishername>
      <address format="linespecific">
        <city>Reston</city>
        <state>VA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.usgs.gov/</bibliomisc>
</biblioentry>
<biblioentry id="Erosion 3D" role="software">
<abbrev>von Werner 1996</abbrev>
<title>Erosion 3D</title>
<author>
      <surname>von Werner</surname>
      <firstname>Michael</firstname>
    </author>
<publisher>
      <publishername>Institut für Geographische Wissenschaften</publishername>
      <address format="linespecific">
        <city>Berlin</city>
        <country>Germany</country>
      </address>
    </publisher>
<pubdate>1996</pubdate>
<bibliomisc role="url">http://www.geog.fu-berlin.de/~erosion/</bibliomisc>
</biblioentry>
<biblioentry id="VTP" role="software">
<abbrev>VTP 2006</abbrev>
<title>The Virtual Terrain Project</title>
<corpauthor>VTP</corpauthor>
<publisher>
      <publishername>VTP</publishername>
    </publisher>
<pubdate>2006</pubdate>
<bibliomisc role="url">http://www.vterrain.org/</bibliomisc>
</biblioentry>
<biblioentry id="OBJ Specification">
<abbrev>Wavefront 1995</abbrev>
<title>The OBJ File Format Specification</title>
<corpauthor xreflabel="Wavefront">Wavefront Technologies</corpauthor>
<pubdate>1995</pubdate>
<bibliomisc role="url">http://www.martinreddy.net/gfx/3d/OBJ.spec</bibliomisc>
</biblioentry>
<biblioentry id="Mean">
<abbrev>Weisstein 2004</abbrev>
<title>Sample Mean</title>
<author>
      <surname>Weisstein</surname>
      <firstname>Eric</firstname>
      <othername role="mi">W</othername>
    </author>
<bibliosource role="compilation">MathWorld—A Wolfram Web Resource</bibliosource>
<publisher>
      <publishername>Wolfram Research, Inc</publishername>
      <address format="linespecific">
        <city>Champaign</city>
        <state>IL</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2004</pubdate>
<bibliomisc role="url">http://mathworld.wolfram.com/SampleMean.html</bibliomisc>
</biblioentry>
<biblioentry id="Standard Deviation">
<abbrev>Weisstein 2003</abbrev>
<title>Standard Deviation</title>
<author>
      <surname>Weisstein</surname>
      <firstname>Eric</firstname>
      <othername role="mi">W</othername>
    </author>
<bibliosource role="compilation">MathWorld—A Wolfram Web Resource</bibliosource>
<publisher>
      <publishername>Wolfram Research, Inc</publishername>
      <address format="linespecific">
        <city>Champaign</city>
        <state>IL</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2003</pubdate>
<bibliomisc role="url">http://mathworld.wolfram.com/StandardDeviation.html</bibliomisc>
</biblioentry>
<biblioentry id="Skewness">
<abbrev>Weisstein 2005</abbrev>
<title>Skewness</title>
<author>
      <surname>Weisstein</surname>
      <firstname>Eric</firstname>
      <othername role="mi">W</othername>
    </author>
<bibliosource role="compilation">MathWorld—A Wolfram Web Resource</bibliosource>
<publisher>
      <publishername>Wolfram Research, Inc</publishername>
      <address format="linespecific">
        <city>Champaign</city>
        <state>IL</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2005</pubdate>
<bibliomisc role="url">http://mathworld.wolfram.com/Skewness.html</bibliomisc>
</biblioentry>
<biblioentry id="Kurtosis">
<abbrev>Weisstein 2004</abbrev>
<title>Kurtosis</title>
<author>
      <surname>Weisstein</surname>
      <firstname>Eric</firstname>
      <othername role="mi">W</othername>
    </author>
<bibliosource role="compilation">MathWorld—A Wolfram Web Resource</bibliosource>
<publisher>
      <publishername>Wolfram Research, Inc</publishername>
      <address format="linespecific">
        <city>Champaign</city>
        <state>IL</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2004</pubdate>
<bibliomisc role="url">http://mathworld.wolfram.com/Kurtosis.html</bibliomisc>
</biblioentry>
<biblioentry id="k-Statistic">
<abbrev>Weisstein 2002</abbrev>
<title>k-Statistic</title>
<author>
      <surname>Weisstein</surname>
      <firstname>Eric</firstname>
      <othername role="mi">W</othername>
    </author>
<bibliosource role="compilation">MathWorld—A Wolfram Web Resource</bibliosource>
<publisher>
      <publishername>Wolfram Research, Inc</publishername>
      <address format="linespecific">
        <city>Champaign</city>
        <state>IL</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2002</pubdate>
<bibliomisc role="url">http://mathworld.wolfram.com/k-Statistic.html</bibliomisc>
</biblioentry>
<biblioentry id="Sample Central Moment">
<abbrev>Weisstein 2003</abbrev>
<title>Sample Central Moment</title>
<author>
      <surname>Weisstein</surname>
      <firstname>Eric</firstname>
      <othername role="mi">W</othername>
    </author>
<bibliosource role="compilation">MathWorld—A Wolfram Web Resource</bibliosource>
<publisher>
      <publishername>Wolfram Research, Inc</publishername>
      <address format="linespecific">
        <city>Champaign</city>
        <state>IL</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>2003</pubdate>
<bibliomisc role="url">http://mathworld.wolfram.com/SampleCentralMoment.html</bibliomisc>
</biblioentry>
<biblioentry id="Fluid Simulation" role="website">
<abbrev>Woodhouse 2003</abbrev>
<title>Terrain Generation Using Fluid Simulation</title>
<author>
      <surname>Woodhouse</surname>
      <firstname>Francis</firstname>
    </author>
<bibliosource role="compilation">GameDev.net</bibliosource>
<publisher>
      <publishername>GameDev.net</publishername>
    </publisher>
<pubdate>September 30, 2003</pubdate>
<bibliomisc role="url">http://www.gamedev.net/reference/articles/article2001.asp</bibliomisc>
</biblioentry>
<biblioentry id="Trespasser Postmortem" role="website">
<abbrev>Wyckoff 1999</abbrev>
<title>Postmortem: DreamWorks Interactive's Trespasser</title>
<author>
      <surname>Wyckoff</surname>
      <firstname>Richard</firstname>
    </author>
<bibliosource role="compilation">Gamasutra.com</bibliosource>
<publisher>
      <publishername>CMP Media LLC</publishername>
      <address format="linespecific">
        <city>San Francisco</city>
        <state>CA</state>
        <country>USA</country>
      </address>
    </publisher>
<pubdate>May 14, 1999</pubdate>
<bibliomisc role="url">http://www.gamasutra.com/features/19990514/trespasser_01.htm</bibliomisc>
</biblioentry>
</bibliography>
  <chapter id="Vita" label="Vita" xml:base="vita.xml">
  <title>Vita</title>

  <para>Contact Information</para>
  <para>
    Ryan L. Saunders may be reached by mail at PO Box 753, Bellevue, WA 98009, 
    or by email at saunders@aggienetwork.com.
  </para>

  <para>Education</para>
  <para>
    I received a Bachelor of Science in Computer Engineering from Texas 
    A&amp;M University in 2002. I continued on to pursue my Master of 
    Science also at Texas A&amp;M, graduating in December of 2006.
  </para>

  <para>Professional Experience</para>
  <para>
    My professional experience includes:
  </para>
  <itemizedlist spacing="compact">
    <listitem>
      Hewlett Packard (Richardson, TX) Intern—FORTRAN compiler team
    </listitem>
    <listitem>
        Dynetics, Inc. (Huntsville, AL), Intern—Industrial automation division
    </listitem>
    <listitem>
      Self-employed (College Station, TX), Independent Contractor—Dynamic website development
  </listitem>
    <listitem>
      Microsoft Corporation (Redmond, WA), Software Development Engineer—Microsoft Office (current)
    </listitem>
  </itemizedlist>

  <para>Publications</para>
  <para>
    In the course of my Master's degree studies, I was co-author of a 
    paper, <citetitle>Terrain Generation Using Genetic Algorithms</citetitle>,
    which was accepted to the <citetitle>Genetic and Evolutionary 
    Computation Conference (GECCO) 2005</citetitle>.
  </para>

</chapter>

</book>
